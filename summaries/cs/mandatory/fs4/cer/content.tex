\chapter{Einführung} % 1
	\todo{Content}

	\section{Beispiele} % 1.11, 1.12, 1.13, 1.14, 1.15
		\todo{Content}
	% end

	\section{Was ist ein Roboter?} % 1.17, 1.18
		\todo{Content}

		\subsection{Funktionale Anforderungen} % 1.24, 1.25
			\todo{Content}
		% end
	% end

	\section{Was ist Robotik?} % 1.19, 1.20
		\todo{Content}
	% end

	\section{Typischer Aufbau eines Roboterarms/-beins} % 1.21, 2.9
		\todo{Content}
	% end

	\section{Begriffe} % 1.28
		\todo{Content}

		\subsection{Simulation} % 1.29, 1.30
			\todo{Content}
		% end

		\subsection{Modell} % 1.31, 1.32, 1.33
			\todo{Content}
		% end
	% end

	\section{Aufgaben einer Simulation} % 1.51
		\todo{Content}
	% end
% end

\chapter{Mathematische Grundlagen und Notation} % 2.15
\section{Vektoren} % 2.16
\paragraph{Vektor}
\begin{equation*}
	p =
	\begin{bmatrix}
		p _ x \\
		p _ y \\
		p _ z
	\end{bmatrix}
	=
	\begin{bmatrix}
		p _ 1 \\
		p _ 2 \\
		p _ 3
	\end{bmatrix}
	\in \mathbb{R} ^ 3 = \mathbb{R} ^ { 3 \times 1 } \tag{Spaltenvektor}
\end{equation*}

\paragraph{Nullvektor}
\begin{equation*}
	0 =
	\begin{bmatrix}
		0 \\
		0 \\
		0
	\end{bmatrix}
\end{equation*}

\paragraph{Transponierter Vektor}
\begin{equation*}
	p ^ T =
	\begin{bmatrix}
		p _ 1 & p _ 2 & p _ 3
	\end{bmatrix}
	\in \mathbb{R} ^ { 1 \times 3 } \tag{Zeilenvektor}
\end{equation*}

\paragraph{(Euklidische) Norm eines Vektors}
\begin{equation*}
	\lVert p \rVert = \sqrt{p _ 1 ^ 2 + p _ 2 ^ 2 + p _ 3 ^ 2}
\end{equation*}

\paragraph{Skalarprodukt zweier Vektoren \( p, r \in \mathbb{R} ^ 3 \)}
\begin{equation*}
	\langle p, r \rangle = p ^ T p = p _ 1 r _ 1 + p _ 2 r _ 2 + p _ 3 r _ 3
\end{equation*}

\paragraph{Orthogonale Vektoren \( p \perp r \)}
\begin{equation*}
	\langle p, r \rangle = p ^ T r = 0
\end{equation*}

\paragraph{Winkel \( \Phi \) zwischen zwei Vektoren \( p, r \)}
	\begin{equation*}
		\cos(\Phi) = \frac{p ^ T r}{\lVert p \rVert \cdot \lVert r \rVert}
	\end{equation*}
% end

\section{Matrizen} % 2.17, 2.18, 2.19, 2.20
\paragraph{\( (3 \times 3) \)-Matrix}
\begin{equation*}
	R =
	\begin{bmatrix}
		r _ { 1 1 } & r _ { 1 2 } & r _ { 1 3 } \\
		r _ { 2 1 } & r _ { 2 2 } & r _ { 2 3 } \\
		r _ { 3 1 } & r _ { 3 2 } & r _ { 3 3 }
	\end{bmatrix}
	\in \mathbb{R} ^ { 3 \times 3 }
\end{equation*}

\paragraph{Transponierte Matrix}
\begin{equation*}
	R ^ T =
	\begin{bmatrix}
		r _ { 1 1 } & r _ { 2 1 } & r _ { 3 1 } \\
		r _ { 1 2 } & r _ { 2 2 } & r _ { 3 2 } \\
		r _ { 1 3 } & r _ { 2 3 } & r _ { 3 3 }
	\end{bmatrix}
	\in \mathbb{R} ^ { 3 \times 3 }
\end{equation*}

\paragraph{Einheitsmatrix}
\begin{equation*}
	I = E =
	\begin{bmatrix}
		1 & 0 & 0 \\
		0 & 1 & 0 \\
		ß & 0 & 1
	\end{bmatrix}
	\in \mathbb{R} ^ { 3 \times 3 }
\end{equation*}

\paragraph{Nullmatrix}
\begin{equation*}
	0 =
	\begin{bmatrix}
		0 & 0 & 0 \\
		0 & 0 & 0 \\
		0 & 0 & 0
	\end{bmatrix}
	\in \mathbb{R} ^ { 3 \times 3 }
\end{equation*}

\paragraph{Inverse Matrix \( R ^ { -1 } \)}
\begin{equation*}
	R R ^ { -1 } = E = R ^ { -1 } R
\end{equation*}

\paragraph{Orthonormale Matrizen}
	Für orthonormale (orthogonale und normierte) Matrizen gilt
	\begin{equation*}
		R R ^ T = E \implies R ^ T = R ^ { -1 }
	\end{equation*}
	Außerdem gilt für orthonormale Matrizen:
	\begin{equation*}
		1 = \det(E) = \det(R R ^ T) = \det(R) \det(R ^ T) = (\det(R)) ^ 2 \implies \abs{\det(R)} = 1
	\end{equation*}
	Orthonormale Matrizen mit \( \det(R) = +1 \) heißen \textit{Rechtssystem}, orthonormale Matrizen mit \( \det(R) = -1 \) heißen \textit{Linkssystem}.
% end

\section{Koordinatensysteme} % 2.21
	\begin{itemize}
		\item Koordinatensystem dienen der Beschreibung von \textit{Position} und \textit{Orientierung} von Robotergelenken, Endeffektoren, Objekten in der Umgebung u.v.m..
		\item Oftmals werden \textit{kartesische Rechtskoordinatensysteme} verwendet.
		\item Die Vektoren \( e _ x, e _ y, e _ z \in \mathbb{R} ^ 3 \), welche das Koordinatensystem aufspannen, sind zueinander orthogonale Einheitsvektoren, das heißt sie bilden eine Basis von \( \mathbb{R} \).
	\end{itemize}
% end

\section{Positionsvektor eines Punktes} % 2.22
	\begin{itemize}
		\item Die Position eines Punktes im Raum kann durch einen \textit{Positionsvektor} angegeben werden.
		\item Im dreidimensionalen euklidischen Raum ist dies ein Vektor
			\begin{equation*}
				p =
				\begin{bmatrix}
					p _ x \\
					p _ y \\
					p _ z
				\end{bmatrix}
				= p _ x e _ x + p _ y e _ y + p _ z e _ z
			\end{equation*}
		\item \textbf{Notation:} Bei einem Punktvektor relativ zu einem Koordinatensystem \( S _ a \), wird dies mit \( ^a p \) notiert.
	\end{itemize}
% end

\section{Räumliche Anordnung eines Objektes} % 2.23, 2.24
	\begin{itemize}
		\item Zur Beschreibung der Lage eines Objektes wird ein \textit{lokales Koordinatensystem} erstellt, welches fest mit dem Objekt verbunden ist.
		\item Die Lage dieses Koordinatensystems \( S _ b \) wird mit \( ^ae_x, ^ae_y, ^ae_z \) bezüglich des äußeren Koordinatensystems \( S _ a \) angegeben.
		\item So entstehen durch Verschiebung (Translation) und Verdrehung (Rotation) neue Koordinatensysteme.
	\end{itemize}
% end

\section{Klassische Transformationsbeziehungen} % 2.25
	\begin{itemize}
		\item Eine \textit{klassische Transformationsbeziehung} beim Wechsel von Punktkoordinaten bezüglich \( S _ a \) zu \( S _ b \) wir mit getrennter Translation und Rotation durchgeführt:
			\begin{equation*}
				^ap = \,^ar_b + \,^aR_b \,^bp
			\end{equation*}
		\item \( ^ar_b \) beschreibt die Translation zwischen \( S _ a \) und \( S _ b \).
		\item \( ^aR_b \) beschreibt die Rotation zwischen \( S _ a \) und \( S _ b \).
		\item Die Koordinaten der Einheitsvektoren in \( S _ b \) dargestellt in \( S _ a \) entsprechen den Spalten der Rotationsmatrix \( ^aR_b \).
			\begin{equation*}
				^aR_b =
				\begin{bmatrix}[c|c|c]
					^ae_{xb} & ^ae_{yb} & ^ae_{zb}
				\end{bmatrix}
			\end{equation*}
	\end{itemize}
% end

\section{Homogene Transformationsbeziehungen} % 2.26
	\label{sec:homogeneMatrix}

	\begin{itemize}
		\item Statt einer klassischen Transformation kann auch eine \textit{homogene Transformation} durchgeführt werden.
		\item Diese Nutzt nur eine Matrix für die Translation und die Rotation.
			\begin{equation*}
				^a\hat{p} =
				\begin{bmatrix}
					^ap \\ \hline
					1
				\end{bmatrix}
				=
				\begin{bmatrix}[ccc|c]
					  & ^aR_b &   & ^ar_b \\ \hline
					0 & 0     & 0 & 1
				\end{bmatrix}
				\cdot
				\begin{bmatrix}
					^bp \\ \hline
					1
				\end{bmatrix}
				= \,^aT_b \cdot \,^b\hat{p}
			\end{equation*}
		\item Die \textit{homogene Transformationsmatrix} wird als \( ^aT_b \) bezeichnet.
	\end{itemize}
% end

\section{Lösungsansätze für mathematische Modelle} % 1.61, 1.62
	Zur Lösung von mathematischen Modellen gibt mehrere Möglichkeiten:
	\begin{description}
		\item[Analytisch] Das Problem mit exakt gelöst, es sind keine Vereinfachungen/Näherungen nötig. Dies ist nur in wenigen Fällen (effizient) möglich.
		\item[Heuristisch] \enquote{Trial \& Error} gemäß einer bestimmten Strategie, vor allem nützlich bei Problemen der diskreten Optimierung.
		\item[Direkt-Numerisch] Der numerische Algorithmus liefert exakte Lösungen (mglw. mit Rundungsfehlern). Dies ist ein klarer Algorithmus und eine Heuristik mehr, das Erreichen des Ziels ist stets sichergestellt.
		\item[Approximativ-Numerisch] Iterative Näherungsverfahren für angenäherte Beziehungen (Gleichungen). Dies stellt den häufigsten Fall der Lösungsstrategien dar und ist der Hauptbestandteil der numerischen Simulation.
	\end{description}

	Analytische und Heuristische Verfahren werden im Vergleich zu den numerischen Verfahren selten eingesetzt, da die meisten Probleme analytisch zu schwer zu lösen sind und Heuristiken für die meisten Probleme nicht oder nur langsam konvergieren.
% end

\section{Numerik} %  
	\subsection{Grundlegende Numerische Verfahren}
		\todo{Content}

		% Vorwärtsdifferenzenquotient
		% Rückwärtsdifferenenquotient
		% Quadratregel
		% Trapezregel
	% end

	\subsection{Lösung nichtlinearer Gleichungsmodelle} % 2.53
		\paragraph{Aufgabe}
			Punkte \( x _ s \in \mathbb{R} ^ n \) finden, sodass
			\begin{equation*}
				F(x _ s) = 0 \iff
				\begin{matrix}
					F _ 1 (x _ 1, \cdots, x _ n) = 0 \\
					\vdots                           \\
					F _ n (x _ 1, \cdots, x _ n) = 0
				\end{matrix}
			\end{equation*}
			erfüllt ist.

			Sämtliche Gleichungen können in diese Form überführt werden.
		% end

		\subsubsection{Fixpunktiteration} % 2.55, 2.56, 2.57
			\begin{itemize}
				\item Die Fixpunktiteration ist ein einfacher Algorithmus, um einen Fixpunkt einer Funktion zu finden.
				\item Somit muss die Gleichung \( F(x) = 0 \) in eine Fixpunktgleichung \( x = g(x) \), bspw. \( g(x) \coloneqq F(x) + x \) umgebaut werden.
				\item Es muss außerdem ein Startwert \( x _ 0 \) gegeben sein, welcher eine Näherung der Lösung darstellt.
				\item Dann gilt für die Iteration:
					\begin{equation*}
						x_ { k + 1 } \coloneqq g(x _ k) \quad\quad\quad k \in \mathbb{N}
					\end{equation*}
				\item Das Verfahren terminiert, wenn es nahe genug bei der Lösung ist, die maximale Iterationsanzahl erreicht ist oder kein Fortschritt ersichtlich ist.
				\item Konvergenzbedingung: Sei \( x _ s = g(x _ s) \), dann muss \( x _ 0 \) nahe genug bei \( x _ s \) liegen und alle Eigenwerte von \( \frac{\partial g}{\partial x} (x _ s) \) müssen im Einheitskreis liegen (d.h. \( \forall \lambda : \abs{\lambda} < 1 \)). \\ Dann konvergiert \( x _ k \rightarrow x _ s \).
			\end{itemize}

			\paragraph{Konvergenzhilfe: Relaxationsmatrix} % 2.59
				\begin{itemize}
					\item Da die Konvergenz nicht garantiert ist, kann eine \textit{Relaxationsmatrix} \( A \in \mathbb{R} ^ { n \times n } \) vorgeschaltet werden, mit deren Hilfe die Konvergenz verbessert werden kann:
						\begin{equation*}
							g(x) \coloneqq A \cdot F(x) + x
						\end{equation*}
					\item Diese Relaxationsmatrix muss konstant und regulär sein.
					\item Als einfachster Ansatz kann eine Diagonalmatrix (oder sogar die Einheitsmatrix) verwendet werden.
					\item Eine optimale Relaxationsmatrix ergibt sich durch
						\begin{equation*}
							A = -\bigg[\frac{\partial F}{\partial x} (x _ s)\bigg] ^ {-1} \quad\quad\quad F(x _ s) = 0
						\end{equation*}
					\item Durch die Wahl einer optimalen Relaxationsmatrix ist eine konvergente FPI immer möglich (sofern eine Lösung existiert).
				\end{itemize}
			% end
		% end

		\subsubsection{Newton-Verfahren} % 2.62, 2.63, 2.64, 2.65
			\begin{itemize}
				\item Das Newton-Verfahren ist ein Algorithmus, um eine Nullstelle einer Funktion zu finden.
				\item Das Newton-Verfahren löst somit eine Gleichung \( F(x) = 0 \).
				\item Hierzu muss ein Startwert \( x _ 0 \) gegeben sein, welcher eine Näherung der Lösung darstellt.
				\item Dann gilt für die Iteration:
					\begin{equation*}
						x _ { k + 1 } \coloneqq x _ k + \Delta x _ k \quad\quad\quad \Delta x \coloneqq - \bigg[ \frac{\partial F}{\partial x} (x _ k) \bigg] ^ {-1} \cdot F(x _ k)
					\end{equation*}
					Die Berechnung von \( \Delta x \) glückt nur, wenn \( \frac{\partial F}{\partial x} (x _ k) \) regulär ist. Ansonsten muss die Gleichung
					\begin{equation*}
						0 = F(x _ k) + \frac{\partial F}{\partial x} (x _ k) \cdot \Delta x _ k
					\end{equation*}
					gelöst werden.
				\item Das Verfahren terminiert, wenn es nahe genug bei der Lösung ist, die maximale Iterationsanzahl erreicht ist oder kein Fortschritt ersichtlich ist.
				\item Konvergenzbedingung: Sei \( x \) so, dass \( F(x) = 0 \) gilt, dann muss \( x _ 0 \) nahe genug bei \( x \) liegen.
			\end{itemize}

			\paragraph{Konvergenz: Schrittweitensteuerung} % 2.71, 2.72
				\begin{itemize}
					\item Bei hoch-nichtlinearen Funktionen kann es passieren, dass über die Nullstele drüber iteriert wird.
					\item Durch eine geeignete Schrittweitensteuerung \( \alpha \) kann dies verhindert werden (mit \( 0 < \alpha _ \text{min} \leq \alpha _ k \leq 1 \)):
						\begin{equation*}
							x _ { k + 1 } = x _ k + \alpha _ k \cdot \Delta x _ k
						\end{equation*}
					\item \( \alpha \) sollte nur \enquote{so klein wie nötig} und \enquote{so groß wie möglich} sein, da nur für \( \alpha \approx 1 \) quadratische Konvergenz zu erwarten ist.
					\item Die Schrittweite kann beispielsweise durch Minimierung von
						\begin{equation*}
							\varphi(\alpha) = \lVert F(x _ k + \alpha \cdot \Delta x _ k) \rVert ^ 2 _ 2 = \sum_{i = 1}^{n} (F _ i (x _ k + \alpha \cdot \Delta x _ k))
						\end{equation*}
						bestimmt werden.
				\end{itemize}
			% end

			\paragraph{Berechnung der Jacobi-Matrix} % 2.74, 2.75
				\begin{itemize}
					\item Die Berechnung der Jacobi-Matrix gestaltet sich oft schwierig.
					\item Außerdem: Ist ein Eintrag in der Jacobi-Matrix falsch, konvergiert das Newton-Verfahren nur schlecht oder gar nicht.
					\item Somit wird in der Praxis häufig \textit{Vorwärtsdifferenzen-Approximation} verwendet.
					\item Ist \( F(x) \) nichtlinear, so ver-\(n\)-facht sich der Berechnungsaufwand durch die VD-Approximation.
					\item Es gibt noch viele weitere Lösungsmethoden für die Jacobi-Matrix.
						\begin{itemize}
							\item Untersuchung der Jacobi-Matrix auf \textit{Dünnbesetztheit} und Überspringen der Einträge \( x _ {ij} \approx 0 \). Berechnung der restlichen Einträge bspw. mit VD-Approximation.
							\item Ersetzung der Jacobi-Matrix \( \frac{\partial F}{\partial x} (x _ k) \) mit einer \textit{konstanten Matrix}, bspw. \( \frac{\partial F}{\partial x} (x _ 0) \).
								\begin{itemize}
									\item Das Verfahren ist damit nicht mehr quadratisch, sondern höchstens linear konvergent.
									\item Sollte es dennoch konvergieren, ist es häufig schneller als ein \enquote{normales} Newton-Verfahren.
								\end{itemize}
							\item \textit{Schrittweise Aufaddierung (\enquote{Updates})} einer Approximation der Jacobi-Matrix (\enquote{Quasi-Newton-Verfahren}).
						\end{itemize}
				\end{itemize}
			% end
		% end

		\subsubsection{Vergleich FPI \( \leftrightarrow \) Newton} % 2.76
			\paragraph{Fixpunktiteration}
				\begin{itemize}
					\item Ausgeglichene globale Konvergenz, aber schlechte lokale Konvergenz.
					\item Geringer Rechenaufwand pro Iteration.
					\item Geringer Implementationsaufwand.
				\end{itemize}
			% end

			\paragraph{Newton-Verfahren}
				\begin{itemize}
					\item Schlechte globale Konvergenz, aber sehr gut lokale Konvergenz.
					\item Hoher Rechenaufwand pro Iteration.
					\item Hoher Implementationsaufwand.
				\end{itemize}
			% end
		% end

		\subsection{Numerische Simulation} %  
			Siehe Kapitel \ref{c:numerischesimulation}.
		% end

		\subsection{Numerische Simulation zeitkontinuierlicher Modelle} %  
			Siehe Kapitel \ref{c:numerischesimulationtime}
		% end
	% end

	\section{Differentialgleichungen} %  
		Allgemeiner Aufbau eines AWP 1. Ordnung:
		\begin{equation*}
			\dot{x}(t) = f(x(t), u(t)) \quad\quad x(0) = x _ 0 \in \mathbb{R} ^ n
		\end{equation*}
		\begin{description}
			\item[\( f(x, u) \)] Funktion der DGL.
			\item[\( x \)] Zustand des Systems zu einem Zeitpunkt \( t \).
			\item[\( u \)] Stellgrößen zu einem Zeitpunkt \( t \).
		\end{description}

		eine solche Differentialgleichung mit Anfangswert (Anfangswertproblem) kann auch als
		\begin{equation*}
			x(t) = x _ i + \int_{0}^{t} \! f(x(\tau), u(\tau)) \, d\!\tau
		\end{equation*}
		geschrieben werden.

		\subsection{Transformation auf System 1. Ordnung} % 3.13
			Jedes System von gewöhnlichen Differentialgleichungen höherer Ordnung kann in ein System 1. Ordnung transformiert werden.

			Bei nichtlinearen System kann das System nicht in der Form \( \dot{x} = Ax + b \) aufgeschrieben werden, sondern wird in der Form \( \dot{x} = A(x) \) notiert, wobei \( A \) ein Vektor ist.

			\paragraph{Beispiel: Schwingung einer Masse an einer Feder}
				\begin{itemize}
					\item Ausgangsdifferentialgleichung 2. Ordnung:
						\begin{equation*}
							\ddot{x} + \frac{k}{m} x = 0
						\end{equation*}
					\item Umformung in eine explizite DGL:
						\begin{equation*}
							\ddot{x} + \frac{k}{m} x = 0 \iff \ddot{x} = - \frac{k}{m} x
						\end{equation*}
					\item Einführung weiterer Zustandsvariablen zur Transformation:
						\begin{align*}
							\hat{x} _ 1 & \coloneqq x       \\
							\hat{x} _ 2 & \coloneqq \dot{x} \\
							\hat{x}     & \coloneqq
							\begin{bmatrix}
								\hat{x} _ 1 \\
								\hat{x} _ 2
							\end{bmatrix}
						\end{align*}
					\item Transformation in ein DGL-System 1. Ordnung der Form \( \dot{\hat{x}} = A\hat{x} \):
						\begin{align*}
							\begin{bmatrix}
								\dot{\hat{x}} _ 1 \\
								\dot{\hat{x}} _ 2
							\end{bmatrix}
							=
							\begin{bmatrix}
								0            & 1 \\
								-\frac{k}{m} & 0 \\
							\end{bmatrix}
							\cdot
							\begin{bmatrix}
								\hat{x} _ 1 \\
								\hat{x} _ 2
							\end{bmatrix}
						\end{align*}
				\end{itemize}
			% end
		% end

		\subsection{Autonomisierung nichtautonomer DGL-Systeme} % 3.14
			Jedes nicht-autonome System von DGL kann mit Einführung einer neuen Zeitvariablen autonomisiert werden.

			\paragraph{Beispiel}
				\textit{Dieses Beispiel wandelt zeitgleich ein DGL-System 2. Ordnung ist ein System 1. Ordnung um.}

				\begin{itemize}
					\item Das folgende nichtautonome DGL-System 2. Ordnung soll in ein autonomes System 1. Ordnung umgewandelt werden:
						\begin{align*}
							0 & = \frac{1}{2} \dot{x} _ 3 - \ddot{x} _ 2 + 5 x _ 1      \\
							1 & = -1 \ddot{x} _ 3 + x _ 1 + \dot{x} _ 2 - \frac{4}{5} t \\
							0 & = \dot{x} _ 3 - 3 x _ 2 + \ddot{x} _ 1 + t
						\end{align*}
					\item Zuerst werden die einzelnen Gleichungen in explizite DGL umgeformt:
						\begin{align*}
							\ddot{x} _ 2 & = \frac{1}{2} \dot{x} _ 3 + 5 x _ 1                                         \\
							\ddot{x} _ 3 & = \frac{1}{2} x _ 1 + \frac{1}{2} \dot{x} _ 2 - \frac{2}{5} t - \frac{1}{2} \\
							\ddot{x} _ 1 & = 3 x _ 2 - \dot{x} _ 3 - t
						\end{align*}
					\item Als nächstes werden weitere Zustandsvariablen für die Transformation eingeführt:
						\begin{align*}
							\hat{x} _ 1 & \coloneqq x _ 1, \quad \hat{x} _ 2 \coloneqq x _ 2, \quad \hat{x} _ 3 \coloneqq x _ 3                   \\
							\hat{x} _ 4 & \coloneqq \dot{x} _ 1, \quad \hat{x} _ 5 \coloneqq \dot{x} _ 2, \quad \hat{x} _ 6 \coloneqq \dot{x} _ 3 \\
							\hat{x} _ 7 & \coloneqq t \tag{Autonomisierung}                                                                       \\
							\hat{x}     & \coloneqq
							\begin{bmatrix}
								\hat{x} _ 1 & \hat{x} _ 2 & \hat{x} _ 3 & \hat{x} _ 4 & \hat{x} _ 5 & \hat{x} _ 6 & \hat{x} _ 7
							\end{bmatrix} ^ T
						\end{align*}
					\item Nun wird das System autonomisiert und in ein System 1. Ordnung der Form \( \dot{\hat{x}} = A \hat{x} + b \) transformiert:
						\begin{align*}
							\begin{bmatrix}
								\dot{\hat{x}} _ 1 \\
								\dot{\hat{x}} _ 2 \\
								\dot{\hat{x}} _ 3 \\
								\dot{\hat{x}} _ 4 \\
								\dot{\hat{x}} _ 5 \\
								\dot{\hat{x}} _ 6 \\
								\dot{\hat{x}} _ 7
							\end{bmatrix}
							=
							\begin{bmatrix}
								0           & 0 & 0 & 1 & 0           & 0            & 0            \\
								0           & 0 & 0 & 0 & 1           & 0            & 0            \\
								0           & 0 & 0 & 0 & 0           & 1            & 0            \\
								0           & 3 & 0 & 0 & 0           & -1           & -1           \\
								5           & 0 & 0 & 0 & 0           & -\frac{1}{2} & 0            \\
								\frac{1}{2} & 0 & 0 & 0 & \frac{1}{2} & 0            & -\frac{2}{5} \\
								0           & 0 & 0 & 0 & 0           & 0            & 0
							\end{bmatrix}
							\cdot
							\begin{bmatrix}
								\hat{x} _ 1 \\
								\hat{x} _ 2 \\
								\hat{x} _ 3 \\
								\hat{x} _ 4 \\
								\hat{x} _ 5 \\
								\hat{x} _ 6 \\
								\hat{x} _ 7
							\end{bmatrix}
							+
							\begin{bmatrix}
								0            \\
								0            \\
								0            \\
								0            \\
								0            \\
								-\frac{1}{2} \\
								1
							\end{bmatrix}
						\end{align*}
				\end{itemize}
			% end
		% end

		\subsection{Richtungsfelder} % 3.18
			\todo{Content}
		% end

		\subsection{Lösbarkeit} % 3.17, 3.19
			\begin{itemize}
				\item Die allgemeine Lösung von \( \dot{x} = f(x) \), \( x \in \mathbb{R} ^ n \) hängt von \( n \) Integrationskonstanten ab, die z.B. durch \( n \) Anfangswerte festgelegt werden: \( x(0) = x _ 0 \in \mathbb{R} ^ n \).
				\item Allgemein hat ein \textit{autonomes} DGL-System \textit{1. Ordnung} mit Anfangswert eine \textit{eindeutige Lösung} \( x(t), t > 0 \), falls die Funktion \( f(x) \) Lipschitz-Stetig ist (Satz von Picard-Lindelöff).
				\item Die Funktion \( f(x) \)i st Lipschitz-Stetig gdw. \[ \exists L > 0 : \forall x _ 1, x _ 2 \in \mathbb{R} ^ n : (\lVert f(x _ 1) - f(x _ 2) \rVert \leq L \lVert x _ 1 - x _ 2 \rVert \] gilt mit einer beliebigen Vektornorm \( \lVert \cdot \rVert \).
			\end{itemize}
		% end

		\subsection{Gleichgewichtslösungen} % 3.20, 3.21, 3.23
			\begin{itemize}
				\item Ein Zustand \( x _ s \) heißt \textit{stationärer Zustand} (oder \textit{Ruhezustand}), wenn \( x(t) \rightarrow x _ s \) mit \( t \rightarrow \infty \) gelten.
				\item Sei \( u(t) = u _ s \) gegeben.
				\item Falls \( x _ s \) existiert, muss \( \dot{x}(t) \rightarrow 0 \) für \( t \rightarrow \infty \) und somit \( 0 = f(x _ s, u _ s) \) gelten.
				\item Dies entspricht einem (i.A. nichtlinearen) System von \(n\) Gleichungen \(f_j\) zur Bestimmung von \(n\) Unbekannten \(x_{s,i}\).
					\begin{itemize}
						\item Die Frage nach der Existenz eines Ruhezustandes und dessen Eindeutigkeit lässt sich also auf die Frage nach der Lösbarkeit des Gleichungssystems zurück führen.
						\item Für ein lineares Gleichungssystem \( 0 = Ax_s + Bu_s \iff -Bu_s = Ax_s \) heißt dies, das System ist eindeutig lösbar, wenn \(A\) quadratisch und regulär ist (d.h. \( \det(A) \neq 0 \)).
					\end{itemize}
				\item Jede Lösung \( x _ s \in \mathbb{R} ^ n \) heißt \textit{Gleichgewichtslösung}.
			\end{itemize}
		% end

		\subsection{Linearisierung um die Ruhelage} % 3.42, 3.46, 3.47, 3.48
			\label{sec:linearisierung}

			\begin{itemize}
				\item Oftmals ist es nicht (effizient) möglich, ein nichtlineares DGL-System \( \dot{x} = f(x, u) \in \mathbb{R} ^ n \) regeln.
				\item Das System kann um die Ruhelage linearisiert werden, sodass es einfacher zu regeln ist.
				\item Der Prozess der Linearisierung stützt sich auf Taylor-Entwicklungen um \( (x _ s, u _ s) \) bis zum linearen Term.
				\item Die Linearisierung läuft nun wie folgt ab:
					\begin{itemize}
						\item Sei \( \dot{x} \eqqcolon (f _ 1, \cdots, f _ n) \eqqcolon f \).
						\item Nun werden folgende Jacobi-Matrizen gebildet:
							\begin{align*}
								A & \coloneqq \frac{\partial f}{\partial x} (x _ s, u _ s) \\
								B & \coloneqq \frac{\partial f}{\partial u} (x _ s, u _ s)
							\end{align*}
							Es wird somit einmal die \(n\)-Dimensionale Funktion in Richtung \(x\) und einmal in Richtung \(u\) abgeleitet.
						\item Damit ergibt sich die folgende, linearisierte, Differentialgleichung (mit \( \Delta u \) als Regelparameter):
							\begin{align*}
								{(\Delta x)}' & = A \cdot \Delta x + B \cdot \Delta u                                                                                       \\
								              & = \frac{\partial f}{\partial x} (x _ s, u _ s) \cdot \Delta x + \frac{\partial f}{\partial u} (x _ s, u _ s) \cdot \Delta u
							\end{align*}
					\end{itemize}
				\item Eine Linearisierung ist nicht möglich, wenn der Ruhezustand mit einer Sprung- oder Knickstelle (oder einer anderen Ausnahmestelle) zusammen fällt oder in der engeren Umgebung liegt, da die Funktion in diesen Punkten nicht differenzierbar ist.
			\end{itemize}
		% end

		\subsection{Lösung von \( (\Delta x)' = A \cdot \Delta x \)} % 3.50, 3.51, 3.52, 3.103, 3.104
			\begin{itemize}
				\item Eine DGL \( (\Delta x)' = A \cdot \Delta x \) lässt sich allgemein über die Eigenwerte \( \lambda _ i \) und den dazugehörigen Eigenvektoren \( v _ i \) der Matrix \(A\) lösen.
				\item Die Lösung lautet dann \( \Delta x = \sum _ i x _ i \) für alle \( i \) mit unterschiedlichen (wobei für \( z \in \mathbb{C} \) gilt \( z = \bar{z} \)) \( \lambda _ i \) und folgenden \( x _ i \):
					\begin{itemize}
						\item Falls \( \lambda _ i \in \mathbb{R} \):
							\begin{equation*}
								x _ i = c _ i \cdot e ^ { \lambda _ i t }
							\end{equation*}
						\item Falls \( \lambda _ i \in \mathbb{C} \setminus \mathbb{R} \)
							\begin{align*}
								x _ i              & = c _ i \cdot l _ { i, \Re } (t) + i \cdot d _ i \cdot l _ { i, \Im } (t) \\
								l _ { i, \Re } (t) & \coloneqq e ^ {-t} (\Re(v _ i) \cdot \cos(t) - \Im(v _ i) \cdot \sin(t))  \\
								l _ { i, \Re } (t) & \coloneqq e ^ {-t} (\Re(v _ i) \cdot \sin(t) - \Im(v _ i) \cdot \cos(t))
							\end{align*}
					\end{itemize}
				\item Die Koeffizienten \( c _ i, d _ i \) ergeben sich aus den Anfangswerten.
			\end{itemize}
		% end

		\subsection{Stabilität von Differentialgleichungen} % 3.55, 3.56, 3.57, 3.58
			\label{sec:stabilitydgl}

			\begin{itemize}
				\item Die Eigenwerte \( \lambda _ i \), \( i = 1, \cdots, n \) bestimmen die \textit{Stabilität} des Systems und könne
					\begin{itemize}
						\item reell,
						\item konjugiert komplex,
						\item einfach oder
						\item mehrfach sein,
					\end{itemize}
				\item Für die Stabilität ist das Vorzeichen des reellen Teils \( \Re(\lambda _ i) \) entscheidend:
					\begin{itemize}
						\item Bei \textit{nur negativen reellen Eigenwerten} unterliegt das System einer aperiodischen Dämpfung und ist somit \textit{stabil}.
						\item Bei \textit{mindestens einem reellen echt-positivem Eigenwert} wächst die Eigenbewegung mit \( t \rightarrow \infty \) und das System ist somit \textit{instabil}.
						\item Bei \textit{nur komplexen Eigenwerten mit \( \Re(\lambda _ i) < 0 \)} liegt eine gedämpfte Oszillation vor, das System ist somit \textit{stabil}.
						\item Bei \textit{mindestens einem komplexen Eigenwert mit \( \Re(\lambda _ is) \)} liegt eine ungedämpfte Oszillation vor, das System ist somit \textit{instabil}.
					\end{itemize}
				\item Nach A. M. Ljapunov gilt:
					\begin{itemize}
						\item Das System ist stabil, wenn alle Eigenwerte negative Realanteile aufweisen.
						\item Das System ist instabil, wenn mindestens ein Eigenwert einen positiven Realanteil aufweist.
						\item Es kann keine Aussage getroffen werden, wenn mindestens ein Eigenwert einen Realanteil Null aufweist und alle übrigen Eigenwerte einen negativen Realanteil aufweisen.
					\end{itemize}
			\end{itemize}
		% end

		\subsection{Zeitcharakteristik von Differentialgleichungen}
			\label{sec:mathezeitCharakteristik}

			Die Zeitcharakteristik eines linearen oder linearisierten Differentialgleichungssystems \( (\Delta x)' = A \cdot \Delta x \) kann durch die Eigenwerte \( \lambda _ i \) der Matrix \(A\) bestimmt werden. Dabei wird jedem Eigenwert \(\lambda_i\) eine Zeitcharakteristik \( T_i \) wird folgt zugewiesen:
			\begin{equation*}
				T _ i =
				\begin{cases}
					\frac{1}{\abs{\lambda _ i}}                                                              & \lambda _ i \in \mathbb{R}                                                             \\
					\frac{2\pi}{\abs{\lambda _ i}}                                                           & \lambda _ i \in \mathbb{C} \land \Re(\lambda _ i) = 0                                  \\
					\min \Big\{ \frac{1}{\abs{\Re(\lambda _ i)}}, \frac{2\pi}{\abs{\Im(\lambda _ i)}} \Big\} & \lambda _ i \in \mathbb{C} \land \Re(\lambda _ i) \neq 0 \land \Re(\lambda _ i) \neq 0
				\end{cases}
			\end{equation*}

			Dann werden die minimalen und maximalen Zeitcharakteristika folgendermaßen zugewiesen:
			\begin{align*}
				T _ {\min} & = \min\limits _ i (T _ i) \\
				T _ {\max} & = \max\limits _ i (T _ i)
			\end{align*}
		% end

		\subsection{Steife Differentialgleichung} % 3.107
			\label{sec:steifedgl}

			\begin{itemize}
				\item Eine stabile Differentialgleichung mit \textit{sehr unterschiedlichen Zeitcharakteristika} wird \textit{steife Differentialgleichung} genannt.
				\item Als Maß der Steifigkeit wird das Verhältnis der minimalen und maximalen Zeitkonstanten \( \frac{T_\text{max}}{T_\text{min}} \) angesehen.
				\item Numerische Lösungen steifer Differentialgleichungen mit explizitem Integrationsverfahren benötigen hohe Rechenzeiten proportional zu \( \frac{T_\text{max}}{T_\text{min}} \). \\ Mit impliziten Verfahren kann dieses Problem gelöst werden.
				\item Ein solch steifes Verhalten ist zu erwarten, wenn für \( \dot{x} = f(x, u) \) die Jacobi-Matrix \( \frac{\partial f}{\partial x}(x, u) \) Eigenwerte \( \lambda _ i \) mit Realanteil \( \Re(\lambda) \ll 0 \) sind.
			\end{itemize}
		% end

		\subsection{Unstetige rechte Seite} % 3.108
			\begin{itemize}
				\item Ist die rechte Seite einer Differentialgleichung \( f(x, u) \) unstetig, so kann dies zu Problem bei der numerischen Integration führen.
				\item Mit \textit{Schaltpunkten} und \textit{abschnittsweiser} Berechnung kann dies gelöst werden.
				\item Für weitere Informationen siehe Abschnitt \ref{sec:integrationunstetig}.
			\end{itemize}
		% end
	% end
% end

\chapter{Modellung und Simulation mit nichtlinearen Gleichungsmodellen} % 2
	\section{System und Modell: Notation} % 2.3, 2.4
		\begin{description}
			\item[\(u\)] Steuergrößen, kontrollierbar (Systemeingang)
			\item[\(z\)] Störgrößen, nicht kontrollierbar (Systemeinang)
			\item[\(p\)] Systemparameter, konstant während eines Systemlaufes
			\item[\(x\)] Systemzustand, vollständige Charakterisierung des Systems
			\item[\(y\)] Systemausgang
		\end{description}

		\todo{Vielleicht ein Bildchen malen?}

		\textit{In diesem Kapitel wird angenommen, dass \( z = 0 \) und \( y = x \) gilt.}
	% end

	\section{Explizite vs. Implizite Gleichungsmodelle} % 2.5
		\paragraph{Explizite Gleichungsmodelle}
			Explizite Gleichungsmodelle sind zu der interessanten Variable \( x \) aufgelöst und können meist schnell berechnet werden.

			\begin{equation*}
				x = F(u) \iff
				\begin{bmatrix}
					x _ 1  \\
					\vdots \\
					x _ { n _ x }
				\end{bmatrix}
				=
				\begin{bmatrix}
					F _ 1 (u _ 1, \cdots, u _ { n _ u }) \\
					\vdots                               \\
					F _ { n _ x } (u _ 1, \cdots, u _ { n _ u })
				\end{bmatrix}
			\end{equation*}
			wobei \( F : \mathbb{R} ^ { n _ u } \rightarrow \mathbb{R} ^ { n _ x } \).
		% end

		\paragraph{Implizite Gleichungsmodelle}
			Implizite Gleichungsmodelle sind nicht zu der interessanten Variable \( x \) aufgelöst und erfordern meist mehr Rechenaufwand.

			\begin{equation*}
				0 = F(x, u) \iff
				\begin{bmatrix}
					0      \\
					\vdots \\
					0
				\end{bmatrix}
				=
				\begin{bmatrix}
					F _ 1 (x _ 1, \cdots, x _ { n _ x }, u _ 1, \cdots, u _ { n _ u }) \\
					\vdots                                                             \\
					F _ { n _ x } (x _ 1, \cdots, x _ { n _ x }, u _ 1, \cdots, u _ { n _ u })
				\end{bmatrix}
			\end{equation*}
			wobei \( F : \mathbb{R} ^ { n _ x \times n _ u } \rightarrow \mathbb{R} ^ { n _ x } \).
		% end
	% end

	\section{Aufbau von Roboterarmen/-beinen} % 2.10
		\begin{itemize}
			\item Ein Roboterarm/-bein ist eine offene und starre kinematische Kette mit
				\begin{itemize}
					\item Einer Menge an starren Körpern, den \textit{links}, die
					\item durch Gelenke, den \textit{joints}, in einer Kette verbunden sind.
				\end{itemize}
			\item Überlicherweise haben die elementaren Gelenke nur einen Bewegungsfreiheitsgrad:
				\begin{itemize}
					\item Drehgelenke, welche in einer Achse rotieren können und
					\item Schubgelenke, welche ihre Länge ändern können
				\end{itemize}
			\item Die Gelenkstellung des \(i\)-ten Gelenks wird angegeben als:
				\begin{equation*}
					q _ i =
					\begin{cases}
						\text{Winkel } \Theta _ i & \text{bei Drehgelenken}  \\
						\text{Strecke} d _ i      & \text{bei Schubgelenken}
					\end{cases}
				\end{equation*}
		\end{itemize}

		\subsection{Koordinatensysteme} % 2.12, 2.13
			\begin{itemize}
				\item Zur Abbildung der Positionen der Gelenke und des Endeffektors wird an jedem Gelenk ein Koordinatensystem befestigt.
				\item Mit diesen \( n + 1 \) Koordinatensystemen kann die Vorwärtskinematik (die Hinrichtung) sehr einfach berechnet werden.
				\item Siehe hierzu \ref{sec:kinematik}.
			\end{itemize}
		% end
	% end

	\section{Vorwärts-/Rückwärtsmodell} % 2.6
		\begin{itemize}
			\item Das \textit{Vorwärtsmodell} eines Systems beschreibt, wie aus gegebenen Gelenkstellungen die Position eines Endeffektors berechnet werden kann.
			\item Das \textit{Rückwärtsmodell} oder auch \textit{inverses Modell} eines Systems beschreibt, wie aus gegebener Position eines Endeffektors die Gelenkstellungen berechnet werden können.
		\end{itemize}
	% end

	\section{Vorwärtskinematikmodell} % 2.11, 2.12, 2.13 2.28, 2.29, 2.34, 2.40
		\label{sec:kinematik}

		\begin{itemize}
			\item Sei \( n \) die Anzahl der Gelenke der kinematischen Kette. Dann ist \( S _ 0 \) das Weltkoordinatensystem und \( S _ n \) das Koordinatensystem des Endeffektors.
			\item Das \textit{Vorwärtskinematikmodell} eines Roboters ordnet den gegebenen Gelenkstellungen \( q _ 1, \cdots, q _ n \) eine Rotation \( ^{n-1}R_n \) und Position \( ^{n-1}r_n \) des Endeffektors zu.
			\item Da an jedem Gelenk ein Koordinatensystem befestigt ist, kann die Vorwärtskinematik einfach durch Kombination der lokalen homogenen Transformationsmatrizen gebildet werden:
				\begin{equation*}
					^0T_1 \times \cdots \times \,^{n-1}T_n =
					\begin{bmatrix}[ccc|c]
						  & ^0R_n &   & ^0R_n \\ \hline
						0 & 0     & 0 & 1
					\end{bmatrix}
				\end{equation*}
				Dann beschreibt \( ^0R_n \) die Rotation und \( ^0r_n \) die Lage des Endeffektors bezüglich des Weltkoordinatensystems.
			\item Eine lokale Transformationsmatrix \( ^iT_{i+1} \) beschreibt die Lage des Koordinatensystems \( S _ { i + 1 } \) in Bezug auf das Koordinatensystem \( S _ i \) und stellt eine homogene Transformationsmatrix (siehe \ref{sec:homogeneMatrix}) dar.
		\end{itemize}

		\subsection{DH-Konvention} % 2.30, 2.31, 2.32
			Die Denavit-Hartenberg (DH) Konvention ist eine Konvention zur Angabe der Freiheitsgrade eines Gelenkes.

			Dazu haben die angebrachten Koordinatensysteme folgende Eigenschaften zu erfüllen:
			\begin{itemize}
				\item Die Koordinatensysteme liegen in den Bewegungsachsen.
				\item Die \( z _ { i - 1 } \)-Achse liegt entlang der Bewegungsachse des Gelenks.
				\item Die \( x _ i \)-Achse steht senkrecht zur \( z _ { i - 1 } \)- und \( z _ i \)-Achse, zeigt von ihr weg und hat einen Schittpunkt mit ihr.
				\item Die \( y _ i \)-Achse muss mit \( z _ i \)- und \( x _ i \)-Achse ein Rechtskoordinatensystem bilden.
			\end{itemize}

			Sind alle diese Anforderungen erfüllt, so werden nur 4 Parameter benötigt, um die gesamte Bewegung zu beschreiben:

			\begin{table}[H]
				\centering
				\begin{tabular}{l | c | p{7cm} | l}
					Bedeutung    & Symbol           & Definition                                                                                                & Wert                        \\ \hline
					Gelenkwinkel & \( \Theta _ i \) & Winkel zwischen \( x _ { i - 1} \)- und \( x _ i \)-Achse um die \( z _ { i - 1 } \)-Achse.               & Variabel, wenn Drehgelenk   \\
					Verschiebung & \( d _ i \)      & Entfernung des Ursprungs von \( S _ {i - 1} \) zur \( x_i \)-Achse entlang der \( z _ { i - 1 } \)-Achse. & Variablen, wenn Schubgelenk \\
					Länge        & \( a _ i \)      & Entfernung zwischen der \( z _ { i - 1 } \)- und \( z _ i \)-Achse entlang der \( x _ i \)-Achse.         & Konstant                    \\
					Verdrehung   & \( \alpha _ i \) & Winkel zwischen \( z _ { i - 1 } \)- und \( z _ i \)-Achse um die \( x _ i \)-Achse.                      & Konstant
				\end{tabular}
				\caption{DH-Parameter Beschreibung}
			\end{table}
		% end

		\subsection{Homogene Transformation in DH-Konvention} % 2.33
			Die (homogene) Transformation \( ^{i-1}T_i \) zwischen zwei benachbarten Koordinatensystemen \( S _ { i - 1 } \) und \( S _ i \) mit DH-Konvention ergibt sich durch:
			\begin{align*}
				^{i-1}T_i & = \text{Rot}(z; \Theta _ i) \cdot \text{Trans}(0, 0, d _ i) \cdot \text{Trans}(a _ i, 0, 0) \cdot \text{Rot}(x; \alpha _ i) \\
				          & =
				\begin{bmatrix}
					\cos(\Theta_i) & -\sin(\Theta_i) & 0 & 0 \\
					\sin(\Theta_i) & \cos(\Theta_i)  & 0 & 0 \\
					0              & 0               & 1 & 0 \\
					0              & 0               & 0 & 1
				\end{bmatrix}
				\cdot
				\begin{bmatrix}
					1 & 0 & 0 & 0   \\
					0 & 1 & 0 & 0   \\
					0 & 0 & 1 & d_i \\
					0 & 0 & 0 & 1
				\end{bmatrix}
				\cdot
				\begin{bmatrix}
					1 & 0 & 0 & a_i \\
					0 & 1 & 0 & 0   \\
					0 & 0 & 1 & 0   \\
					0 & 0 & 0 & 1
				\end{bmatrix}
				\cdot
				\begin{bmatrix}
					1 & 0              & 0               & 0 \\
					0 & \cos(\alpha_i) & -\sin(\alpha_i) & 0 \\
					0 & \sin(\alpha_i) & \cos(\alpha_i)  & 0 \\
					0 & 0              & 0               & 1 \\
				\end{bmatrix}                                                                                                \\
				          & =
				\begin{bmatrix}
					\cos(\Theta_i) & -\sin(\Theta_i)\cos(\alpha_i) & \sin(\Theta_i)\sin(\alpha_i)  & a_i \cos(\Theta_i) \\
					\sin(\Theta_i) & \cos(\Theta_i)\cos(\alpha_i)  & -\cos(\Theta_i)\sin(\alpha_i) & a_i \sin(\Theta_i) \\
					0              & \sin(\alpha_i)                & \cos(\alpha_i)                & d_i                \\
					0              & 0                             & 0                             & 1
				\end{bmatrix}
			\end{align*}
		% end
	% end

	\section{Inverses Kinematikmodell} % 2.36, 2.42, 2.43, 2.44, 2.81
		\begin{itemize}
			\item Sei \( n \) die Anzahl der Gelenke der kinematischen Kette. Dann ist \( S _ 0 \) das Weltkoordinatensystem und \( S _ n \) das Koordinatensystem des Endeffektors.
			\item Das \textit{inverse Kinematikmodell} eines Roboters ordnet einer gegebenen Endeffektorrotation \( ^{n-1}R_n \) und Endeffektorposition \( ^{n-1}r_n \) gewisse Gelenkstellungen \( q _ 1, \cdots, q _ n \), welche im Vorwärtskinematikmodell zu der gewollten Rotation/Position führen.
			\item Folgende Fragen tun sich für das inverse Modell auf:
				\begin{enumerate}
					\item Existiert eine Lösung?
					\item Ist die Lösung eindeutig oder mehrdeutig?
					\item Wie kann die Lösung berechnet werden?
				\end{enumerate}
			\item Mit dem impliziten Gleichungsmodell
				\begin{equation*}
					0 =
					\begin{bmatrix}
						^0\tilde{r}_{n,x}   \\
						^0\tilde{r}_{n,y}   \\
						^0\tilde{r}_{n,z}   \\
						^0\tilde{R}_{n,1,1} \\
						\vdots              \\
						^0\tilde{R}_{n,3,3}
					\end{bmatrix}
					-
					\begin{bmatrix}
						^0r_{n,x}(q_1, \cdots, q_n)   \\
						^0r_{n,y}(q_1, \cdots, q_n)   \\
						^0r_{n,z}(q_1, \cdots, q_n)   \\
						^0R_{n,1,1}(q_1, \cdots, q_n) \\
						\vdots
						^0R_{n,3,3}(q_1, \cdots, q_n)
					\end{bmatrix}
				\end{equation*}
				\textit{könnte} die Gelenkposition berechnet werden, allerdings ist die Berechnung sehr aufwändig, da das System \(12\) Unbekannte hat.
			\item Die \( 3 \times 3 \)-Rotationsmatrix hat \(9\) Matrixelemente, kann aufgrund der orthonormalität aber durch maximal \(3\) unabhängige Winkel \(\alpha\), \(\beta\), \(\gamma\) beschrieben werden.
			\item Es gibt hier viele Möglichkeiten, die Winkel festzulegen, z.B. durch Euler-Winkel, Kardan-Winkel, \dots.
			\item Hier werden sogenannte Z-Y-Z-Winkel verwendet, bei denen die Winkel \(\alpha\), \(\beta\), \(\gamma\) Rotationen um Z-Y-Z-Achsen beschreiben.
			\item Damit kann das Gleichungsmodell wie folgt dedupliziert und vereinfacht werden:
				\begin{equation*}
					0 =
					\begin{bmatrix}
						^0\tilde{r}_{n,x} \\
						^0\tilde{r}_{n,y} \\
						^0\tilde{r}_{n,z} \\
						\tilde{\alpha}    \\
						\tilde{\beta}     \\
						\tilde{\gamma}
					\end{bmatrix}
					-
					\begin{bmatrix}
						^0r_{n,x}(q_1, \cdots, q_n)      \\
						^0r_{n,y}(q_1, \cdots, q_n)      \\
						^0r_{n,z}(q_1, \cdots, q_n)      \\
						\tilde{\alpha}(q_1, \cdots, q_n) \\
						\tilde{\beta}(q_1, \cdots, q_n)  \\
						\tilde{\gamma}(q_1, \cdots, q_n)
					\end{bmatrix}
				\end{equation*}
			\item Die Lösung kann nun analytisch oder numerisch (z.B. mit dem Newton-Verfahren) berechnet/approximiert werden.
		\end{itemize}

		\subsection{Problematiken}
			\begin{itemize}
				\item Das Problem ist durch das vorgestellte Verfahren noch nicht gelöst, da nicht alle Gelenkstellungen möglich sind (ein Arm kann nicht durch den Roboter greifen) und es viele Lösungen geben kann.
					\begin{itemize}
						\item Eine Lösung existiert somit nur, wenn die Position und Orientierung im \textit{Arbeitsraum} des Roboters sind.
						\item Als Faustregel für die Lösbarkeit gilt bei einem INVKIN-Modell mit 6 nichtlinearen Gleichungen für \(n\) unbekannte \(q_i\):
							\begin{itemize}
								\item Bei \( n < 6 \) gibt es im Allgemeinen keine Lösung, da es mehr weniger Variablen als Gleichungen gibt.
								\item Bei \( n = 6 \) gibt es im Allgemeinen eine Lösung, da es genau so viele Variablen wie Gleichungen gibt.
								\item Bei \( n > 6 \) gibt es im Allgemeinen viele Lösungen, da es mehr Variablen als Gleichungen gibt.
							\end{itemize}
					\end{itemize}
			\end{itemize}
		% end

		\subsection{Berechnung} % 2.80
			Die Gleichung kann auf unterschiedliche Arten berechnet werden:
			\begin{itemize}
				\item Explizite \textit{analytische} Lösung mit einer Lösungsformel.
				\item Iterative \textit{numerische} Verfahren wie das Newton-Verfahren.
				\item Kombinationen aus den obigen Verfahren.
				\item Spezialverfahren unter Ausnutzung der Struktur des Vorwärtskinematikmodells.
			\end{itemize}
			Für alle Arten der Berechnung gilt die Anforderung, dass die Lösung in Echtzeit berechnet werden muss und dass alle Lösungen berechnet werden können müssen.
		% end
	% end
% end

\chapter{Zeitkontinuierliche Modelle} % 3
	\section{Örtlich konzentrierter Systemzustand} % 3.3
		\begin{itemize}
			\item Systeme mit \textit{örtlich konzentrierten} Zuständen werden durch \textit{gewöhnliche} Differentialgleichungen beschrieben.
			\item Beispiele:
				\begin{itemize}
					\item Zeitlicher Verlauf der Schwingung einer Masse an einer Feder
					\item Zeitlicher Verlauf von Strom und Spannung in einer elektrischen Schaltung
					\item u.v.m.
				\end{itemize}
		\end{itemize}

		\subsection{Beispiel: Linearer Schwinger} % 3.4, 3.5, 3.6
			\begin{figure}
				\centering
				\begin{tikzpicture}
					\node [draw, rectangle, minimum width = 2cm, minimum height = 3.5cm] (mass) at (0, 0) { \(m\) };
					\coordinate (massTop) at (1, 1);
					\coordinate (massBottom) at (1, -1);
					\node [draw, circle, minimum width = 0.5cm, minimum height = 0.5cm] (servo) at (3, 1) { \(M\) };
					\node [draw, rectangle, anchor = west, minimum width = 0.5cm, minimum height = 0.5cm, label = below:\(d\)] (friction) at (3, -1) { };
					\coordinate [left = 0.5cm of friction.north west] (frictionTopHelp);
					\coordinate [left = 0.5cm of friction.south west] (frictionBottomHelp);
					\node [draw, rectangle, minimum width = 1cm, minimum height = 3.5cm] (earth) at (5.5, 0) { };
					\coordinate (earthTop) at (5, 1);
					\coordinate (earthBottom) at (5, -1);
					\coordinate (springLeft) at (2, 0);
					\coordinate (springRight) at (4, 0);

					\draw [decoration = {zigzag, segment length = 3mm, amplitude = 1mm}, decorate] (springLeft) -- node[below]{\(k\)} (springRight);

					\coordinate [below left = 0.1 of mass.south west] (bottomLeft);
					\coordinate [below right = 0.1 of earth.south east] (bottomRight);

					\draw (friction.north west) -- (frictionTopHelp);
					\draw (friction.south west) -- (frictionBottomHelp);

					\draw (bottomLeft) -- (bottomRight);

					\draw (massTop) -- (servo);
					\draw (mass.east) -- (springLeft);
					\draw (massBottom) -- (friction);

					\draw (servo) -- (earthTop);
					\draw (springRight) -- (earth.west);
					\draw (friction) -- (earthBottom);


					\coordinate [below = 0.3 of earth.north east] (groundHelpTopLeft);
					\coordinate [right = 0.3 of earth.north east] (groundHelpTopRight);
					\foreach \i in { 0, 0.3, ..., 3.3 } {
						\coordinate [below = \i of groundHelpTopLeft] (a);
						\coordinate [below = \i of groundHelpTopRight] (b);
						\draw (a) -- (b);
					}

					\draw [|->] (0, -2.2) -- node[below]{\(x\)} (2, -2.2);
				\end{tikzpicture}
				\caption{Linearer Schwinger: Blockschaltbild}
				\label{fig:linearerSchwinger}
			\end{figure}

			Abbildung~\ref{fig:linearerSchwinger} zeigt einen linearen Schwinger mit folgenden Attributen:
			\begin{description}
				\item[\(m\)] Masse
				\item[\(M\)] Motor (Antriebs-/Bremskraft \( F _ M (t) \) in \(x\)-Richtung)
				\item[\(k\)] Federkonstante
				\item[\(d\)] Reibungskonstante
			\end{description}

			Aus diesem Blockschaltbild lässt sich direkt die entsprechende Differentialgleichung ablesen:
			\begin{align*}
				     & m\ddot{x} = F _ M (t) - d\dot{x} - kx \tag{Grundform}                                   \\
				\iff & \ddot{x} = \frac{F _ M (t)}{m} - \frac{d}{m} \dot{x} - \frac{k}{m} x \tag{Normalisiert} \\
				\iff & F _ M (t) = m\ddot{x} + d\dot{x} + kx \tag{Motorkraft}
			\end{align*}

			Mit Hilfe der letzten, zur Motorkraft aufgelösten, Formel, kann die Bewegungsdifferentialgleichung auch auf mehrere Achsen (unter Vernachlässigung der Kopplungseffekte) erweitert werden:
			\begin{equation*}
				F (t) =
				\underbrace{
					\begin{bmatrix}
						m _ 1  & 0      & \ddots \\
						0      & \ddots & 0      \\
						\ddots & 0      & m _ n
					\end{bmatrix}
				} _ { M }
				\ddot{q} +
				\underbrace{
					\begin{bmatrix}
						d _ 1  & 0      & \ddots \\
						0      & \ddots & 0      \\
						\ddots & 0      & d _ n
					\end{bmatrix}
				} _ { D }
				\dot{q} +
				\underbrace{
					\begin{bmatrix}
						k _ 1  & 0      & \ddots \\
						0      & \ddots & 0      \\
						\ddots & 0      & k _ n
					\end{bmatrix}
				} _ { K }
				q
			\end{equation*}
			Dabei entsprechen \( \ddot{q} \overset{\text{def}}{=} \ddot{x} \), \( \dot{q} \overset{\text{def}}{=} \dot{x} \) und \( q \overset{\text{def}}{=} x \) und \( M \overset{\text{def}}{=} m \), \( D \overset{\text{def}}{=} d \) und \( K \overset{\text{def}}{=} k \) und \( F(t) \overset{\text{def}}{=} F _ M (t) \) in mehreren Achsen.
		% end
	% end

	\section{Örtlich verteilter Systemzustand} % 3.7
		Örtlich verteilte Systemzustände werden durch \textit{partielle} Differentialgleichungen beschrieben, die mehrere unabhängige Variablen haben.

		Beispiele:
		\begin{itemize}
			\item Strömungsdynamik
			\item Elektromagnetische Felder
			\item u.v.m.
		\end{itemize}

		\textit{Diese Art von Systemen wird nicht weiter behandelt.}
	% end

	\section{Beschreibung zeitkontinuierlicher Systeme} % 3.8
		\subsection{Allgemeine Zustandsgleichung, Allgemeines Zustandsraummodell} % 3.11, 3.12, 3.102
			Allgemein werden die Systeme mit gewöhnlichen Differentialgleichungssystemen 1. Ordnung beschrieben:
			\begin{align*}
				\dot{x}(t) & = \frac{d x(t)}{dt} =
				\begin{bmatrix}
					\dot{x} _ 1 (t) \\
					\vdots          \\
					\dot{x} _ n (t)
				\end{bmatrix}
				=
				\begin{bmatrix}
					f _ 1 (x(t), u(t), t) \\
					\vdots                \\
					f _ n (x(t), u(t), t)
				\end{bmatrix}
				= f(x(t), u(t), t)                 \\
				y          & = g(x, u, t) =
				\begin{bmatrix}
					g _ 1 (x, u, t) \\
					\vdots
					g _ n (x, u, t)
				\end{bmatrix}
			\end{align*}
			Mit den Zustandsgrößen \(x\), den Steuervariablen (Stellgrößen) \(u\) und den Ausgangsgrößen \(y\).

			\begin{itemize}
				\item Die große Aufgabe bei der Erstellung eines Modells ist es, die Funktion \(f\) zu finden und die Steuervariablen \(u\) mit geeigneten Werten zu belegen.
				\item Dabei wird die Modellgleichung \(f\) meistens aus physikalischen, mechanischen, \dots Gesetzen hergeleitet.
				\item Steuervariablen müssen natürlich nicht immer explizit auftreten.
			\end{itemize}

			\subsubsection{Zeitcharaktersitik} % 3.105, 3.106
				Siehe \ref{sec:mathezeitCharakteristik} für die Definition der hier verwendeten Variablen.

				Aus den minimalen/maximalen Zeitcharakteristika \( T _ {\min} \)/\( T _ {\max} \) ist die Simulationsdauer sinnvoll abschätzbar (als Faustregel):
				\begin{itemize}
					\item Stabiles System: \( t _ f = 5 T _ {\max} \) \\ (Bis zum erreichen der Gleichgewichtslage)
					\item Instabiles System: \(x_t\) sodass \( x(t _ f) \geq M \) \\ (Danach nicht mehr so interessant)
				\end{itemize}
				Daraus lässt sich auch eine geeignete Diskretisierungsschrittweite annähern:
				\begin{equation*}
					h = \Delta t \leq \alpha T _ {\max}, \quad \alpha \approx \frac{1}{20} \text{ bis } \frac{1}{5}
				\end{equation*}
			% end
		% end

		\subsection{Lineare/Nichtlineare Systemdynamik} % 3.15
			Für die Regelungstechnik sehr wichtig sind \textit{lineare Systemdynamiken}, die den allgemeinen Aufbau
			\begin{align*}
				\dot{x} & = f(x, u) = Ax + Bu \\
				y       & = g(x, u) = Cx + Eu
			\end{align*}
			haben mit \( x \in \mathbb{R} ^ n \), \( y \in \mathbb{R} ^ m \), \( u \in \mathbb{R} ^ l \) und konstanten oder nur Zeitabhängigen Matrizen \( A \in \mathbb{R} ^ { n \times n } \), \( B \in \mathbb{R} ^ { n \times l } \), \( C \in \mathbb{R} ^ { m \times n } \) und \( E \in \mathbb{R} ^ { m \times l } \).
		% end
	% end

	\section{Linearisierung um die Ruhelage} % 3.42, 3.43
		\begin{itemize}
			\item Das Verfahren der Linearisierung selbst ist in \ref{sec:linearisierung} beschrieben.
			\item Eine Linearisierung um die Ruhelage ist von Nöten, damit die Regelung des Systems (um in der Ruhelage zu verweilen) vereinfacht wird.
		\end{itemize}
	% end

	\section{Stabilität} % 3.49
		\begin{itemize}
			\item Ein \textit{stabiles System} ist asymptotisch stabil, d.h. die Veränderungen werden immer kleiner, bis sie schließlich verschwinden.
			\item Eine mathematische Definition und die Bestimmung, ob ein System stabil ist, ist in \ref{sec:stabilitydgl} gegeben.
		\end{itemize}
	% end

	\section{Regelung} % 3.68, 3.69, 3.70, 3.71
		\begin{itemize}
			\item Die Regelungstechnik beschäftigt sich damit, die Stellgrößen \(u\) auf Basis der Systemausgänge \(y\) anzupassen, sodass ein stabiler Zustand erreicht wird. \\ Vergleich: Regelung der Temperatur des Wassers in einer Badewanne.
			\item Gewünscht ist, dass das dynamische Modell eine \enquote{virtuelle} Ruhelage \(x_\text{soll}\) (Sollwert) oder \(x_\text{soll} (t)\) (Solltrajektorie) annimmt.
			\item Hierzu wird eine geeignete Steuerung \(u(t)\) oder Regelung \(u(x)\) gesucht, sodass der Sollwert/die Solltrajektorie angenommen stabil wird.
		\end{itemize}

		\subsection{Steuerung und Regelung} % 3.72, 3.73
			\subsubsection{Abgrenzung}
				Die \textit{Steuerung} steuert ein Modell ohne Kenntnis über den Systemausgang (open-loop/feedforward control).
				\begin{figure}[H]
					\centering
					\begin{tikzpicture}[->, align = center]
						\coordinate [label = left:{ Sollwert \\ \(x _ \text{soll} (t) \) }] (init);
						\node [draw, rectangle, right = of init, label = above:{ \( u(t) \) }] (control) {Steuerung};
						\node [draw, rectangle, right = of control] (system) {Regelstrecke};
						\coordinate [right = of system, label = right:{ Istwert \\ \( x _ \text{ist} (t) \) }] (end);

						\draw (init) -- (control);
						\draw (control) -- (system);
						\draw (system) -- (end);
					\end{tikzpicture}
					\caption{Steuerung}
				\end{figure}

				\noindent Die \textit{Regelung} steuert ein Modell mit Kenntnis über den Systemausgang (closed-loop/feedback control).
				\begin{figure}[H]
					\centering
					\begin{tikzpicture}[align = center]
						\coordinate [label = left:{ Sollwert \\ \(x _ \text{soll} (t) \) }] (init);
						\node [draw, circle, right = of init, label = above left:+, label = below right:-] (calc) {};
						\node [draw, rectangle, right = of calc, label = above:{ \( u(x_\text{soll} - x_\text{ist}) \) }] (control) {Steuerung};
						\node [draw, rectangle, right = of control] (system) {Regelstrecke};
						\coordinate [right = of system] (twoway);
						\coordinate [right = of twoway, label = right:{ Istwert \\ \( x _ \text{ist} (t) \) }] (end);

						\draw [->] (init) -- (calc);
						\draw [->] (calc) -- (control);
						\draw [->] (control) -- (system);
						\draw [->] (system) -- (end);
						\coordinate [below = of calc] (help);
						\draw (twoway) |- (help);
						\draw [->] (help) -- node[right]{\( x _ \text{ist} (t) \)} (calc);
					\end{tikzpicture}
					\caption{Regelung}
				\end{figure}
			% end
		% end

		\subsection{Regelung} % 3.74, 3.77, 3.75, 3.76
			\begin{itemize}
				\item Der Sollwert/die Sollwerttrajektorie soll durch Regelung der Steuerungsparameter \(u\) in Abhängigkeit vom aktuellen Zustand \(x_\text{ist}\) stabil angenommen werde.
				\item Anders Ausgedrückt: Die Stellwerte \(u(x)\) müssen so gefunden werden, dass der Realteil aller Eigenwerte der linearisierten Bewegungsdifferentialgleichung um \(x_\text{soll}\) kleiner \(0\) ist und die Regelung somit stabil ist (nach Ljapunov).
				\item nach \textit{Regelungssystem} besteht somit aus:
					\begin{itemize}
						\item Einem \textit{Messglied} zur Messung der regelbaren Größen (der Systemausgänge).
						\item Einem \textit{Stellglied} zum Einbringen der Steuerung.
						\item Einem \textit{Regler} mit \textit{Regelgesetz} zur Bestimmung der Steuerung aus den Daten des Messglieds.
					\end{itemize}
				\item Es nun die Frage, \textit{wann} eine solche Regelung existiert und \textit{wie} eine stabile oder sogar optimale Steuerung/Regelung bestimmt werden kann? Hierzu gibt es keine allgemeingültigen Antworten, im folgenden wird nur die Regelung eines linearen Feder-Masse-Systems betrachtet.
			\end{itemize}
		% end

		\subsection{Lineares Feder-Masse-System} % 3.79
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}
					\node [draw, rectangle, minimum width = 3.5cm, minimum height = 2cm] (mass) { \( m \) };
					\coordinate [left = 2 of mass] (force);
					\coordinate [right = 2 of mass] (spring);

					\coordinate [left = 3 of mass.south west] (S);
					\coordinate [above = 1 of S] (Sy);
					\coordinate [right = 1 of S] (Sx);
					\draw [->] (S) -- node[left]{y} (Sy);
					\draw [->] (S) -- node[below]{x} (Sx);

					\draw [->] (force) -- node[above]{\(f\)} (mass);
					\draw [decoration = {zigzag, segment length = 3mm, amplitude = 1mm}, decorate] (mass) -- node[above]{\(k\)} (spring);

					\coordinate [below = 0.5 of mass.south west] (groundHelp);
					\coordinate [left = 0.5 of groundHelp] (groundLeft);
					\coordinate [above = 1.5 of spring] (groundTop);
					\draw (groundLeft) -| (groundTop);

					\coordinate [below = 0.3 of groundTop] (groundHelpTopLeft);
					\coordinate [right = 0.3 of groundTop] (groundHelpTopRight);
					\foreach \i in { 0, 0.3, ..., 3.3 } {
						\coordinate [below = \i of groundHelpTopLeft] (a);
						\coordinate [below = \i of groundHelpTopRight] (b);
						\draw (a) -- (b);
					}

					\coordinate [right = 0.3 of groundLeft] (groundHelpLeftTop);
					\coordinate [below = 0.3 of groundLeft] (groundHelpLeftBottom);
					\foreach \i in { 0, 0.3, ..., 6 } {
						\coordinate [right = \i of groundHelpLeftTop] (a);
						\coordinate [right = \i of groundHelpLeftBottom] (b);
						\draw (a) -- (b);
					}

					\coordinate [right = 0.5 of mass.south west] (frictionHelpTopRight);
					\coordinate [below = 0.5 of mass.south west] (frictionHelpBottomLeft);
					\coordinate [right = 0.5 of frictionHelpBottomLeft] (frictionHelpBottomRight);
					\foreach \i in { 0, ..., 3 } {
						\coordinate [right = \i of mass.south west] (a);
						\coordinate [right = \i of frictionHelpTopRight] (b);
						\coordinate [right = \i of frictionHelpBottomLeft] (c);
						\coordinate [right = \i of frictionHelpBottomRight] (d);
						\draw (a) -- (d);
						\draw (b) -- (c);
					}
				\end{tikzpicture}
				\caption{Lineares Feder-Masse-System}
			\end{figure}

			\begin{description}
				\item[\(m\)] Masse, \( m > 0 \)
				\item[\(k\)] Federsteifigkeit, \( k > 0 \)
				\item[\(b\)] Reibungskoeffizient, \( b > 0 \)
				\item[\(f\)] Antriebs- oder Bremskraft
				\item[Bewegungsgleichung] \( m\ddot{x}(t) + b\dot{x}(t) + kx(t) = f(t) \)
			\end{description}

			\subsubsection{Untersuchung des Bewegungsverhaltens} % 3.80
				\begin{itemize}
					\item Berechnung des Bewegungsverhaltens von \(x(t)\) mit Hilfe von:
						\begin{itemize}
							\item gegebener Anfangsposition \(x(0)\),
							\item gegebener Anfangsgeschwindigkeit \(\dot{x}(t)\) und
							\item gegebenem Antriebskraftverlauf \(f(t)\).
						\end{itemize}
					\item Weitere Annahmen:
						\begin{itemize}
							\item Antriebs-/Bremskraft \(f(t) = 0\)
							\item Ruhelage \( x _ \text{stat} (t) = 0 \) \\ Viele mechanische Systeme sind in einer Ruhelage, wenn keine Antriebs-/Bremskraft wirkt (\( \frac{d}{dt}x(t)  \rightarrow 0 \) für \( t \rightarrow \infty \)).
						\end{itemize}
				\end{itemize}
			% end

			\subsubsection{Erwartetes Bewegungsverhalten} % 3.81
				\begin{itemize}
					\item Variante 1
						\begin{itemize}
							\item Die Federkraft ist schwach (\(k\) ist \enquote{klein}).
							\item Die Reibungskraft ist groß (\(b\) ist \enquote{groß}).
						\end{itemize}
						\(\implies\) Die Masse kehrt von einer Auslenkung \( x(0) \neq x _ \text{stat} \) nur langsam in die Ruhelage zurück.
					\item Variante 2
						\begin{itemize}
							\item Die Federkraft ist groß (\(k\) ist \enquote{groß}).
							\item Die Reibungskraft ist schwach (\(b\) ist \enquote{klein}).
						\end{itemize}
						\( \implies \) die Masse oszilliert nach einer Auslenkung mehrmals schnell hin und her, bevor sie in die Ruhelage zurückkehrt.
				\end{itemize}
			% end

			\subsubsection{Berechnung des Bewegungsverhaltens} % 3.82, 3.83, 3.84, 3.85
				\label{sec:bewegung}

				Mit der Lösung der Differentialgleichung \[ \ddot{x} + \frac{b}{m} \dot{x} + \frac{k}{m} x = 0 \] durch den allgemeinen Lösungsansatz \( x = ce^{\lambda t} \) ergeben sich die Nullstellen (Pole) \[ \lambda _ { 1, 2 } = - \frac{b}{2m} \pm \frac{\sqrt{b^2 - 4mk}}{2m} \]

				Die Lage dieser Pole bestimme das Bewegungsverhalten der Masse:
				\begin{itemize}
					\item \( \lambda _ { 1, 2 } \) sind einfache, reelle Nullstellen \( \lambda _ { 1, 2 } \), wenn
						\begin{equation*}
							b ^ 2 - 4mk > 0 \iff b ^ 2 > 4mk \implies \lambda _ { 1, 2 } < 0
						\end{equation*}
						\begin{itemize}
							\item Hat die Lösung die Form \( x = c_1 e^{\lambda_1 t} + c_2 e^{\lambda_2 t} \) mit durch Anfangswerte bestimme Konstanten \( c _ 1, c _ 2 \).
							\item Wegen \( \lambda _ { 1, 2 } \) gilt \( x(t) \rightarrow 0 \) für \( t \rightarrow \infty \).
							\item Dieses Verhalten wird \textit{überkritisch gedämpft} genannt.
						\end{itemize}
					\item \( \lambda _ { 1, 2 } \) ist eine doppelte, reelle Nullstelle \( \lambda_{1,2} = -\frac{b}{2m} < 0 \), wenn
						\begin{equation*}
							b^2 - 4mk = 0 \iff b^2 = 4mk \implies \lambda _ { 1, 2 } = -\frac{b}{2m} < 0
						\end{equation*}
						\begin{itemize}
							\item Hat die Lösung die Form \( x = c_1 e^{\lambda_1 t} + c_2 t e^{\lambda_2 t} \) mit durch Anfangswerte bestimme Konstanten \( c _ 1, c _ 2 \).
							\item Wegen \( \lambda _ { 1, 2 } \) gilt \( x(t) \rightarrow 0 \) für \( t \rightarrow \infty \).
							\item Dieses Verhalten wird \textit{kritisch gedämpft} genannt und ist das schnellstmögliche Verhalten, um ohne Oszillation in die Ruhelage überzugehen.
						\end{itemize}
					\item \( \lambda _ 1 = \lambda _ 2 \) ist eine einfache, komplexe Nullstelle \( \Re(\lambda _ {1,2}) < 0 \), wenn
						\begin{equation*}
							b ^ 2 - 4mk < 0 \iff b ^ 2 < 4mk \implies \lambda _ { 1, 2 } = -\frac{b}{2m} \pm i \frac{\sqrt{\abs{b^2 - 4mk}}}{2m} = \Re(\lambda) \pm \Im(\lambda)
						\end{equation*}
						\begin{itemize}
							\item Hat die Lösung die Form \( x = c_1 e ^ { \Re(\lambda) t } \cos(\Im(\lambda) t) + c_2 e ^ { \Re(\lambda) t } \sin(\Im(\lambda) t) \) mit durch Anfangswerte bestimmte Konstanten \( c _ 1, c _ 2 \).
							\item Wegen \( \Re(\lambda) < 0 \) gilt \( x(t) \rightarrow 0 \) für \( t \rightarrow \infty \).
							\item Dieses Verhalten wird \textit{unterkritisch gedämpft} genannt und die Masse oszilliert mehrmals um die Ruhelage \( x _ \text{stat} \), bevor sie vollständig in die Ruhelage übergeht.
						\end{itemize}
				\end{itemize}
			% end

			\subsubsection{Gewünschtes Bewegungsverhalten} % 3.86
				\begin{itemize}
					\item Gewünscht ist eine \textit{kritische Dämpfung}, da diese am schnellsten in die Ruhelage zurück kehrt und keine Oszillation auftritt.
				\end{itemize}
			% end

			\subsubsection{PD-Regelung des Feder-Masse-Systems} % 3.87, 3.88, 3.89, 3.90, 3.91
				\textit{Der Name PD-Regelung stammt von dem verwendeten Proportions- und Differentialanteil, welche in das Regelgesetz einfließen.}

				\begin{itemize}
					\item Ist das natürliche Bewegungsverhalten des Systems nicht wie gewünscht (zu weniger Federkraft, zu viel Federkraft, etc.), so muss das System geregelt werden.
					\item Dies wird mit Hilfe von geeigneten Sensoren zur Messung der Position und der Geschwindigkeit, der Verwendung einer geeigneten Antriebskraft \(f\) und einem geeigneten \textit{Regelgesetz} zur Bestimmung von \(f\) geregelt.
					\item Das Bewegungsverhalten soll so modifiziert werden, dass eine kritische Dämpfung eintritt.
					\item Ein Ansatz ist folgende Antriebsformel mit den Regelparametern \( k _ v \) und \( k _ p \):
						\begin{equation*}
							f(t) = \underbrace{-k_px(t)}_{\text{P-Teil}} \underbrace{-k_v\dot{x}(t)}_{\text{D-Teil}}
						\end{equation*}
					\item Eingesetzt in Bewegungsdifferentialgleichung \( f = m\ddot{x} + b\dot{x} + kx \) ergibt sich:
						\begin{align*}
							-k_px -k_v\dot{x} & = m\ddot{x} + b\dot{x} + kx                                                                                       \\
							\iff 0            & = m\ddot{x} + \underbrace{(b + k_v)}_{ \coloneqq \hat{b} }\dot{x} + \underbrace{(k + k_p)}_{ \coloneqq \hat{k} }x
						\end{align*}
					\item Womit sich die Nullstellen \( \lambda _ { 1, 2 } = -\frac{\hat{b}}{2m} \pm \frac{\sqrt{\hat{b}^2 - 2m\hat{k}}}{2m} \) ergeben.
					\item Dann ist es nach Abschnitt \ref{sec:bewegung} notwendig, dass \( \hat{b}^2 = 4m\hat{k} \) gilt. Damit Regelfehler bei Instabiltät nicht verstärkt gedämpft werden (\( k_v \) und \( k_p \) können positiv und negativ gewählt werden), muss außerdem \( \hat{b} = 2\sqrt{m\hat{k}} > 0 \) gelten.
						\begin{equation*}
							\hat{b}^2 = 4m\hat{k} \quad\text{und}\quad \hat{b} = 2\sqrt{m\hat{k}} > 0
						\end{equation*}
					\item Damit kann das Verhalten auf einen konstanten Sollwert \( x _ d \) geregelt werden, ähnlich ist dies für eine Sollwerttrajektorie \( x _ d (t) \) möglich.
				\end{itemize}
			% end

			\subsubsection{Mehr Dimensionen und Nichtlineare Systeme}
				\begin{itemize}
					\item Es gibt ähnliche Ansätze, um mehr Dimensionen und auch nichtlineare Systeme zu regeln.
					\item Dabei ist immer das Ziel, die Polstellen so zu legen, dass ein stabiles System auftritt.
				\end{itemize}
			% end
		% end

		\subsection{PID-Bahnregelung eines Servomotors} % 3.93, 3.94
			\begin{itemize}
				\item Die PID-Regelung ist eine Erweiterung eines PD-Reglers, welche zusätzlich zum Proportions- und Differentialanteil noch einen Integralanteil enthält.
				\item Dabei ist der allgemeine Aufbau des PID-Regelgesetzes:
					\begin{equation*}
						u(t) = u _ d (t) + k _ P \underbrace{e(t)}_{\text{P-Fehler}} + k _ I \underbrace{\int_{0}^{t} \! e(s) \, ds}_{\text{I-Fehler}} + k _ V \underbrace{\dot{e} (t)}_{\text{D-Fehler}}
					\end{equation*}
					\begin{itemize}
						\item Soll-Position \( q _ d (t) \) (Gelenkwinkelverlauf)
						\item Ist-Position \( q (t) \)
						\item Soll-Moment \( u _ d (t) \)
						\item Stellmoment \( u(t) \) (Motorantriebsmoment)
						\item Regelabweichung \( e(t) = q _ d (t) - q(t) \)
					\end{itemize}
				\item Intuition führ die P-/I-/D-Anteile:
					\begin{description}
						\item[P-Anteil] Überwachung des Ist-Zustandes; Sofortige Reaktion; Überschwingen
						\item[I-Anteil] Überwachung der Vergangenheit; Reagiert auf Fehler der Regelung (z.B. Überschwingen)
						\item[D-Anteil] Überwachung der \enquote{Zukunft}; Reagiert auf Störungen
					\end{description}
			\end{itemize}
		% end
	% end
% end

\chapter{Numerische Simulation} % 4, 4.27
	\label{c:numerischesimulation}

	\begin{itemize}
		\item Um ein gegebenes numerisches Simulationsproblem zu lösen, ist es nötig, eine Implementierung zu finden, welche Rundungsfehler möglichst wenig verstärkt.
		\item Vorgehen
			\begin{enumerate}
				\item \textit{Analyse} der Berechnungsaufgabe, ob diese gut oder schlecht \textit{konditioniert} ist.
				\item \textit{Auswahl} eines mathematisch äquivalenten und \textit{numerisch stabilen} Algorithmus, der Rundungsfehler nicht zusätzlich verstärkt.
				\item \textit{Vorsicht} bei beispielsweise:
					\begin{itemize}
						\item Subtraktion zwei annähernd gleicher Zahlen (Auslöschung).
						\item Berechnungen mit relativ großen Zwischenwerten, wenn das Ergebnis klein ist (Auslöschung der Nachkommastellen).
					\end{itemize}
			\end{enumerate}
		\item Treten bei der numerisch stabilen Implementierung eines schlecht konditionierten Problem noch immer Fehlerverstärkung auf, so kann:
			\begin{itemize}
				\item Die Berechnung mit höherer Genauigkeit durchgeführt werden.
				\item Das Ausgangsproblem so modifiziert werden, dass eine bessere Kondition erreicht wird.
			\end{itemize}
	\end{itemize}

	\section{Zahlendarstellung} % 4.32, …, 4.42
		Die Darstellung von Ganz- und Fließkommazahlen sollte hinreichend bekannt sein und wird hier nicht erneut erläutert.

		Siehe \HREF{https://de.wikipedia.org/wiki/IEEE\_754}.
	% end

	\section{Rundungsfehler} % 4.2, 4.5, 4.6
		\begin{itemize}
			\item Da nur eine endliche Menge an Gleitpunktzahlen \( g \) verfügbar ist, muss jede reelle Variable \( x \) auf die nächstliegende Maschinenzahl abgebildet werden.
			\item Diese Abbildung wird \textit{Rundung} genannt und kann durch \( \forall g : \abs{x - \rd(x)} \leq \abs{x - g} \) beschrieben werden.
			\item Nach IEEE 754 gibt es folgende Rundungsarten:
				\begin{description}
					\item[R1] Immer aufrunden. \\ Wichtig für Intervallarithmetik.
					\item[R2] Immer abrunden. \\ Wichtig für Intervallarithmetik.
					\item[R3] Runden durch abschneiden.
					\item[R4] Runden zur nächsten geraden Gleitpunktzahl. \\ Stellt das Standard-Verfahren dar.
				\end{description}
			\item Damit ergibt sich der relative Rundungsfehler \( \varepsilon(x) \):
				\begin{equation*}
					\varepsilon(x) \coloneqq \frac{x - \rd(x)}{x} \iff \rd(x) = x(1 - \varepsilon(x)) \text{wobei} \abs{\varepsilon(x)} \leq \eps = \varepsilon _ \text{mach}
				\end{equation*}
			\item \( \eps \) (Maschinenepsilon) stellt hierbei die Maschinengenauigkeit dar. Der maximale Abstand zweier benachbarten Zahlen beträgt dann \( 2\eps \).
			\item Das Ergebnis einer arithmetischen Funktion (Addition, Subtraktion, Multiplikation, Division) ist im Allgemeinen keine Maschinenzahl, auch wenn die Operanden Maschinenzahlen sind.
			\item Um diese Ungenauigkeiten abzubilden, gilt für \( x + y \), \( x - y \), \( x \cdot y \), \( \frac{x}{y} \) in IEEE-Arithmetik:
				\begin{align*}
					\gl(x + y)                        = & (x + y)(1 + \varepsilon _ 1)                 \\
					\gl(x - y)                        = & (x - y)(1 + \varepsilon _ 2)                 \\
					\gl(x \cdot y)                    = & (x \cdot y)(1 + \varepsilon _ 3)             \\
					\gl\bigg(\frac{x}{y}\bigg)        = & \bigg(\frac{x}{y}\bigg)(1 + \varepsilon _ 4) \\
					                                    & \text{mit } \abs{\varepsilon _ i} \leq \eps
				\end{align*}
		\end{itemize}
	% end

	\section{Fortpflanzung von Rundungsfehlern} % 4.10, 4.11
		\begin{itemize}
			\item In der IEEE-Arithmetik gelten Assoziativ- und Distributivgesetz nicht.
				\begin{align*}
					\gl(\gl(x + y) + z)     & \neq \gl(x + \gl(y + z))                     \\
					\gl(a \cdot \gl(b + c)) & \neq \gl(\gl(a \cdot b) \cdot \gl(a \cdot c)
				\end{align*}
			\item Eine Möglichkeit zur Fehleranalyse ist, jeden Ausdruck \( \gl(x \diamond y) \) durch \( (x \diamond y)(1 + \varepsilon) \) zu ersetzen. \\ Daraus ergibt sich eine Darstellung, in der die von den Eingangparametern abhängigen Verstärkungsfaktoren ersichtlich werden.
		\end{itemize}
	% end

	\section{Kondition} % 4.19, 4.20, 4.21, 4.27
		\begin{itemize}
			\item Kernfrage: Wie wirken sich Rundungsfehler in den Eingangsdaten \( x \) einer Berechnung \( y = f(x) \) auf das Ergebnis aus?
			\item \textit{Absoluter Fehler} der \textit{Eingangsdaten}: \tabto{6.5cm} \makebox[0pt][l]{\( \Delta x _ j \)}\phantom{XXX} \(\coloneqq \abs{\tilde{x} _ j - x _ j} \)
			\item \textit{Relativer Fehler} der \textit{Eingangsdaten}: \tabto{6.5cm} \makebox[0pt][l]{\( \varepsilon _ {x _ j} \)}\phantom{XXX} \( \coloneqq \frac{\Delta x _ j}{x _ j} \)
			\item \textit{Absoluter Fehler} des \textit{Ergebnisses}: \tabto{6.5cm} \makebox[0pt][l]{\( \Delta y _ i \)}\phantom{XXX} \( \coloneqq \abs{\tilde{y} _ i - y _ i} = \abs{f _ i (\tilde{x}) - f _ i (x)} \)
			\item \textit{Relativer Fehler} des \textit{Ergebnisses}: \tabto{6.5cm} \makebox[0pt][l]{\( \varepsilon _ {y _ i} \)}\phantom{XXX} \( \coloneqq \frac{\Delta y _ i}{y _ i} \approx \sum_{j = 1}^{n} \bigg( \frac{x _ j}{f _ i (x)} \frac{\partial f _ i (x)}{\partial x _ j} \varepsilon _ { x _ j } \bigg) \eqqcolon \sum_{j = 1}^{n} ( \alpha _ j \varepsilon _ { x _ j } ) \)
			\item Die Verstärkungsfaktoren \( \alpha _ j \) heißen \textit{Konditionszahlen}.
				\begin{itemize}
					\item Sind diese \enquote{groß}, so ist das Problem schlecht konditioniert.
					\item Sind diese \enquote{klein}, so ist das Problem gut konditioniert.
				\end{itemize}
			\item Intuitiv lässt sich sagen, dass \enquote{schlecht konditioniert} heißt, dass kleine Änderungen der Eingabewerte große Änderungen des Ergebnisses bewirken.
			\item Die Konditionszahlen hängen nur von der Funktion ab und nicht davon, wie die Funktion ausgewertet wird!
		\end{itemize}
	% end

	\section{Numerische Stabilität} % 4.23, 4.25
		\begin{itemize}
			\item Die \textit{numerischer Stabilität} eines Algorithmus gibt Aufschluss darüber, wie sich eine Implementierung bei Störung der Eingangsvariablen verhält.
			\item Das heißt, die numerische Stabilität ist (lapidar gesprochen) die Konditionszahl einer Implementierung.
			\item Definition: Werden die relativen Eingabefehler eines gut konditionierten Problems \( y = f(x + \Delta x) \) durch ein Berechnungsverfahren nicht verstärkt, so ist das Verfahren \textit{numerisch stabil}. \\ Ein Berechnungsverfahren, welches trotz guter Konditionszahl schlechte Ergebnisse liefert, heißt \textit{numerisch instabil}.
			\item \( \text{Effizient Lösbar} \subset \text{Numerisch Stabil Lösbar} \subset \text{Gut Konditioniert} \subset \text{Alle Probleme} \)
		\end{itemize}
	% end
% end

\chapter{Numerische Simulation zeitkontinuierlicher Modelle} % 5
	\label{c:numerischesimulationtime}

	\section{Verschiedene Dynamikmodelltypen} % 5.5
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}[every node/.style = { align = center }, main/.style = { draw, rectangle }]
				\node [main, label = above:{ nichtautonom, \\ nichtlinear }, label = below:A] (a) {{%
						\( \begin{aligned}
							\dot{x} & = f(x, u, t) \\
							y       & = g(x, u, t)
						\end{aligned} \)
					}};
				\node [main, below right = 2 of a, label = right:{ nichtautonom, \\ linear }, label = left:B] (b) {{%
						\( \begin{aligned}
							\dot{x} & = A(t) \cdot x + B(t) \cdot u \\
							y       & = C(t) \cdot c + D(t) \cdot u
						\end{aligned} \)
					}};
				\node [main, below left = 2 of b, label = below:{ autonom, \\ linear }, label = above:C] (c) {{%
						\( \begin{aligned}
							\dot{x} & = A \cdot x + B \cdot u \\
							y       & = C \cdot x + D \cdot u
						\end{aligned} \)
					}};
				\node [main, above left = 2 of c, label = left:{ autonom, \\ i.A. nichtlinear }, label = right:D] (d) {{%
						\( \begin{aligned}
							\dot{x} & = f(x, u) \\
							y       & = g(x, u)
						\end{aligned} \)
					}};

				\draw [->] (a) to node[right]{ \(f\), \(g\) hängen \\ linear von \(x\), \(u\) ab } (b);
				\draw [->] (a) to node[left]{ \(f\), \(g\) hängen \\ nicht von \(t\) ab } (d);
				\draw [->] (b) to node[right]{ \(A\), \(B\), \(C\), \(D\) sind \\ konstant } (c);
				\draw [->] (d) to node[left]{ \(f\), \(g\) hängen \\ linear von \(x\), \(u\) ab } (c);
				;            	\end{tikzpicture}
			\caption{Dynamikmodelltypen}
			\label{fig:dynamicmodels}
		\end{figure}

		\begin{itemize}
			\item Differentialgleichung von Typ A und D sind im allgemeinen nur numerisch lösbar.
		\end{itemize}
	% end

	\section{Numerische Integration} % 5.6, 5.7, 5.32
		\todo{Rechteck, Trapezregel?}

		\begin{itemize}
			\item Bei der numerischen Integration wird versucht, eine schwer analytisch zu integrierene Funktion \( g(x) \) oder eine Differentialgleichung \( \dot{x}(t) = f(x(t)) \) zu approximieren.
			\item Hierbei spielen vor allem folgende Faktoren eine Rolle:
				\begin{itemize}
					\item Rechenaufwand (Berechnungseffizienz)
					\item Genauigkeit (Approximationsfehler)
					\item Eignung für steife Systeme (Stabilität)
					\item Implementierungsaufwand (Eigenentwicklung oder Verwendung einer Bibliothek)
				\end{itemize}
		\end{itemize}

		\subsection{Einschrittverfahren} % 5.13, 5.14
			\begin{itemize}
				\item Ein Einschrittverfahren zur Approximation eines Anfangswertproblems \( \dot{x} = f(x) \), \( x(0) = x _ 0 \) hat den allgemeinen Ansatz:
					\begin{equation*}
						x _ { k + 1 } = x _ k + h _ k \cdot \Phi(t _ k, x _ k, x _ { k + 1 }, h; f)
					\end{equation*}
					mit gegebenem \( x _ k \approx x(t _ k) \).
				\item Als Konsistenzbedingung muss \( \lim\limits_{h \rightarrow 0} \Phi(t _ k, x _ k, x _ { k + 1 }, h; f) = f(x _ k) \) gelten.
			\end{itemize}
		% end

		\subsection{Explizites Euler-Verfahren} % 5.9, 5.10, 5.11
			\begin{itemize}
				\item Das \textit{explizite Euler-Verfahren} ist ein Einschrittverfahren zur Approximation von Differentialgleichungen.
				\item Es gilt \( \Phi = f(x _ k) \), eingesetzt in den allgemeinen Ansatz:
					\begin{equation*}
						x _ { k + 1 } = x _ k + h _ k \cdot f(x _ k)
					\end{equation*}
				\item \textbf{Rechenaufwand:} Gering, eine Auswertung von \( f \) je Schritt.
				\item \textbf{Genauigkeit:} \( \mathcal{O}(h_k) \) \\
					\phantom{XXXXX} \( \implies \) Für eine hohe Genauigkeit sind sehr kleine Schrittweiten nötig. \\
					\phantom{XXXXX} \( \implies \) Stabilitätsprobleme.
			\end{itemize}
		% end

		\subsection{Implizites Euler-Verfahren} % 5.18, 5.19
			\begin{itemize}
				\item Das \textit{implizite Euler-Verfahren} ist ein Einschrittverfahren zur Approximation von Differentialgleichungen, welches sehr viel bessere Stabilitätseigenschaften als das explizite Euler-Verfahren hat.
				\item Es gilt \( \Phi = f(x _ { k + 1 }) \), eingesetzt in den allgemeinen Ansatz:
					\begin{equation*}
						x _ { k + 1 } = x _ k + h _ k \cdot f(x _ { k + 1 })
					\end{equation*}
				\item Somit erfordert jeder Schritt eine (approximative) Lösung der nichtlinearen Gleichung
					\begin{equation*}
						0 = x _ { k + 1 } - x _ k - h _ k \cdot f(x _ { k + 1 })
					\end{equation*}
				\item \textbf{Rechenaufwand:} Sehr viel höher als bei dem explizitem Newton-Verfahren.
				\item \textbf{Genauigkeit:} \( \mathcal{O}(h_k) \) \\
					\phantom{XXXXX} \( \implies \) Für eine hohe Genauigkeit sind sehr kleine Schrittweiten nötig.
					\phantom{XXXXX \( \implies \)} Im Gegensatz zum expliziten Newton-Verfahren ist das implizite aber deutlich stabiler.
			\end{itemize}
		% end

		\subsection{Heun-Verfahren} % 5.20
			\begin{itemize}
				\item Das Heun-Verfahren ist ein Prädikator-Korrektor Verfahren und ein 2-stufiges Einschrittverfahren zur Approximation von Differentialgleichungen.
				\item Prädikator-Schritt: \( x ^ p _ { k + 1 } = x _ k + h _ k \cdot f(x _ k) \) (explizites Euler-Verfahren)
				\item Korrektor-Schritt: \( x _ { k + 1 } = x _ k + h _ k \cdot \frac{1}{2} \big( f(x _ k) + f(x ^ p _ { k + 1 }) \big) \) (Mittlung des Gradienten)
				\item Insgesamt ist das Heun-Verfahren ein zweistufiges Einschrittverfahren:
					\begin{align*}
						s _ 1 & = f(x _ k)                          \\
						s _ 2 & = f(x _ k + h _ k \cdot s _ 1)      \\
						\Phi  & = \frac{1}{2} \big( s_1 + s_2 \big)
					\end{align*}
					eingesetzt in den allgemeinen Ansatz:
					\begin{equation*}
						x _ { k + 1 } = x _ k + \frac{h _ k}{2} (s _ 1 + s _ 2)
					\end{equation*}
				\item \textbf{Rechenaufwand:} Gering, zwei Auswertungen von \( f \) je Schritt.
				\item \textbf{Genauigkeit:} \( \mathcal{O}(h ^ 2) \), sehr viel besser als das implizite/explizite Euler-Verfahren.
			\end{itemize}
		% end

		\subsection{Runge-Kutta-Verfahren 4. Ordnung} % 5.21, 5.22
			\begin{itemize}
				\item Das Runge-Kutta-Verfahren ist ein 4-stufiges Einschrittverfahren zur Approximation von Differentialgleichungen.
				\item Das RK4-Verfahren setzt sich wie folgt zusammen:
					\begin{align*}
						s _ 1 & = f(x _ k)                                                                                                               \\
						s _ 2 & = f(x _ k + h _ k \cdot \alpha _ 1 \cdot s _ 1)                                                                          \\
						s _ 3 & = f(x _ k + h _ k \cdot \beta _ 1 \cdot s _ 1 + h _ k \cdot \alpha _ 2 \cdot s _ 2 )                                     \\
						s _ 4 & = f(x _ k + h _ k \cdot \gamma _ 1 \cdot s _ 1 + h _ k \cdot \beta _ 2 \cdot s _ 2 + h _ k \cdot \alpha _ 3 \cdot s _ 3) \\
						\Phi  & = \delta _ 1 \cdot s _ 1 + \delta _ 2 \cdot s _ 2 + \delta _ 3 \cdot s _ 3 + \delta _ 4 \cdot s _ 4
					\end{align*}
				\item Nun wird versucht, die Koeffizienten \( \alpha _ 1 \), \( \alpha _ 2 \), \( \alpha _ 3 \), \( \beta _ 1 \), \( \beta _ 2 \), \( \gamma _ 1 \), \( \delta _ 1 \), \( \delta _ 2 \), \( \delta _ 3 \), \( \delta _4 \) so zu bestimmen, dass die Konsistenzbedingung erfüllt ist und der Approximationsfehler möglichst gering wird (d.h. \( \mathcal{O}(h ^ 4) \)) \( \implies \delta _ 1 + \delta _ 2 + \delta _ 3 + \delta _ 4 = 1 \).
				\item Klassischerweise werden folgende Koeffizienten genutzt:
					\begin{align*}
						\alpha _ 1 & = \alpha _ 2 = \frac{1}{2}   \\
						\alpha _ 3 & = 1                          \\
						\beta _ 1  & = \beta _ 2 = \gamma _ 1 = 0 \\
						\delta _ 1 & = \delta _ 4 = \frac{1}{6}   \\
						\delta _ 2 & = \delta _ 3 = \frac{1}{3}
					\end{align*}
				\item Was zu folgendem, klassischem, RK4-Verfahren führt:
					\begin{align*}
						s _ 1 & = f(x _ k)                                      \\
						s _ 2 & = f(x _ k + \frac{h _ k}{2} \cdot s _ 1)        \\
						s _ 3 & = f(x _ k + \frac{h _ k}{2} \cdot s _ 2 )       \\
						s _ 4 & = f(x _ k + h _ k \cdot s _ 3)                  \\
						\Phi  & = \frac{1}{6} (s _ 1 + 2s _ 2 + 2s _ 3 + s _ 4)
					\end{align*}
					eingesetzt in den allgemeinen Ansatz:
					\begin{equation*}
						x _ { k + 1 } = x _ k + \frac{h _ k}{6} (s _ 1 + 2s _ 2 + 2s _ 3 + s _ 4)
					\end{equation*}
				\item \textbf{Rechenaufwand (klassisches RK4):} Vier Funktionsauswertungen von \( f \) je Schritt.
				\item \textbf{Genauigkeit (klassisches RK4):} \( \mathcal{O}(h ^ 4) \) falls \( f \) 4 Mal stetig differenzierbar ist innerhalb von \( (t _ k, r _ { k + 1 }) \).
			\end{itemize}
		% end

		\subsection{Anmerkungen} % 5.23
			\begin{itemize}
				\item Bei gegebener Schrittweite \( h _ k \):
					\begin{itemize}
						\item Der Approximationsfehler bei Verfahren höherer Ordnung (Heun, RK4) ist sehr viel geringer.
						\item Dafür ist der Rechenaufwand entsprechend höher.
					\end{itemize}
				\item Die Auswahl eines Integrationsverfahrens ist abhängig von Anforderung an die Genauigkeit:
					\begin{itemize}
						\item Je Höher die Anforderung an die Genauigkeit, desto höher sollte die Ordnung des Verfahrens sein. \\ Beispiel: Bei einer Genauigkeitsanforderung von \( 10 ^ {-4} \) kann das Heun-Verfahren, bei \( 10 ^ {-8} \) sollte besser ein RK7- oder RK8-Verfahren verwendet werden.
						\item Für die meisten Anforderungen in ein Verfahren 1. Ordnung (Euler-Verfahren) zu ungenau.
					\end{itemize}
				\item Allerdings verstärken sich Rundungsfehler bei sinkender Schrittweite stark.
			\end{itemize}
		% end

		\subsection{Schrittweitensteuerung} % 5.24, 5.25, 5.26
			\begin{itemize}
				\item Eine konstante Schrittweite \( h _ k = h \) ist
					\begin{itemize}
						\item \textit{ungenau}, wenn sich die gesuchte Lösung lokal sehr stark ändert und
						\item \textit{ineffizient}, wenn sich die gesuchte Lösung lokal sehr wenig ändert.
					\end{itemize}
				\item Abhilfe schafft hier eine Schrittweitensteuerung, um
					\begin{itemize}
						\item \( h _ k \) so \enquote{groß wir möglich} aber \enquote{so klein wie nötig} zu wählen sodass
						\item der lokale Approximationsfehler unterhalb einer vorgegebenen Fehlerschranke bleibt.
					\end{itemize}
				\item Es gibt unterschiedliche Varianten der Schrittweitensteuerung, die üblichen sind:
					\begin{enumerate}
						\item Ein Einschrittverfahren der Ordnung \( p \) mit \( s \) Stufen.
							\begin{itemize}
								\item Berechnung von 2 Näherungen für \( x _ { k + 1 } \), einmal mit der Schrittweite \( h _ k \) und einmal mit zwei Schritten mit jeweils der Schrittweite \( \frac{h _ k}{2} \).
								\item Daraus wird der lokale Fehler geschätzt.
								\item Dann wird ein neuer Schrittweitenvorschlag \( \hat{h} _ k \) produziert, sodass der Fehler unter der vorgegebenen Schranke liegt.
								\item Ist der lokale Fehler unter der vorgegebenen Schranke, wird der Schritt akzeptiert (mit der durch \( \frac{h _ k}{2} \) berechneten Näherung) und es wird mit dem nächsten Schritt fortgefahren.
								\item Ansonsten wird der Schritt mit dem neuen Schrittweitenvorschlag \( \hat{h} _ k \) wiederholt.
								\item \textbf{Berechnungsaufwand:} \( s + 2s \) Auswertungen von \( f \).
							\end{itemize}
						\item Zwei verwandte Verfahren unterschiedlicher Ordnungen \( p, \tilde{p} \).
							\begin{itemize}
								\item Berechnung von 2 Näherungen für \( x _ { k + 1 } \) für die selbe Schrittweite \( h _ k \).
								\item Daraus wird der lokale Fehler geschätzt.
								\item \textbf{Berechnungsaufwand:} Bei geeigneter Wahl der verfahren unterscheiden sich nur die \( \delta _ i \)-Koeffizienten, sodass nur \( s + 1 \) Auswertungen nötig sind.
								\item Der Ansatz ist sehr viel effizienter als der erste, dafür ist (bei geringer Ordnung) das erste Verfahren etwas robuster.
							\end{itemize}
					\end{enumerate}
			\end{itemize}
		% end
	% end

	\section{Integration steifer Differentialgleichungen} % 5.28, 5.29
		Für eine Definition von steifen Differentialgleichungen siehe \ref{sec:steifedgl}.

		\begin{itemize}
			\item Steife Differentialgleichungen sind im allgemeinen schwer zu lösen.
			\item Zur Berechnung von Lösungen sind ausschließlich implizite Verfahren geeignet.
		\end{itemize}
	% end

	\section{Integration von Zustands-Differentialgleichungen mit Unstetigkeiten} % 5.35, 5.36
		\label{sec:integrationunstetig}

		\todo{Beispiel, z.B. von Übungsblatt 9.}

		\begin{itemize}
			\item Die bisherigen Verfahren fordern, dass eine Differentialgleichung \( \dot{x} = f(x, u, t) \) mindestens so oft \textit{stetig differenzierbar} ist, wie die Ordnung des Verfahrens. \\ Ansonsten führt dies zu einem massivem Genauigkeitsverlust.
			\item Aber: In der realen Welt ist nicht alles stetig differenzierbar.
			\item Annahmen:
				\begin{itemize}
					\item Die Funkion \( f \) ist abschnittsweise stetig differenzierbar.
					\item An den Übergängen der Abschnitte ist \( f \) möglicherweise unstetig aber nicht differenzierbar.
					\item Die Übergänge werden durch formulierbare Ereignisse (Events) ausgelöst, die zustands- oder zeitabhängig sein können.
				\end{itemize}
		\end{itemize}

		\subsection{Ursachen für Unstetigkeiten} % 5.37, 5.38
			Ursachen für Unstetigkeiten in realen Systemen können beispielsweise sein:
			\begin{itemize}
				\item \textit{Stoßvorgänge:} Position ändert sich stetig, aber nicht differenzierbar. \\ Beispiele: Hüpfender Ball; Kollision in physikalisch-basierter Animation
				\item \textit{Reibung in mechanischen Systemen:} Übergänge zwischen Gleit- und Haftreibung sind meist unstetig.
				\item \textit{Strukturvariable Systeme:} Die Anzahl der Freiheitsgrade des Zustands ändert sich. \\ Beispiele: Abheben eines Roboterbeins vom Boden; Verlust eines Gelenkantriebs eines Roboterarms
				\item \textit{Approximation von Teilmodellen von \(f\)} mit stückweise stetigen Funktionen. \\ Beispiel: Lineare Interpolation von Tabellendaten
				\item \textit{Hysterese:} Ein Teil von \(f\) hängt von der aktuellen Vorgeschichte von \(x\) ab.
				\item \textit{Unstetige zeitabhängige Stellgrößen \(u\):} Zeitabhängige Eingangsfunktion mit Unstetigkeiten zu bekannten Zeitpunkten (Zeitereignisse) \\ Beispiele: Ventil auf/zu; Gangschaltung
				\item u.v.m.
			\end{itemize}
		% end

		\subsection{Schaltfunktionen} % 5.40
			\begin{itemize}
				\item Die \textit{Schaltzeitpunkte} \( t _ { s, i } \) werden im Allgemeinen als (einfache!) \textit{Nullstellen} \( n _ q \) reeller \textit{Schaltfunktionen}
					\begin{equation*}
						q _ l (x(t _ { s, i }), t _ { s, i }) = 0, \quad l \in \{ 1, \cdots, n _ q \}
					\end{equation*}
					modelliert.
				\item Bei der numerischen Integration müssen nun die \textit{Vorzeichen} der Schaltfunktion beobachtet werden:
					\begin{itemize}
						\item Wenn zwischen der Näherung \( x _ k \approx x(t _ k) \) und \( x _ { k + 1 } \approx x(t _ { k + 1 }) \) ein Vorzeichenwechsel in mindestens einer Schaltfunktion auftritt (d.h. die Schaltfunktion schaltet), dann muss:
						\item Der dazwischen liegende Schaltpunkt bestimmt werden (mit der vorgegebenen Genauigkeit und der vom Verfahren implizit vorgegebenen Genauigkeit).
						\item[] \( \rightarrow \) Kombination auf numerischer Integration und numerischer Nullstellensuche.
					\end{itemize}
				\item Voraussetzung: Die Schrittweite \( h _ k \) muss klein genug sein, sodass kein doppelter Vorzeichenwechsel innerhalb eines Schrittes stattfindet.
			\end{itemize}

			\subsubsection{Vorgehensweise} % 5.43
				\begin{enumerate}
					\item Das Modell (die Differentialgleichung) auf \textbf{mögliche Unstetigkeiten} in \(x\), der rechten Seite oder den ersten Ableitungen der rechten Seite überprüfen.
					\item Bestimmung der \textbf{Schaltzeitpunkte} \( t _ {s,i} \), \( i = 1, \cdots, n _ s \):
						\begin{description}
							\item[Zeitgesteuert] Zu offensichtlich bekanntem \( t _ { s, i } \).
							\item[Zustandsabhängig] Modellierung als Nullstelle einer Schaltfunktion \( q _ k (x(t _ { s, i }), t _ { s, i }) = 0 \), \( k \in \{ 1, \cdots, n _ q \} \).
						\end{description}
					\item \textbf{Numerische Integration} von einem Schaltpunkt zum nächsten unter \enquote{genauer} Einhaltung der Schaltpunkte. \\ Möglicherweise spezielle Integrationsverfahren mit Schaltpunktsuche verwenden.
					\item \textbf{Wiederaufsetzen} nach einem Schaltpunkt (wie ein normales, neues Anfangswertproblem). \\ Anfangswert für \(x\) aus einer Zustandsübergangsbedingung, zum Beispiel vom Typ \( x(t _ { s, i } + 0) = \xi(x(t _ { s, i } - 0), t _ { s, i }) \).
				\end{enumerate}
			% end
		% end

		\subsection{Anmerkungen} % 5.44
			Was passiert, wenn der Integrator einfach über die Schaltstelle drüber iteriert?
			\begin{itemize}
				\item Ein \textit{Integrator mit konstanter Schrittweite} merkt gar nichts hiervon.
				\item Ein \textit{Integrator mit Schrittweitensteuerung} merkt, dass das Modell sich stark ändert.
					\begin{itemize}
						\item Somit wird die Schrittweite verringert bis die minimale Schrittweite erreicht wurde.
						\item Häufig stoppen diese Verfahren nun, da die minimale Schrittweite erreicht wurde, die Genauigkeitsanforderung aber nicht erfüllt werden kann.
						\item Alternativ schreitet das Verfahren fort und nimmt den Fehler in kauf.
					\end{itemize}
			\end{itemize}
			Dies führt in allen Fällen dazu, dass die gewünschte Genauigkeit nicht erreicht wird.
		% end
	% end
% end

\chapter{Teilschritte einer Simulationsstudie} % 6, 6.2, 6.5, 6.15, 6.30, 6.33, 1.63
	Die Teilschritte einer Simulationsstudie sind:
	\begin{enumerate}
		\item Problemspezifikation
			\begin{itemize}
				\item Aufgabenformulierung
				\item Kriterienfestlegung
				\item Datenerhebung
				\item Siehe \ref{sec:simproblemspez}.
			\end{itemize}
		\item Modellierung
			\begin{itemize}
				\item Strukturfestleung
				\item Modellgleichungen
				\item Modellvereinfachung
				\item Siehe \ref{sec:simmodelling} und \ref{c:simmodelling}.
			\end{itemize}
		\item Implementierung
			\begin{itemize}
				\item Auswahl oder Entwicklung eines Berechnungsverfahrens (für das jeweilige Model)
				\item Programmierung von Modell und Berechnungsverfahren
				\item Visualisierung von Berechnungsergebnissen
				\item Laufzeitoptimierung
				\item Siehe \ref{sec:simmodelling}
			\end{itemize}
		\item Validierung
			\begin{itemize}
				\item Systematische Plausibilitätsprüfung (\enquote{Stimmen Modell und Simulation?})
				\item Fehlersuche
				\item Konsistenzprüfung
				\item Daten-, Parameterabgleich
				\item Siehe \ref{c:simvalidierung} und \ref{c:simmodelling}.
			\end{itemize}
		\item Anwendung
			\begin{itemize}
				\item Simulationsläufe
				\item Parametervariation
				\item Strukturvariation
				\item Vorhersage und Optimierung
				\item Siehe \ref{sec:simanwendung}.
			\end{itemize}
	\end{enumerate}
	Einiger dieser Schritte werden in folgenden tiefer behandelt.

	\section{Problemspezifikation} % 1.38, 1.39
		\label{sec:simproblemspez}

		Kernfrage: Was ist der Zweck der Simulation?

		\begin{enumerate}
			\item Ein bekanntes Szenario \textit{verstehen}/\textit{nachvollziehen}.
			\item Ein bekanntes Szenario \textit{optimieren}.
			\item Ein unbekanntes Szenario \textit{vorhersagen}.
			\item Wieso nicht die Realität verwenden, welche bessere Ergebnisse liefert?
				\begin{itemize}
					\item Zu groß, klein (Galaxien, Moleküle)
					\item Zu schnell, zu langsam (Flugzeuge, Population, Klima)
					\item Noch nicht gebaut (Flugzeuge, Brücken, Roboter)
					\item Zu gefährlich (Kernphysik, Humanmedizin)
					\item Nicht Experimentierbar (Volkswirtschaft, Ökosysteme)
					\item Zu teuer (Auto Crash Test, Raketen, Roboter)
					\item Zu stark gestört (Börsenkurse, Wirtschaft)
				\end{itemize}
			\item[\( \implies \)] Eine Simulation eignet sich, wenn das reale System nicht oder nur unter großem Aufwand zur Verfügung steht.
		\end{enumerate}
	% end

	\section{Modellierung} % 1.41, 1.42
		\label{sec:simmodelling}

		\begin{itemize}
			\item Die zu entwickelnden Strukturen und Gleichungen zielen nur auf spezifische Aufgaben und Ziele ab! Für unterschiedliche Aufgaben werden unterschiedliche Modelle benötigt.
			\item Die reale Welt wird aufgeteilt in das zu untersuchende System und seine Umwelt, mit der es über Ein- und Ausgaben in Wechselwirkung steht.
			\item Das Modell ist ein Ersatzsystem, welches unter Annahmen und Idealisierungen gebildet wird.
			\item Modellierung bedeutet, durch Abstraktion wichtige Bestandteile und Eigenschaften hervorzuheben und unwichtiges zu entfernen.
		\end{itemize}

		\subsection{Herleitung von Modellen} % 1.43, 1.44, 1.45
			Bei der Herleitung von Modellen muss ein Gleichgewicht zwischen den folgenden Anforderungen gefunden werden:
			\begin{enumerate}
				\item Um Ergebnisse am Modell nutzen zu können, muss eine ausreichend genaue Modellierung mit der für den Simulationszweck relevanten Parametern durchgeführt werden.
				\item Um das Modell einfacher handhaben zu können als die Realität, müssen Details weggelassen werden (Idealisierung und Abstraktion).
			\end{enumerate}
			Allerdings ist vorher meistens nicht bekannt, welche Merkmale relevant sind. Die Auswirkungen dieser sind im Allgemeinen nicht vorhersagbar.

			Bei der Herleitung von Modellen müssen die folgenden Fragen beantwortet werden können:
			\begin{enumerate}
				\item \textit{Was} genau soll modelliert werden? \\ Beispiel: Der gesamte Arbeitsraum (Geometrie, Kinematik) oder nur die Kräfte (Kinetik)?
				\item Welche \textit{Größen} spielen eine Rolle (qualitativ) und wie groß ist deren Einfluss (quantitativ)? \\ Beispiele: Gelenkwinkel, Motorspannungen; Gravitation eines Himmelskörpers
				\item[] Achtung: Im allgemeinen sind diese Größen alles andere als offensichtlich!
				\item In welchem \textit{Beziehungsgeflecht} stehen die als relevant identifizierten Größen miteinander?
					\begin{itemize}
						\item Qualitative vs. Quantitative Abhängigkeit (wenn-dann, Vorzeichen oder konkrete Größen der Abhängigkeiten)
						\item Typischerweise sind die Beziehungen sehr kompliziert, z.B. Kontaktkräfte zwischen Roboterhand und unterschiedlichen Objekten
					\end{itemize}
				\item Mit welchen \textit{Instrumenten} lassen sich die Wechselwirkungen und Abhängigkeiten beschreiben?
					\begin{itemize}
						\item Algebraische Gleichungen und Ungleichungen
						\item Systeme gewöhnlicher Differentialgleichungen (mit einer unabhängigen Variablen, meistens der Zeit)
						\item Systeme partieller Differentialgleichungen (mehr als eine unabhängige Variable, meistens zeit und Ort)
						\item Automaten, Zustandsübergangsdiagramme
						\item Graphen
						\item Wahrscheinlichkeitsverteilung
						\item Fuzzy Logic
						\item Gaußsche Prozesse
						\item Neuronale Netze
						\item u.v.m.
					\end{itemize}
				\item Welche Gestalt hat die \textit{resultierende Berechnungsaufgabe} zur Lösung der Modellbeziehung?
					\begin{itemize}
						\item Finden \textit{einer Lösung} zu gegebenem Gleichungssystem
						\item Finden \textit{der Lösung} zu gegebenem Gleichungssystem
						\item Lösen einer Existenzaufgabe
						\item Lösen einer beschränkten Optimierungsaufgabe
						\item Ermittlung von Flaschenhälsen und Störenfrieden
					\end{itemize}
			\end{enumerate}
		% end

		\subsection{Zustandsvariablen eines Modells} % 1.55
			\begin{itemize}
				\item Zeitabhängige Größen
				\item Exakte Festlegung der aktuellen Konfiguration eines Systems
				\item Festlegung des zukünftigen Verlaufs
				\item Nicht redundant
			\end{itemize}
			Die Festlegung der Zustandsvariablen ist der Ausgangspunkt jeder Modellbildung.
		% end

		\subsection{Klassifikation der Zustandsänderungen} % 1.59
			\begin{itemize}
				\item Zeit-, Wertkontinuierlich
				\item Zeit-, Wertdiskret
				\item Zeitdiskret, Wertkontinuerlich
				\item Ereignisdiskret, Wertdiskret
				\item Stochastisch
			\end{itemize}

			\todo{Hier kann man bestimmt noch eine Grafik malen...}
		% end
	% end

	\section{Implementierung} %  
		\label{sec:simimpl}

		\subsection{Klassifikation zeitkontinuierlicher Simulationswerkzeuge} % 6.21, 6.22, 6.23
			\begin{itemize}
				\item[Level 3] Multidisziplinäre Modellgenerierung (Modelica, VHDL-A, \dots)
				\item[Level 2] Graphische Modellierung (SIMULINK, WorkingModel, Aspen, STELLA, \dots) \\
					Spezialsimulatoren (ADAMS, SIMPACK, KSIM, \dots)
				\item[Level 1] Simulationssprachen (ACSL, VHDL, Dare-P, Desire, \dots) \\
					Simulationsframeworks (SIMULINK, C++-Klassenbibliothek)
				\item[Level 0] Direkte Programmierung (C++, C, MATLAB, FORTRAN)
			\end{itemize}
		% end
	% end

	\section{Anwendung} % 6.34
		\label{sec:simanwendung}

		\begin{itemize}
			\item \enquote{Laufen lassen} der Simulation; Simulieren
			\item Dieser Schritt nimmt, im Vergleich zu den vorherigen Schritten, nur wenig (Menschen-) Zeit ein.
			\item Die Berechnung selbst kann natürlich lange dauern.
		\end{itemize}
	% end

	\todo{Kann man sich noch überlegen... Eher nicht.}
	%\section{Beispiel: Schiffsschaukel} %  
	%    \todo{Content}
	%
	%    \subsection{Problemspezifikation} % 6.4, 1.57, 1.58
	%        \todo{Content}
	%    % end
	%
	%    \subsection{Modellierung} % 6.6, 6.7, 6.8, 6.9, 6.10, 6.11, 6.12, 6.13, 1.55, 1.56
	%        \todo{Content}
	%    % end
	%
	%    \subsection{Implementierung} % 6.16, 6.17, 6.18, 6.19, 6.20, 6.24, 6.25, 6.26, 6.27, 6.28
	%        \todo{Content}
	%    % end
	%% end
% end

\chapter{Validierung} % 7, 7.3
	\label{c:simvalidierung}

	\begin{itemize}
		\item Zu dem zu validierenden \textit{Simulationsmodell} gehören das \textit{Modell}, die \textit{Implementierung} und die \textit{Berechnungsverfahren}.
		\item Die Validierung eines Simulationsmodell beschäftigt sich mit der \textit{systematischen Plausibilitätsprüfung} und damit der Fehlersuche, Konsistenzprüfung und Daten-/Parameterabgleich.
		\item Eine Lösung kann nur akzeptiert werden, wenn in allen vier Schritten (Modellierung, Diskretisierung, Abbruch- und Rundungsfehler, Visualisierungsfehler) vergleichbar kleine Fehler gemacht wurden.
	\end{itemize}

	\section{Fehlerquellen} % 7.4, 7.13
		\begin{itemize}
			\item \textit{Modellierungsfehler} (Vereinfachte Modellannahmen, Ungenaue Modellparameter)
			\item \textit{Approximationsfehler} der Berechnungsverfahren
			\item \textit{Rundungsfehler}
			\item \textit{Programmier-, Implementierungsfehler}
		\end{itemize}
	% end

	\section{Begriffe und Definitionen} % 7.6, 7.7, 7.12
		\paragraph{Verifikation}
			\begin{itemize}
				\item Normaler (meist mathematischer) Nachweis der Korrektheit, dass ein Programm einer vorgegebenen Spezifikation entspricht.
				\item Aufgrund der großen Anzahl an Parametern, Zustandsverläufen und Störungseinflüssen ist es in der Regel unmöglich, die vollständige Korrektheit des gesamten Systems zu beweisen.
				\item Durch geeignete Anzahl und systematischer gesuchter Tests kann die Wahrscheinlichkeit der Korrektheit erhöht werden. \\ \( \rightarrow \) Validierung
			\end{itemize}
		% end

		\paragraph{Validierung}
			\begin{itemize}
				\item Plausibilitätsprüfung, dass ein Programm einer vorgegebenen Spezifikation entspricht.
				\item Ziel der Validierung ist der Nachweis der ausreichenden Glaubwürdigkeit des Simulationsmodells im Hinblick auf den Einsatzbereich.
				\item Validierung ist wichtig, da dadurch das Risiko von verheerenden Zwischenfällen und Falschaussagen über die Realität stark verringert wird.
			\end{itemize}
		% end
	% end

	\section{Vorgehensweise} % 7.14
		Die Validierung erfordert fachliche Einsicht und Kreativität! Es gibt keine pauschal guten Lösungen.

		\subsection{Validierung der Implementierung (D, L, V)} % 7.15
			\begin{itemize}
				\item[I1] \textit{Syntaktische Fehlerfreiheit} der Implementierung
				\item[I2] \textit{Plausibilitätsprüfung} der Simulationsergebnisse für Spezialfälle (\enquote{naturgetreues} Verhalten)
				\item[I3] \textit{Numerische Korrektheit} der Implementierung (zum Beispiel durch Vergleich der berechneten Lösung und einer analytischen Lösung)
			\end{itemize}
		% end

		\subsection{Validierung des Modells (M)} % 7.16
			\begin{itemize}
				\item[M1] \textit{Zulässigkeit und logische Konsistenz} der Modellannahmen (und deren Anwendbarkeit zur Problemlösung)
				\item[M2] \textit{Ausreichende Detailliertheit} des Modells (und korrekte Modellstruktur)
				\item[M3] \textit{Korrektheit (Genauigkeit)} der Modellparameter
			\end{itemize}
		% end

		\subsection{Validierung des Berechnungsverfahrens (D, L)} % 7.17
			\begin{itemize}
				\item[B1] \textit{Eignung} für die numerische Lösung des Modells
				\item[B2] \textit{Approximationsfehler} des (iterativen) Berechnungsverfahrens
				\item[B3] Einfluss von \textit{Rundungsfehlern}
			\end{itemize}
		% end

		\subsection{Tests auf Plausibilität und Konsistenz} % 7.18, 7.19
			\begin{itemize}
				\item[T1] \textit{Reproduktion} von beobachtetem bzw. \enquote{natürlichen} Systemverhalten \\ Wie gut stimmt das berechnete verhalten mit den beobachteten/bekannten Erkenntnissen überein?
				\item[T2] \textit{Vorhersage} von Verhalten \\ Wie plausibel ist das simulierte Verhalten für noch nicht beobachtete Szenarien? \\ Können die Ergebnisse eines Experiments mit ausreichender Genauigkeit vorhergesagt werden?
				\item[T3] \textit{Verhaltensanomalien} \\ Stark unterschiedliches/widersprüchliches Verhalten des Modells gegenüber dem realen System weißt auf große Fehler im Modell oder im Berechnungsverfahren oder in der Implementierung hin.
				\item[T4] Systemverhalten in \textit{Extremsituation} \\ Entspricht das simulierte Verhalten in extremen Szenarien den Erwartungen, auch wenn diese in der Realität selten/nie auftreten?
				\item[T5] \textit{Parametervariationen und Parametersensitivität} \\ Ist das Verhalten sensitiv zu plausiblen Variationen der Modellparameter?
			\end{itemize}
		% end
	% end
% end

\chapter{Identifikation von Modellen} % 8
	\label{c:simmodelling}

	\section{Systemidentifikation} % 8.1, 8.2, 8.3
		Das Ziel der Systemidentifikation ist zu bestimmen, wie die Ausgangsgrößen von den Eingangsgrößen quantitativ abhängen, also der Bestimmung eines Systemmodells \(f\) mit geeigneten Parameterwerten \(p\) (der rechten Seite von \( \dot{x} = f(x(t), p) \)).

		Dies hat folgenden Nutzen:
		\begin{itemize}
			\item Bessere (d.h. genauere) Vorhersagen durch Simulation mit den identifizierten Modellen.
			\item Validierung von bestehenden Simulationsmodellen.
		\end{itemize}

		\subsection{Arten der und Modellbildung} % 8.4, 8.5
			Arten von Modellbildung:
			\begin{enumerate}
				\item Spekulation \\ Beispiel: Soziale Systeme
				\item Vorhersage \\ Beispiel: Ökonomische Systeme
				\item Analyse \\ Beispiel: Biologische Systeme
				\item Steuerung \\ Beispiel: Chemische Systeme, Mechanische Systeme
				\item Design \\ Beispiel: Mechanische Systeme, Elektrotechnische Schaltungen
			\end{enumerate}

			Des weiteren können die obigen Modellbildungsarten in die drei Oberkategorien \enquote{Black Box} und \enquote{White Box} eingeteilt werden:
			\begin{itemize}
				\item Black Box
					\begin{itemize}
						\item Modellbildung auf Basis des beobachteten Verhaltens am Ausgang in Abhängigkeit vom Eingang.
						\item Induktives Vorgehen bei der Modellierung.
						\item Generische Ansätze, die allgemeine Funktionen repräsentieren, z.B. \( \dot{x} = \hat{f}(x(t), p) \). \\ Die Parameter \(p\) beschreiben dann die Struktur und die Ausgestaltung der Ansatzfunktion(en) von \( \hat{f} \).
					\end{itemize}
				\item White Box
					\begin{itemize}
						\item Modellbildung auf Basis grundlegender Gesetzmäßigkeiten und der Systemstruktur.
						\item Deduktives Vorgehen bei der Modellierung.
						\item Aus grundlegenden Gesetzmäßigkeiten (Mechanik, Elektrotechnik, \dots) abgeleitete Modelle, z.B. Differentialgleichungen \( \dot{x} = f(x(t), p) \). \\ Die Parameter \(p\) können mit experimenteller Daten identifiziert, bzw. kalibriert werden.
					\end{itemize}
			\end{itemize}
			Außerdem gibt es noch den Ansatz einer \enquote{Grey Box}, welche Ansätze von Black und White Box vereint.
		% end

		\subsection{Hauptschritte der Systemidentifikation} % 8.6
			\begin{itemize}
				\item \textit{Strukturidentifikation} \\ Stimmt das Verhalten von \(f\) mit den vorhandenen Daten und generellen Erkenntnissen überein?
				\item \textit{Parameteridentifikation} \\ Die Struktur ist bereits gegeben, es müssen die Modellparameter \(p\) gefunden werden, sodass die Abweichungen zwischen experimentellen und simuliert Daten möglichst klein werden.
			\end{itemize}

			\warning{Die beste Lösung ist nicht unbedingt die mit dem kleinsten Fehler. Es müssen auch andere Faktoren, zum Beispiel Differenzierbarkeit betrachtet werden.}
		% end
	% end

	\section{Parameteridentifikation} % 8.8, 8.9, 8.10, 8.11
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}[every node/.style = { draw, rectangle, align = center}, shorten >= 1pt]
				\node (a) { Ingenieru-/natur- \\ wissenschaftlicher \\ Prozess };
				\node [right = 2 of a] (b) { Modell \\ \( \dot{x} = f(x, t, p) \) };
				\node [below = of a] (c) { Experiment };
				\node [below = of b] (d) { Numerische \\ Simulation };

				\draw [->, dashed] (a) -- (b);
				\draw [->] (a) -- (c);
				\draw [->] (b) -- (d);
			\end{tikzpicture}
			\caption{Parametereinschätzung bei DGL-Systemen}
		\end{figure}

		\begin{itemize}
			\item Kalibrierung der Modellparameter \(p\): \( \eta _ {ij} = x _ i(t_j)+\varepsilon_{ij} \)
				\begin{itemize}
					\item \( n _ {ij} \) beschreiben die experimentell gemessenen Werte von \( x _ i (t_j) \).
					\item \( x(t_j, p) \) beschreibt das Ergebnis der numerischen Simulation mit Parameter \(p\).
				\end{itemize}
			\item Es sollen nun die Quadrate der Abweichungen minimiert werden (\( \omega _ {ij} = \textit{const} > 0 \) sind die Gewichtungsfaktoren):
				\begin{equation*}
					\min \limits _ { p \in \mathbb{R} ^ n } \varphi(p) = \frac{1}{2} \sum_{j=1}^{n_t} \sum_{i \in I _ j} \omega _ {ij} \cdot \big( \underbrace{\eta _ {ij} - x _ i (t _ j, p)}_{\coloneqq r _ {ij} (p)} \big) ^ 2
				\end{equation*}
			\item Nebenbedingung. \( x \) ist eine numerische Lösung des AWP
				\begin{equation*}
					\dot{x} _ i = f_i(x, t, p), \quad x_i(0) = x _ { i, 0 }, \quad i = 1, \cdots, n _ x
				\end{equation*}
		\end{itemize}

		\subsection{Schema der Parameteridentifikation}
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[main/.style = { draw, rectangle }, align = center]
					\coordinate [label = left:Start] (init);
					\coordinate [right = 2 of init] (inithelp);
					\node [main, right = 2 of inithelp, label = above:{ Reales Experiment }] (real) {Reales System};
					\node [main, below = of real, label = above:{ Simuliertes Experiment }] (simu) {Mathematisches Modell \\ \( \dot{x} = f(x, p) \)};
					\coordinate (centerhelp) at ($(real.south east)!0.5!(simu.north east)$);
					\node [right = 2 of centerhelp] (subtract) { \resizebox{0.5cm}{!}{\( \ominus \)} };
					\node [main, right = of subtract] (iden) { Identifikation \\ der Merkmale };
					\coordinate [below = of simu] (helpsimu);

					\draw (init) -- (inithelp);
					\draw[->, shorten >= 1pt] (inithelp) -- (real);
					\draw[->, shorten >= 1pt] (inithelp) |- (simu);
					\draw[->, shorten >= 1pt] (real) -| node[above]{Messwerte \( \hat{x} _ i, \dot{\hat{x}} _ i \)} (subtract);
					\draw[->, shorten >= 1pt] (simu) -| node[below]{Simulations- \\ ergebnisse \( x _ i, \dot{x} _ i \)} (subtract);
					\draw[->, shorten >= 1pt] (subtract) -- (iden);
					\draw (iden) |- node[below]{Parametereinschätzung \(p\)} (helpsimu);
					\draw[->, shorten >= 1pt] (helpsimu) -- (simu);
				\end{tikzpicture}
				\caption{Schema der Parameteridentifikation}
			\end{figure}
		% end

		\subsection{Gütekriterien} % 8.12, 8.13
			Zur Bewertung (und Minimierung) des Abweichungsfehlers sind unterschiedliche Gütekriterien möglich, beispielsweise:
			\begin{itemize}
				\item Definition: \( r_i(p) \coloneqq \eta _ {ij} - x _ i (t _ j, p) \)
				\item Summe der Absolutbeträge der Abweichungen
					\begin{equation*}
						\varphi _ 1 (p) = \lVert r(p) \rVert _ 1 = \sum_{i = 1}^{n _ r} \abs{r_i(p)}
					\end{equation*}
				\item Summe der \enquote{kleinsten Quadrate}
					\begin{equation*}
						\varphi _ 2 (p) = \frac{1}{2} \lVert r(p) \rVert _ 2 ^ 2 = \frac{1}{2} \sum_{i = 1}^{n _ r} \big( r _ i (p) \big) ^ 2
					\end{equation*}
				\item Maximale Abweichung
					\begin{equation*}
						\varphi _ \infty (p) = \max \{ \abs{r _ i (p)} : i = 1, \cdots, n _ r \}
					\end{equation*}
			\end{itemize}

			Bei der Wahl der Gütefunktion ist jedoch einiges zu beachten:
			\begin{itemize}
				\item Bei der Auswahl ist zu beachten, wie das numerische Optimierungsverfahren zur Berechnung funktioniert und wie gut es mit der ausgewählten Gütefunktion zusammenarbeiten kann.
				\item Auch wenn \(r\) differenzierbar ist, sind \( \varphi_1 \) und \( \varphi_\infty \) im Allgemeinen \textit{nicht differenzierbar}. Differenzierbar erleichtern die Suche nach einem Minimum immens (durch Nullstellenfindung auf \( \frac{\partial}{\partial p} \varphi _ i (p) \)).
				\item \( \varphi _ \infty \) ist jedoch sehr sensitiv gegenüber einzelnen Ausreißern.
				\item \( \varphi _ 2 \) ist stetig differenzierbar, aber wenig sensitiv gegenüber einzelnen Ausreißern.
				\item Generell liegen bei durch Minimierung von Abweichung produzierten Optimierungsproblemen viele lokale Minima vor, die globale Optimierung ist somit nicht gegeben.
			\end{itemize}

			\subsubsection{Nichtlineare, Kleinste Quadrate} % 8.14
				\begin{itemize}
					\item Meistens wird das verfahren der kleinsten Quadrate (\( \varphi _ 2 \)) verwendet (u.a. wegen der Differenzierbarkeit).
					\item Auch ist das Verfahren aus statistischen Gründen interessant: \\ Wenn
						\begin{itemize}
							\item die Messfehler \( \varepsilon _ {ij} \) unabhängig und
							\item normalverteilt sind mit Median \(0\) und konstanter Varianz \( \omega^2 \),
						\end{itemize}
						dann ist die Lösung des Optimierungsproblems eine Lösung mit größtmöglicher Wahrscheinlichkeit.
					\item Durch Ausnutzung der Struktur von \( \varphi _ 2 \) kann die Effizienz der numerischen Optimierung stark erhöht werden.
				\end{itemize}
			% end
		% end

		\subsection{Kalibrierung} % 8.19, 8.20
			\paragraph{Erfolg}
				\begin{itemize}
					\item Können die Parameter \(p\) so berechnet werden, dass die Abweichungen des Modells von dem Experiment \enquote{klein} sind, dann \enquote{stimmen} Modell und Parameter.
				\end{itemize}
			% end

			\paragraph{Misserfolg}
				\begin{itemize}
					\item Können keine Parameter \(p\) gefunden werden, dann ist möglicherweise
						\begin{enumerate}
							\item das Optimierungsverfahren ungeeignet,
							\item die experimentellen Daten nicht ausreichend relevant für die Bestimmung der Parameter,
							\item die Messfehler in den Messdaten zu groß oder Ausreißer verfälschen die Messwerte oder
							\item das verwendete Modell ist nicht detailliert genug oder enthält nicht alle/nicht die richtigen Effekte.
						\end{enumerate}
				\end{itemize}
			% end
		% end
	% end
% end

\chapter{Physikalisch basierte Spiele} % 9
	\section{Definition} % 9.5, 9.6
		\paragraph{Was ist ein Computerspiel?}
			Ein Spiel ist ein interaktives Erlebnis, welches den Spieler mit immer schwereren Aufgaben fordert, in denen er oder sie neue Techniken lernt und die Aufgaben eventuell meistert.

			\begin{itemize}
				\item In den meisten Fällen wird ein mathematisches Modell zur Approximation und Simulation der Welt verwendet.
				\item In agenten-basierten Simulation interagieren mehrere eigenständige Einheiten (\enquote{Agenten}), zum Beispiel Charaktere, Fahrzeuge, \dots.
				\item Alle interaktiven Spiele sind zeitliche Simulationen, das heißt die Spielwelt ist dynamisch und der Zustand ändert sich mit der Zeit.
				\item Ein Computerspiel muss nur auf begrenzt viele und vorhersehbare Eingaben des Spielers reagieren.
				\item Die meisten Spiele präsentieren die Geschichten und reagieren auf den Spieler in Echtzeit. Das heißt, sie sind interaktive Echtzeit-Simulationen, die sich dementsprechend an gewisse Beschränkungen halten müssen (ein nicht-einhalten hat in der Regel aber keine dramatischen Folgen).
			\end{itemize}
		% end
	% end

	\section{Game Loop} % 9.7
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}[->, shorten >= 1pt, align = center, draw, rectangle]
				\node [] (init) {Initialisierung};
				\node [right = of init] (in) {Spielereingabe};
				\node [below = of in] (updt) {Update \\ Game Interna};
				\node [below = of updt] (updd) {Update Display \\ (Rendering)};
				\node [right = of updt] (end) {Spielende};
				\coordinate (inhelp) at ($(init.east)!0.5!(in.west)$);

				\draw (init) -- (in);
				\draw (in) -- (updt);
				\draw (updt) -- (updd);
				\draw (updt) -- (end);
				\draw (updd) -| (inhelp);
			\end{tikzpicture}
			\caption{Game Loop der Hauptereignisse}
		\end{figure}
	% end

	\section{Game Engine} % 9.8
		Die Game Engine enthält unter anderem:
		\begin{itemize}
			\item Eine API, mit der das Spiel selbst kommunizieren kann.
			\item Scripting Engine
			\item AI Engine
			\item Physics Engine
			\item Sound Engine
			\item Graphics Engine
			\item Netzwerke
			\item I/O.Geräte
			\item Schnittstellen und Kernsystem (mathematische Funktionen, Datenstrukturen, Speicher-/Dateiverwaltung/\dots)
		\end{itemize}
		Auf der untersten Ebene Kommuniziert die Game Engine mit den Hardware-Abstraktions-Schichten (z.B. DirectX und OpenGL).
	% end

	\section{Physics \& Collision Engine} % 9.9, 9.10, 9.11
		Physikalisch basierte Spiele\dots
		\begin{itemize}
			\item enthalten die Simulation grundlegender, physikalischer Eigenschaften als Hauptbestandteil.
			\item Bei Computerspielen ist dies vor allem die Newtonsche Mechanik.
			\item Oftmals werden neben starren Körpern auch deformierbare Körper (dynamische Körper) verwendet, zum Beispiel bei der Simulation von Kleidung.
		\end{itemize}

		\paragraph{Physik Engine}
			\begin{itemize}
				\item Die Physik-Engine ist eine Sammlung von Algorithmen, welche physikalische Eigenschaften simulieren bzw. Tools zur Verfügung stellen, um mit diesen zu arbeiten.
				\item Grundlegend wird zwischen zwei arten von Physik Engines unterschieden:
					\begin{description}
						\item[Echtzeit] Einige Details werden vernachlässigt, um die Rechenzeit zu minimieren. \\ Der Fokus der Anwendung liegt hier besonders auf Computerspielen oder kleinen Simulationen.
						\item[Hohe Genauigkeit] Nahezu alle physikalischen Größen der realen Welt werden berücksichtigt, die Rechenzeit wird missachtet. \\ Der Fokus der Anwendung liegt hier auf der Forschung und Entwicklung neuer Systeme, bei denen die exakten Werte relevant sind.
					\end{description}
				\item Allerdings ist die Implementierung von vollwertigen Physik Engines in Spielen nicht immer vorteilhaft, da sie einen hohen Rechenaufwand produzieren. Allerdings steigt durch die Genauigkeit der Simulation die Qualität des Spiels.
				\item Folgende Kernelemente gehören in jede Physik Engine:
					\begin{itemize}
						\item Typen von Objekten und deren Bewegungsverhalten \\
							Objekte: Starrkörper, Partikelsysteme, deformierbare Körper, \dots \\
							Bewegungsverhalten: Integration von Differentialgleichungssystemen
						\item Kontaktmodellierung, -detektion und -behandlung; Erkennen von Ort, Kraft und/oder Impuls von Kollision zwischen ruhenden, verbundenden und kollidierenden Objekten.
					\end{itemize}
			\end{itemize}
		% end
	% end

	\section{Modellierung eines Objektes} % 9.12
		\begin{itemize}
			\item Punktmasse
			\item Masse mit Trägheitstensor (Beschreibung der räumlichen Masseverteilung des Objektes)
			\item Verbundene Partikel (starr oder elastisch)
		\end{itemize}
	% end

	\section{Kontake, Kollisionen, Kräfte und Impulse} % 9.13, 9.14
		\begin{itemize}
			\item Beispiel: Buch liegt auf einem Tisch
				\begin{itemize}
					\item Keine Geschwindigkeit, keine Bewegung
					\item Das Buch drückt mit immer der selben Kraft auf den Tisch.
				\end{itemize}
			\item Beispiel: Aufprallender Ball
				\begin{itemize}
					\item Dynamischer Rückstoß bei Aufprall auf dem Boden.
					\item Die Änderung der Ballgeschwindigkeit wird von der Aufprallenergie beeinflusst.
					\item Kollisionsbehandlung (Abprall) erfolgt instantan und nicht für eine sehr kurze Zeitdauer.
				\end{itemize}
			\item Die meisten Physik Engines behandeln entweder alles über \textit{Kräfte} oder alles über \textit{Impulse}.
				\begin{itemize}
					\item Kräfte-basierte Physik Engines sind hierbei näher an der realen Welt, der Berechnungsaufwand ist aber extrem groß.
					\item Impuls-basierte Physik Engines haben meist einen geringeren Berechnungsaufwand und ähnliches Objektverhalten wie Kräfte-basierte Engines.
				\end{itemize}
		\end{itemize}
	% end
% end

\chapter{Simulation autonomer Roboter} % 10, 10.2
	\begin{itemize}
		\item Roboter sind komplexe technische Systeme bestehend aus Aktuatoren, Sensoren, Recheneinheiten, sehr vielen Algorithmen, \dots.
		\item Sie treten in vielen Anwendungen und Erscheinungsformen auf (Roboterarme, mobile Roboter, selbstfahrende Autos, \dots).
		\item Die Simulation eines Roboters umfasst
			\begin{enumerate}
				\item Roboterbewegung,
				\item Robotersensoren und
				\item Interaktion des Roboters mit der Umgebung.
			\end{enumerate}
	\end{itemize}

	\section{Problemspezifikation} % 10.4
		Aufgaben und Anforderungen an die Simulation:
		\begin{itemize}
			\item Auslegung und Abschätzung von Hardware (Antriebe, Sensoren, \dots)
			\item Berechnung der optimalen Bewegungsabläufe
			\item Auslegung und Tests von Reglern
			\item Test der Steuerungssoftware von autonomen Robotern
			\item u.v.m.
			\item Je nach Aufgabe unterscheiden sich die Anforderungen an die Simulation drastisch.
			\item Da die Steuerungssoftware sehr komplex sein kann, ist es nötig, diese sehr gut zu testen.
			\item Durch die Zeit- und Kostenintensive Nutzung realer Roboter ist eine geeignete Robotersimulation notwendig.
		\end{itemize}
	% end
% end

\chapter{Beispiele aus der Forschung} % 11
	Dieser Abschnitt wird nicht in der Zusammenfassung behandelt und ist im Foliensatz nachzulesen.
% end
