\documentclass[a4paper, 11pt, accentcolor = tud3b]{tudreport}

% Core packages.
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
% Other packages.
\usepackage[linesnumbered, ruled]{algorithm2e}
\usepackage{enumitem}
\usepackage[mathcal]{euscript} % Get readable mathcal font.
\usepackage{hyperref}
\usepackage{listings}
\usepackage{mathtools}
%\usepackage[disable]{todonotes}
\usepackage{todonotes}
\usepackage[german = quotes]{csquotes}
\usepackage{tikz}
\usepackage{syntax}
\usepackage{pgfgantt}
\usepackage{prftree}
\usepackage{subcaption}
\usepackage{stmaryrd}
\usepackage{multicol}
\usepackage{float}
\usetikzlibrary{arrows.meta, shapes, backgrounds}

% Basic information.
\title{Modellierung, Spezifikation und Semantik}
\subtitle{Zusammenfassung \\ Fabian Damken}
\author{Fabian Damken}
\date{\today}

% Description-list styling.
\SetLabelAlign{parright}{\parbox[t]{\labelwidth}{\raggedleft#1}}
\setlist[description]{style = multiline, leftmargin = 4cm, align = parright}

\definecolor{gray}{rgb}{0.2, 0.2, 0.2}
\definecolor{lightred}{rgb}{1, 0.3, 0}
\definecolor{lightblue}{rgb}{0, 0.5, 1}
\definecolor{darkred}{rgb}{0.6, 0, 0}
\definecolor{darkgreen}{rgb}{0, 0.6, 0}
\definecolor{orange}{rgb}{1, 0.8, 0}

\tikzset{> = { Latex[length = 2mm] }}

% New commands.
\newcommand{\info}[1]{
	\begin{figure}[H]
		\centering
		\fbox{\parbox[c]{0.5\textwidth}{#1}}
	\end{figure}
}
\newcommand{\warning}[1]{
    \begin{figure}[H]
        \centering
        \fbox{\parbox[c]{0.5\textwidth}{\textbf{Warnung:} #1}}
    \end{figure}
}
\newcommand{\forwhich}{\ensuremath{{\,\vert\,}}}
\newcommand{\abs}[1]{\ensuremath{{\lvert #1 \rvert}}}
\newcommand{\parallelAsync}{\ensuremath{\,\lvert\vert\rvert\,}}
\newcommand{\qed}{{\hfill q.e.d.}}

\newcommand{\subsubparagraph}[1]{\hspace{1cm} \textbf{#1:}}

\newcommand{\definition}[2]{\subparagraph{Definition (#1)} #2}
\newcommand{\notation}[2]{\subparagraph{Notation (#1)} #2}
\newcommand{\theorem}[1]{\subparagraph{Theorem} #1}
\newcommand{\intuition}[1]{\subsubparagraph{Intuition} #1}

\begin{document}
    \maketitle
    \tableofcontents
    \listoftodos

    \chapter{Einführung}
	    \section{Modellierungsbeispiele}
		    Ein Modell ist, wie in den folgenden Beispielen deutlich zu erkennen ist, absichtlich nicht originalgetreu, und unterschiedliche Modelle heben unterschiedliche Aspekte der Realität hervor.

		    \paragraph{Liniennetzplan im Personennahverkehr}
			    \subparagraph{Hervorgehoben}
				    \begin{itemize}
				    	\item Linien
				    	\item Haltestellen
				    	\item Tarifzonen
				    \end{itemize}
			    % end

			    \subparagraph{Weggelassen}
				    \begin{itemize}
				    	\item Verbindungen außerhalb des abgebildeten Bereiches
				    	\item Andere Verkehrsmittel
				    	\item Geographische Gegebenheiten (z.B. Entfernungen, Höhenunterschiede, \dots)
				    \end{itemize}
			    % end
		    % end

		    \paragraph{Abfahrtsplan im Personennahverkehr}
			    \subparagraph{Hervorgehoben}
				    \begin{itemize}
					    \item Abfahrtszeiten
					    \item Nächste Haltestellen
					    \item Linie
					    \item Aktuelle Haltestelle
					    \item Richtung (Zielhaltestelle)
				    \end{itemize}
			    % end
			    
			    \subparagraph{Weggelassen}
				    \begin{itemize}
				    	\item Gegenrichtung
				    	\item Andere Haltestellen
				    	\item Andere Busse an der aktuellen Haltestelle
				    \end{itemize}
			    % end
		    % end
	    % end
	    
	    \section{Beziehung Realität \texorpdfstring{$ \leftrightarrow $}{/} Modell}
		    \begin{figure}[H]
		    	\centering
		    	\begin{tikzpicture}[nde/.style = { draw, minimum width = 3cm, minimum height = 1cm }]
			    	\node [nde, cloud, cloud puffs = 15.7, cloud ignores aspect] (reality) {Realität};
			    	\node [nde, right = 3.5 of reality] (model) {Modell};
			    	\node [nde, right = 3.5 of model] (property) {Eigenschaft};
			    	
			    	\coordinate [above left = 0.75 of model] (coordTL);
			    	\coordinate [above right = 0.75 of property] (coordTR);
			    	\coordinate [below right = 0.75 of property] (coordBR);
			    	\coordinate [below left = 0.75 of model] (coordBL);
			    	
			    	\draw [->] (reality) to node[label = above:{modellieren}] {} (model);
			    	\draw [->] (model) to node[label = above:{erfüllt}] {} (property);
			    	\draw [->] (model) to[bend left] node[label = below:{interpretiert}] {} (reality);
			    	
			    	\begin{scope}[on background layer]
				    	\draw [fill = gray!10] (coordTL) to (coordTR) to (coordBR) to (coordBL) to (coordTL);
			    	\end{scope}
		    	\end{tikzpicture}
		    	\caption{Beziehung Realität $ \leftrightarrow $ Modell}
		    \end{figure}
	    % end
	    
	    \section{Formale Modelle}
		    Erklärung formaler Modelle anhand eines Beispiels:

		    \begin{figure}[H]
		    	\centering
		    	\fbox{\parbox[c]{0.9\textwidth}{
			    	\enquote{Ein Mann steht mit einem Wolf, einer Ziege und einem Kohlkopf am linken Ufer eines Flusses, den er überqueren will. Er hat ein Boot, das gerade groß genug ist, ihn und ein weiteres Objekt zu transportieren, so dass er immer nur eines der drei mit sich hinübernehmen kann. Falls der Mann allerdings den Wolf mit der Ziege oder die Ziege mit dem Kohlkopf an einem Ufer zurücklässt, wird einer gefressen.} [Kastens, Kleine Büning: Modellierung, 2008]
		    	}}
		    \end{figure}
	    
		    \subsection{Modellierung}
			    \paragraph{\textit{Identifikation} relevanter Objekte im Szenario}
				    \begin{itemize}
				    	\item Mann, Wolf, Ziege, Kohlkopf
				    \end{itemize}
			    % end
			    
			    \paragraph{\textit{Modellierung} der Objekte durch eine Menge von Symbolen}
				    Symbolmenge:
				    \[ O = \{ m, w, z, k \} \]
			    % end
			    
			    \paragraph{\textit{Identifikation} relevanter Aspekte einer Situation im Szenario}
				    \begin{itemize}
				    	\item Welches Objekt befindet sich an welchem Ufer?
				    \end{itemize}
			    % end
			    
			    \paragraph{\textit{Modellierung} einer Situation durch ein Paar $ (L, R) $ von Mengen}
				    \begin{itemize}
				    	\item Die Menge $ L $ enthält genau die Symbole, welche Objekte modellieren, welche sich momentan am linken Ufer befinden.
				    	\item Die Menge $ R $ enthält genau die Symbole, welche Objekte modellieren, welche sich momentan am rechten Ufer befinden.
				    \end{itemize}
			    % end
			    
			    \paragraph{\textit{Identifikation} von Beschränkungen an möglichen Situationen}
				    \begin{itemize}
				    	\item Keines der Objekte kann sich an mehr als einem Ufer befinden
				    	\item Der Mann und der Wolf können nicht verschwinden
				    \end{itemize}
			    % end
			    
			    \paragraph{\textit{Modellierung} möglicher Zustände durch Menge von Paaren}
				    Zustandsmenge:
				    \[ Z \coloneqq \{ (L, R) \forwhich L \subseteq O \land R \subseteq O \land L \cap R = \emptyset \land \{ m, w \} \subseteq L \cup R \} \]
			    % end
			    
			    \paragraph{\textit{Identifikation} relevanter Aktionen im Szenario}
				    \begin{itemize}
				    	\item Transport von Objekten mit dem Boot zum anderen Ufer
				    \end{itemize}
			    % end
			    
			    \paragraph{\textit{Identifikation} von Beschränkungen an relevanten Aktionen}
				    \begin{itemize}
				    	\item Das Boot kann nicht ohne den Mann fahren
				    	\item Das Boot kann den Mann und maximal ein weiteres Objekt aufnehmen
				    \end{itemize}
			    % end
			    
			    \paragraph{\textit{Modellierung} relevanter Aktionen durch eine Menge von Termen}
				    Ereignismenge:
				    \[ E \coloneqq \{ \text{fahre}(T) \forwhich T \subseteq O \land m \in T \land \abs{T} \leq 2 \} \]
			    % end
			    
			    \paragraph{\textit{Identifikation} der Vorbedingungen der Aktionen}
				    \begin{itemize}
				    	\item Die durch $ \text{fahre}(T) $ modellierte Aktion ist zulässig, wenn alle Objekte in $ T $ an einem Ufer sind und nicht Wolf und Ziege oder Ziege und Kohlkopf zurückbleiben
				    \end{itemize}
			    % end
			    
			    \paragraph{\textit{Identifikation} von Nachbedingungen der Aktionen}
				    \begin{itemize}
				    	\item Nach dem Ereignis $ \text{fahre}(T) $ befinden sich die Objekte in $ T $ am anderen Ufer
				    \end{itemize}
			    % end
			    
			    \paragraph{\textit{Modellierung} der Effekte von Aktionen durch Zustandsübergänge}
				    Zustandsübergangsrelation $ \rightarrow\, \subseteq Z \times E \times Z $
				    \begin{align*}
					    \rightarrow\, \coloneqq \{ ((L, R), \text{fahre}(T), (L', R'))\forwhich &\, (T \subseteq L \land L' = L \setminus T \land R' = R \cup T \land \{ z, w \} \not\subseteq L' \land \{ z, k \} \not\subseteq L') \\
						    \lor &\, (T \subseteq R \land R' = R \setminus T \land L' = L \cup T \land \{ z, w \} \not\subseteq R' \land \{ z, k \} \not\subseteq R') \}
				    \end{align*}
				    
				    \subparagraph{Interpretation}
				    Der Zustand $ (L, R) $ resultiert durch das Ausführen der Aktion $ \text{fahre}(T) $ im Zustand $ (L', R') $.
				    
				    \notation{Zustandsübergang}{
				    	Schreibe $ (L, R) \xrightarrow{\text{fahre}(T)} (L', R') $ statt $ ((L, R), \text{fahre}(T), (L', R')) \in \,\rightarrow $
				    }
			    % end
		    % end
	    % end
    % end
    
    \chapter{Grundlagen}
	    \todo{Definiere $ \not\subseteq $ und $ \neq $.}
    
    	\section{Mengen}
		    \paragraph{Teilmenge und Gleichheit}
			    \definition{Teilmenge}{Eine Menge $ N $ ist eine Teilmenge einer Menge $ M $ ($ N \subseteq M $) gdw. für jedes $ a \in N $ auch $ a \in M $ gilt.}
				
				\definition{Gleichheit}{Zwei Mengen $ M $, $ N $ sind gleich ($ M = N $), gdw. $ M \subseteq N $ und $ N \subseteq M $ gelten.}
		    % end
		    
		    \paragraph{Kartesisches Produkt}
			    \definition{Kartesisches Produkt}{Das kartesische Produkt zweier Mengen $ M $, $ N $ ist die Menge aller Paare bestehend aus einem Element aus $ M $ als erstes Element und einem Element aus $ N $ als zweites Element, also $ M \times N \coloneqq \{ (x, y) \forwhich x \in M \land y \in N \} $.}
		    % end

		    \paragraph{Vereinigung, Schnitt und Differenz}
			    \definition{Vereinigung, Schnitt, Differenz}{
				    \begin{description}
				    	\item[Vereinigung] Die Vereinigung zweier Mengen $ M $, $ N $ ist $ M \cup N \coloneqq \{ x \forwhich x \in M \lor x \in N \} $.
				    	\item[Schnitt] Der Schnitt zweier Mengen $ M $, $ N $ ist $ M \cap N \coloneqq \{ x \forwhich x \in M \land x \in N \} $. Gilt $ M \cap N = \emptyset $, so sind $ M $ und $ N $ disjunkt.
				    	\item[Differenz] Die Differenz zweier Mengen $ M $, $ M $ ist $ M \setminus N \coloneqq \{ x \forwhich x \in M \land x \not\in N \} $.
				    \end{description}
				}
		    % end
		    
		    \paragraph{Disjunkte Vereinigung}
			    \definition{Disjunkte Vereinigung}{
				    Sei $ I \coloneqq \{ 1, \cdots, n \} $ eine Indexmenge mit $ n > 1 $. Dann ist die disjunkte Vereinigung von Mengen $ M(1), \cdots, W(n) $ wie folgt definiert:
				    \begin{equation*}
					    W(1) \uplus \cdots \uplus W(n) \coloneqq \{ (i, w) \forwhich i \in I \land w \in W(i) \}
				    \end{equation*}
				}
		    % end
		    
		    \paragraph{Mehrstellige Operationen}
			    \definition{Kartesische Produkte}{
				    Das kartesische Produkt $ \times _ { i \in \{ 1, \cdots, n \} M(i) } $ einer endlichen Folge $ M(1), \cdots, M(n) $ von Mengen ist wie folgt induktiv definiert:
				    \begin{equation*}
					    \times _ { i \in \{ 1, \cdots, n \} } M(i) \coloneqq \begin{cases*}
						    \{ () \} & \text{falls $ n = 0 $} \\
						    M(1) & \text{falls $ n = 1 $} \\
						    (\times _ { j \in \{ 1, \cdots, n - 1 \} } M(j)) \times M(n) & \text{falls $ n > 1 $} \\
					    \end{cases*}
				    \end{equation*}
				    Die Elemente des kartesischen Produkts $ \times _ { i \in \{ 1, \cdots, n \} } M(i) $ heißen $ n $-Tupel.
				}
			    
			    \notation{Kartesische Produkte}{
				    \begin{itemize}
				    	\item Def.: $ M(1) \times \cdots \times M(n) \iff \times _ { i \in \{ 1, \cdots, n \} } M(i) $
				    	\item Def.: $ M ^ n \iff \times _ { i \in \{ 1, \cdots, n \} } M(i) $ falls $ M(i) = M $ für alle $ i \in \{ 1, \cdots, n \} $
				    \end{itemize}
				}
		    
			    \notation{Tupel}{
				    \begin{itemize}
				    	\item Def.: $ (m _ 1, m _ 2, \cdots, m _ n) \iff (((m _ 1, m _ 2), \cdots), m _ n) $
				    \end{itemize}
				}
			    
			    \definition{Vereinigung/Schnitt}{
				    Die Vereinigung $ \bigcup _ { i \in \{ 1, \cdots, n \} } M(i) $ und der Schnitt $ \bigcap _ { i \in \{ 1, \cdots, n \} } M(i) $ einer nichtleeren, endlichen Folge $ M(1), \cdots, M(n) $ von Mengen ist induktiv definiert:
				    \begin{align*}
					    \bigcup _ { i \in \{ 1, \cdots n \} } M(i) &\coloneqq \begin{cases*}
						    \emptyset & \text{falls $ n = 0 $} \\
						    M(1) & \text{falls $ n = 1 $} \\
						    (\bigcup _ { j \in \{ 1, \cdots, n - 1 \} } M(j)) \cup M(n) & \text{falls $ n > 1 $} \\
					    \end{cases*} \\
					    \bigcap _ { i \in \{ 1, \cdots n \} } &\coloneqq \begin{cases*}
						    M(1) & \text{falls $ n = 1 $} \\
						    (\bigcap _ { j \in \{ 1, \cdots, n - 1 \} } M(j)) \cap M(n) & \text{falls n > 1} \\
					    \end{cases*} \\
				    \end{align*}
				}
			    
			    \notation{Vereinigung/Schnitt}{
				    \begin{itemize}
				    	\item Def.: $ M(1) \cup \cdots \cup M(n) \iff \bigcup _ { i \in \{ 1, \cdots, n \} } M(i) $
				    	\item Def.: $ M(1) \cap \cdots \cap M(n) \iff \bigcap _ { i \in \{ 1, \cdots, n \} } M(i) $
				    \end{itemize}
				}
		    % end
		    
		    \paragraph{Potenzmengen}
			    \definition{Protenzmengen}{Die Potenzmenge einer Menge $ M $ ist die Menge aller Teilmengen von $ M $, also $ \mathcal{P}(M) \coloneqq \{ N \forwhich N \subseteq M \} $.}
		    % end
		    
		    \paragraph{Indexmengen}
			    \subparagraph{Beschreibung}
			    Indexmengen können verwendet werden, wenn Elemente einer Menge vervielfacht werden sollen.
			    
			    \subparagraph{Beispiel}
			    In einem Doppelkopfspiel repräsentiert die unterspezifzierte Menge \textit{SPIELSET} alle möglichen Kartentypen und die Menge $ \textit{INDEX} \coloneqq \{ 1, 2 \} $ eine Indexmenge. Dann modelliert die Menge $ \textit{KARTEN} \coloneqq \textit{SPIELSET} \times \textit{INDEX} $ die Menge aller Karten, wobei jeder Kartentyp zweimal vorhanden ist. Bspw. modelliert $ (\text{König}, 2) $ den zweiten König im Spiel.
			    
			    \notation{Indexmengen}{
				    \begin{itemize}
				    	\item $ T _ i \in \textit{KARTEN} \iff (T, i) \in \textit{KARTEN}, T \in \textit{SPIELSET}, i \in \textit{INDEX} $
				    \end{itemize}
				}
		    % end
		    
		    \paragraph{Kardinalität}
			    \definition{Kardinalität}{Die Kardinalität $ \abs{M} $ einer endlichen Menge $ M $ ist die Anzahl ihrer Elemente.}
			    
			    \subparagraph{Beobachtungen}
			    \begin{itemize}
			    	\item $ \abs{M} \leq \abs{M \cup N} $, $ \abs{N} \leq \abs{M \cup N} $, $ \abs{M} + \abs{N} \geq \abs{M \cup N} $
			    	\item $ \abs{M} \geq \abs{M \cap N} $, $ \abs{N} \geq \abs{M \cap N} $
			    	\item $ \abs{M} - \abs{N} \leq \abs{M \setminus N} $, $ \abs{M} \geq \abs{M \setminus N} $
			    	\item $ \abs{M} \cdot \abs{N} = \abs{M \times N} $
			    	\item $ 2 ^ { \abs{M} } = \abs{\mathcal{P}(M)} $
			    	\item Unabhängig von der Kardinalität einer nichtleeren Menge $ M $ haben die Mengen $ M ^ + $ und $ M ^ * $ unendlich viele Elemente.
			    	\item $ (\abs{B} + 1) ^ \abs{D} = \abs{D \rightharpoonup B} $
			    \end{itemize}
		    % end
		    
		    \paragraph{Multimengen}
			    \definition{Multimengen}{Eine Multimenge über einer Menge $ M $ ist eine Funktion $ m : M \rightarrow \mathbb{N} _ 0 $.}
			    
			    \subparagraph{Verwendung}
			    Multimengen eignen sich, um Ressourcen zu modellieren (bspw. der Preis von etwas).
		    % end
		    
		    \paragraph{(Partiell) Geordnete Mengen}
			    \definition{(Partiell) Geordnete Mengen}{
				    Eine partiell geordnete Menge ist ein Paar $ (M, \leq) $, wobei
				    \begin{itemize}
				    	\item $ M $ eine Menge ist, die Trägermenge genannt wird, und
				    	\item $ \leq \subseteq M \times M $ eine partielle Ordnung ist.
				    \end{itemize}
				    Eine geordnete Menge ist eine partiell geordnete Menge $ (M, \leq) $, wobei $ \leq $ eine totale Ordnung ist.
				}
			    
			    \subparagraph{Visualisierung (Hasse-Diagramme)}
			    Partiell geordnete Mengen können durch Hasse-Diagramme als Graph visualisiert werden. Das Hasse-Diagramm für eine partiell geordnete Menge $ (M, \leq) $ zeichnet ergibt sich wie folgt:
			    \begin{itemize}
			    	\item Jedes $ m \in M $ ist ein Knoten.
			    	\item Wenn $ m _ 1 \leq m _ 2 $ für zwei Knoten $ m _ 1, m _ 2 \in M $ gilt, dann
				    	\begin{itemize}
				    		\item wird der Knoten $ m _ 2 $ oberhalb von $ m _ 1 $ gezeichnet und
				    		\item falls es kein $ m \in M $ mit $ m _ 1 \leq m, m \leq m _ 2, \lnot m \neq m _ 1 $ und $ m \neq m _ 2 $ gibt, dann werden $ m _ 1 $ und $ m _ 2 $ mit einer Kante verbunden.
				    	\end{itemize}
			    \end{itemize}
		    % end
		    
		    \paragraph{Obere/Untere Schranken}
			    \definition{Obere/Untere Schranken}{
				    Sei $ (M, \leq) $ eine geordnete Menge.
				    \begin{itemize}
				    	\item Eine Funktion $ \sqcup : M \times M \rightarrow M $ heißt \textit{Vereinigungsoperator} gdw. $ m _ 1 \sqcup m _ 2 $ die \textit{kleinste obere Schranke} für $ m _ 1, m _ 2 \in M $ ist, d.h.
					    	\begin{itemize}
					    		\item $ m _ 1 \leq (m _ 1 \sqcup m _ 2) $ und $ m _ 2 \leq (m _ 1 \sqcup m _ 2) $ und
					    		\item für alle $ m \in M $, wenn $ m _ 1 \leq m $ und $ m _ 2 \leq m $, dann $ (m _ 1 \sqcup m _ 2) \leq m $.
					    	\end{itemize}
					    \item Eine Funktion $ \sqcap : M \times M \rightarrow M $ heißt \textit{Schnittoperator} gdw. $ m _ 1 \sqcap m _ 2 $ die \textit{größte unter Schranke} für $ m _ 1, m _ 2 \in M $ ist, d.h.
						    \begin{itemize}
						    	\item $ (m _ 1 \sqcap m _ 2) \leq m _ 1 $ und $ (m _ 1 \sqcap m _ 2) \leq m _ 2 $ und
						    	\item für alle $ m \in M $, wenn $ m \leq m _ 1 $ und $ m \leq m _ 2 $, dann $ m  \leq (m _ 1 \sqcap m _ 2) $.
						    \end{itemize}
				    \end{itemize}
				}
		    % end
		    
		    \paragraph{Verbände}
			    \definition{Verbände}{
				    Ein Verband ist ein Tupel $ (M, \leq, \sqcup, \sqcap) $, sodass
				    \begin{itemize}
				    	\item $ (M, \leq) $ eine geordnete Menge ist,
				    	\item $ \sqcup $ ein Vereinigungsoperator auf $ (M, \leq) $ ist und
				    	\item $ \sqcup $ ein Schnittoperator auf $ (M, \leq) $ ist.
				    \end{itemize}
				}
		    % end
    	% end

    	\section{Relationen}
		    \paragraph{Relationen}
			    \definition{Relationen}{Eine Relation über $ M(1), \cdots, M(n) $ ist eine Menge $ R $ von $ n $-Tupeln aus dem Wertebereich $ M(1) \times \cdots \times M(n) $, d.h. $ R \in \mathcal{P}(M(1) \times \cdots \times M(n)) $.}
			    
				\notation{Relationen}{
				    \begin{itemize}
				    	\item Def.: $ R(s _ 1, \cdots, s _ n) \iff (s _ 1, \cdots, s _ n) \in R $
				    	\item Def.: $ s _ 1 R s _ 2 \iff R(s _ 1, s _ 2) $ falls die Relation zweistellig ist
				    \end{itemize}
				}
		    % end

		    \paragraph{Eigenschaften}
			    \definition{Relationseigenschaften}{
				    Eine zweistellige Relation $ R \subseteq M \times M $ heißt\dots
				    \begin{description}[leftmargin = 5cm]
				    	\item[reflexiv] $ \forall x \in M : xRx $
				    	\item[symmetrisch] $ \forall x, y \in M : xRy \implies yRx $
				    	\item[asymmetrisch] $ \forall x, y \in M : xRy \implies \lnot yRx $
				    	\item[antisymmetrisch] $ \forall x, y \in M : (xRy \land yRx) \implies x = y $
				    	\item[transitiv] $ \forall x, y, z \in M : (xRy \land yRz) \implies xRz $
				    	\item[alternativ] $ \forall x, y \in M : xRy \lor yRx $
				    	\item[Äquivalenzrelation] reflexiv $ \land $ symmetrisch $ \land $ transitiv
				    	\item[Quasiordnung] reflexiv $ \land $ transitiv
				    	\item[(partielle) Ordnung] reflexiv $ \land $ antisymmetrisch $ \land $ transitiv
				    	\item[totale/lineare Ordnung] reflexiv $ \land $ antisymmetrisch $ \land $ transitiv $ \land $ alternativ
				    \end{description}
				}
		    
			    \definition{Wohlfundiert}{Eine zweistellige Relation $ \prec \,\subseteq D \times D $ auf einer Menge $ D $ heißt wohlfundiert gdw. es keine unendlich absteigende Kette für $ \prec $ gibt.}
		    % end
		    
		    \paragraph{Transitive Hülle}
			    \definition{Transitive Hülle}{
				    Die transitive Hülle eine zweistelligen Relation $ R \subseteq D \times D $ auf einer Menge $ D $ ist die kleinste Relation $ R ^ * \subseteq D \times D $, sodass
				    \begin{itemize}
				    	\item $ \forall d _ 1, d _ 2 \in D : d _ 1 R d _ 2 \implies d _ 1 R ^ * d _ 2 $
				    	\item $ \forall d _ 1, d _ 2, d _ 3 \in D : d _ 1 R ^ * d _ 2 \land d _ 2 R ^ * d _ 3 \implies d _ 1 R ^ * d _ 3 $
				    \end{itemize}
				}
			    
			    \theorem{
				    Sei $ \prec \,\subseteq D \times D $ eine wohlfundierte Relation auf $ D $. Dann gilt:
				    \begin{itemize}
				    	\item $ \prec $ ist irreflexiv, d.h. $ \forall d \in D : \lnot d R d $ und
				    	\item $ \prec ^ * $ ist eine wohlfundierte Relation.
				    \end{itemize}
				}
		    % end
		    
		    \paragraph{Prädikate}
			    \definition{Prädikate}{Ein Prädikat über einer Menge $ M $ ist eine Funktion $ p : M \rightarrow \mathbb{B} $.}
			    
			    \subparagraph{Beobachtung}
			    \begin{itemize}
			    	\item Die \textit{charakteristische Funktion} einer Teilmenge $ K \subseteq M $ ist das folgende Prädikat über $ M $:
				    	\begin{equation*}
					    	\mathcal{X}(m) \coloneqq \begin{cases*}
						    	w & \text{falls $ m \in K $} \\
						    	f & \text{falls $ m \not\in K $} \\
					    	\end{cases*}
				    	\end{equation*}
				    \item Ein Prädikat $ p : M \rightarrow \mathbb{B} $ induziert zwei Mengen:
					    \begin{align*}
						    W _ p &\coloneqq \{ m \in M \forwhich p(m) = \mathfrak{w} \} \\
						    F _ p &\coloneqq \{ m \in M \forwhich p(m) = \mathfrak{f} \} \\
					    \end{align*}
			    \end{itemize}
		    % end
    	% end

    	\section{Funktionen}
		    \paragraph{Funktionen}
			    \definition{Funktion}{
				    Eine Funktion $ f $ von $ D $ nach $ B $ ist eine Relation über $ D \times B $, wobei es für jedes $ d \in D $ höchstens ein $ b \in B $ mit $ (d, b) \in f $ geben darf. Die Menge $ D $ heißt \textit{Definitionsbereich} von $ f $, die Menge $ B $ heißt \textit{Bildbereich} von $ f $. \\
				    Die \textit{Menge aller Funktionen} von $ D $ nach $ B $ wird mit $ D \rightharpoonup B $ bezeichnet.
				}
			    
			    \notation{Funktionen}{
				    \begin{itemize}
				    	\item $ f(d) = b \iff (d, b) \in f $
				    	\item $ f(d) \uparrow \iff $ es gibt kein $ b \in B $ sodass $ (d, b) \in f $
				    	\item $ f : D \rightharpoonup B \iff f \in D \rightharpoonup B $
				    	\item $ f : D \rightarrow B \iff f \in D \rightarrow B $
				    \end{itemize}
				}
		    
		    \paragraph{Eigenschaften}
			    \definition{Totale Funktion}{
				    Eine Funktion $ f $ heißt totale Funktion gdw. es für jedes $ d \in D $ ein $ b \in B $ gibt, sodass $ (d, b) \in f $ gilt. \\
				    Die \textit{Menge aller totalen Funktionen} von $ D $ nach $ B $ wird mit $ D \rightarrow B $ bezeichnet.
				}
				
				\definition{Indempotente Funktionen}{
					Sei $ M $ eine Menge.
					
					Eine Funktion $ f : \mathcal{P}(M) \rightarrow \mathcal{P}(M) $ heißt idempotent gdw. $ \forall Q \subseteq M : (f(Q) = f(f(Q)) $.
				}
				
				\definition{Monotone Funktionen}{
					Sei $ M $ eine Menge.
					
					Eine Funktion $ f : \mathcal{P}(M) \rightarrow \mathcal{P}(M) $ heißt monoton gdw. $ \forall Q, Q' \subseteq M : (Q \subseteq Q' \implies f(Q) \subseteq f(Q')) $ gilt.
				}
				
				\definition{Extensive Funktionen}{
					Sei $ M $ eine Menge.
					
					Eine Funktion $ f : \mathcal{P}({M}) \rightarrow \mathcal{P}({M}) $ heißt extensiv gdw. $ \forall Q \subseteq M : (Q \subseteq f(Q)) $ gilt.
				}
		    % end

		    \paragraph{Hüllenoperator}
				\definition{Hüllenoperator}{
					Sei $ M $ eine Menge.
					
					Eine Funktion $ f : \mathcal{P}(M) \rightarrow \mathcal{P}(M) $ heißt Hüllenoperator gdw. folgende Bedingungen gelten:
					\begin{align*}
						& \forall Q \subseteq M : (Q \subseteq f(Q)) \tag{Extensivität} \\
						\land & \forall Q, Q' \subseteq M : (Q \subseteq Q' \implies f(Q) \subseteq f(Q')) \tag{Monotonie} \\
						\land & \forall Q \subseteq M : (f(Q) = f(f(Q))) \tag{Idempotenz} \\
					\end{align*}
				}
			% end
		    
		    \paragraph{Unendlich absteigende Ketten}
			    \definition{Unendlich absteigende Ketten}{
				    Sei $ \prec \,\subseteq D \times D $ eine binäre Relation auf einer Menge $ D $. \\
				    Eine unendliche Folge $ f : \mathbb{N} \rightarrow D $ heißt unendlich absteigende Kette für $ \prec $ gdw. $ \forall i \in \mathbb{N} : f(i + 1) \prec f(i) $.
				}
		    % end
    	% end

    	\section{Folgen}
		    \paragraph{Endliche Folgen}
			    \definition{Endliche Folgen}{Die Menge aller nichtleeren, endlichen Folgen über einer Menge $ M $ ist die Menge $ M ^ + \coloneqq \bigcup _ { i \in \mathbb{N} } M ^ i $.}
			    
			    \definition{Menge aller endlichen Folgen}{Die Menge aller endlichen Folgen über einer Menge $ M $ ist die Menge $ M ^ * \coloneqq M ^ + \cup \{ () \} $.}
			    
			    \notation{Endliche Folgen}{
				    \begin{itemize}
				    	\item \enquote{$ ( $} markiert den Anfang einer Folge.
				    	\item \enquote{$ ) $} markiert das Ende einer Folge.
				    	\item \enquote{$ , $} trennt einzelne Elemente in der Folge voneinander.
				    \end{itemize}
				}
		    % end
		    
		    \paragraph{Unendliche Folgen}
			    \definition{Unendliche Folgen}{Die Menge aller unendlichen Folgen über $ M $ ist die Menge $ M ^ \infty \coloneqq \mathbb{N} \rightarrow M $.}
		    % end
    	% end

	    \section{Konzepte zur Modellierung}
		    \paragraph{Symbole}
			    \definition{Symbole}{Symbole sind beliebige Zeichenketten, welche verwendet werden, um Objekte, Subjekte o.ä. aus der echten Welt zu repräsentieren. Beispielsweise kann \textit{Lautsprecher} definiert werden als Symbol, welches einen Lautsprecher darstellt.}
			    
			    \warning{Symbole müssen immer explizit definiert werden. Implizite Definitionen über den Namen des Symbols sind nicht zulässig.}
		    % end
		    
		    \paragraph{Wertebereiche}
			    \definition{Wertebereiche}{Ein Wertebereich ist eine Menge von Werten, welche im Sinne des Modells als gleichartig angesehen werden. Wird ein Wert aus dem Wertebereich $ W $ gefordert, kann jedes Element aus $ W $ verwendet werden.}
			    
			    \subparagraph{Verwendung}
			    Wertebereiche werden zur Strukturierung von Symbolmengen genutzt. Symbole werden hierfür als Werte betrachtet.
			    
			    \subparagraph{Angabemöglichkeiten von Wertebereichen}
			    \begin{itemize}
			    	\item Extensional (Aufzählung aller Elemente), z.B.: $ \{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F \} $
			    	\item Intensional (Deklarative Bedingung), z.B.: $ \{ \alpha \in \mathbb{N} \forwhich \alpha \text{ ist Prim} \} $
			    	\item Induktive Definition einer Familie von Mengen $ (M(i)) _ { i \in \mathbb{N} } $, z.B.:
				    	\begin{align*}
					    	M(1) &\coloneqq \{ 1 \} \\
					    	M(i) &\coloneqq \begin{cases*}
						    	\{ k \in \mathbb{N} \forwhich k \in M(i - 1) \lor k = i \} & \text{falls $ i $ eine Quadratzahl ist} \\
						    	\{ k \in \mathbb{N} \forwhich k \in M(i - 1) \} & \text{falls $ i $ keine Quadratzahl ist} \\
					    	\end{cases*} \\
				    	\end{align*}
			    \end{itemize}
			    
			    \notation{Wertebereiche}{$ \mathbb{N} $ ist die Menge der natürlichen Zahlen \textit{ohne Null} und $ \mathbb{N} _ 0 \coloneqq \mathbb{N} \cup \{ 0 \} $ die Menge der natürlichen Zahlen \textit{mit Null}.}
			    
			    \warning{Nicht jede intensionale Definition einer Menge führt zu einer Menge. Die Menge muss wohldefiniert sein. Beispiel: $ M \coloneqq \{ x \forwhich x \not\in M \} $ \\ Eine Menge ist immer wohldefiniert, wenn in der Bedingung nur bereits definierte Begriffe genutzt werden.}
		    % end
		    
		    \paragraph{Unterspezifizierte Wertebereiche}
			    Ein Wertebereich ist unterspezifiziert, wenn die genauen Elemente nicht angegeben werden. Beispielsweise kann ein Wertebereich \textit{LIEDER} definiert werden, welche alle Lieder enthält, die genauen Elemente werden aber nicht gelistet
		    % end
		    
		    \paragraph{Konvention}
			    Innerhalb einer Modellierung können Konventionen/Vereinfachungen eingeführt werden.
			    
			    Beispiel: Im folgenden wird anstatt \enquote{die durch das Symbol $ v $ modellierte Person} verkürzend \enquote{die Person $ v $} verwendet.
		    % end
	    % end
	    
	    \section{Aussagen- und Prädikatenlogik}
		    Siehe APL Zusammenfassung (\url{https://www.dmken.com/redmine/documents/6}).
		    
		    \subsection{Präzedenzenordnung}
				Die Präzedenzenordnung in absteigender Reihenfolge ist ($ \land $, $ \lor $ und $ \implies $ sind linksassoziativ):
				\begin{enumerate}
					\item $ \lnot $
					\item $ \land $
					\item $ \lor $
					\item $ \implies $, $ \iff $
					\item $ \forall $, $ \exists $
				\end{enumerate}
		    % end
	    % end
	    
	    \section{Formale Sprachen}
		    Siehe AFE Zusammenfassung (\url{https://www.dmken.com/redmine/documents/7}).
		    
		    \subsection{Definitionen}
			    \paragraph{Konkatenation}
				    \definition{Wort-Konkatenation}{Die Konkatenation zweier Wörter $ u = (a _ 1, \cdots, a _ n) $ und $ v = (b _ 1, \cdots, b _ m) $ ist das Wort $ u \circ v = (a _ 1, \cdots, a _ n, b _ 1, \cdots, b _ m) $.}
				    
					\definition{Sprach-Konkatenation}{Die Konkatenation zweier Sprachen $ L _ 1 $ und $ L _ 2 $ ist die Sprache $ L _ 1 \circ L _ 2 = \{ v \circ w \forwhich v \in L _ 1 \land w \in L _ 2 \} $.}
				    
				    \definition{$ i $-Fache Sprach-Konkatenation}{
					    \begin{align*}
						    L ^ 1 &= L \\
						    L ^ { i + 1 } &= \{ v \circ w \forwhich v \in L \land w \in L ^ i \} \\
					    \end{align*}
					}
				% end
		    % end
	    % end
    % end
    
    \chapter{Modellierung}
	    \section{Vorgehen}
		    \begin{enumerate}
		    	\item Identifikation relevanter Dinge
		    	\item Modellierung der relevanten Dinge durch Symbole
		    	\item Strukturierung der Symbolmengen durch Wertebereiche
		    	\item Modellierung von Beziehungen durch Relationen
		    	\item Modellierung von Eigenschaften durch Funktionen
		    	\item Modellierung der Anforderungen durch Relationen
		    \end{enumerate}
	    % end
	    
	    \section{Angemessenheit}
		    Ein (formales) Modell ist angemessen, wenn Beobachtungen, welche am Modell gemacht werden, auch in der Realität gültig sind. Hierzu müssen alle relevanten Aspekte der Realität im Modell wiedergegeben sein.
		    
		    Die Angemessenheit eines Modells hängt auch davon ab,
		    \begin{itemize}
		    	\item wie eine Beobachtung interpretiert wird und
		    	\item welche Fragestellungen von Interesse sind.
		    \end{itemize}
		    
		    Die Argumentation, ob ein Modell angemessen ist, stellt die Verbindung zwischen Modell und Realität her und kann daher nur informell geschehen.
	    % end
    % end
    
    \chapter{Programmiersprachen}
	    \section{IMP Syntax/Semantik}
		    \paragraph{IMP}
			    \begin{itemize}
			    	\item Einfache imperative Programmiersprache
			    	\item Sequentielle Sprache mit Verzweigungen und Schleifen
			    \end{itemize}
			% end
		    
		    \paragraph{Wertebereiche}
			    \begin{description}[leftmargin = 2cm]
			    	\item[\textit{Num}] Ganzen Zahlen
				    	\begin{description}[leftmargin = 3cm]
				    		\item[Definition:] $ \textit{Num} \coloneqq \mathbb{N} _ 0 \cup \{ -n \forwhich n \in \mathbb{N} \} $
				    		\item[Intuition:] Symbole, welche ganze Zahlen repräsentieren
				    	\end{description}
			    	\item[\textit{Bool}] Wahrheitswerte
				    	\begin{description}[leftmargin = 3cm]
				    		\item[Definition:] $ \textit{Bool} \coloneqq \{ \texttt{true}, \texttt{false} \} $
				    		\item[Intuition:] Symbole, welche Wahrheitswerte repräsentieren
				    	\end{description}
			    	\item[\textit{Var}] Programmvariablen
				    	\begin{description}[leftmargin = 3cm]
				    		\item[Definition:] Unterspezifiziert
				    		\item[Intuition:] Programmvariablen
				    		\item[Konvention:] $ m $, $ n $ bezeichnen Elemente aus \textit{Num}, $ t $ bezeichnet Element aus \textit{Bool}, $ X $, $ Y $ bezeichnen Elemente aus \textit{Var}
				    	\end{description}
			    	\item[\textit{AExp}] Arithmetischen Ausdrücke
				    	\begin{description}[leftmargin = 3cm]
				    		\item[Definition:]
					    		\begin{grammar}
						    		<a> ::= $ n $
							    		\alt $ X $
							    		\alt (<a> $ \oplus $ <a>)
							    		\alt (<a> $ \ominus $ <a>)
							    		\alt (<a>  $ \odot $ <a>)
					    		\end{grammar}
				    		\item[Intuition:] Arithmetische Ausdrücke
				    	\end{description}
			    	\item[\textit{BExp}] Boolesche Ausdrücke
				    	\begin{description}[leftmargin = 3cm]
				    		\item[Definition:]
					    		\begin{grammar}
						    		<b> ::= \texttt{true}
							    		\alt \texttt{false}
							    		\alt (<a> \texttt{eq} <a>)
							    		\alt (<a> \texttt{leq} <a>)
							    		\alt \texttt{not} <b>
							    		\alt (<b> \texttt{and} <b>)
							    		\alt (<b> \texttt{or} <b>)
					    		\end{grammar}
				    		\item[Intuition:] Boolesche Ausdrücke
				    	\end{description}
			    	\item[\textit{Com}] Kommandos
				    	\begin{description}[leftmargin = 3cm]
				    		\item[Definition:]
					    		\begin{grammar}
							    	<c> ::= \texttt{skip}
								    	\alt $ X \texttt {:=} $ <a>
								    	\alt <c> \texttt{;} <c>
								    	\alt \texttt{if} <b> \texttt{then} <c> \texttt{else} <c> \texttt{fi}
								    	\alt \texttt{while} <b> \texttt{do} <c> \texttt{od}
					    		\end{grammar}
				    		\item[Intuition:] Kommandos von IMP
				    		\item[Konvention:] \enquote{Programm} wird synonym für \enquote{Kommando} verwendet
				    	\end{description}
			    \end{description}
			% end
	    % end
	    
	    \section{Syntaktische Korrektheit/Gleichheit}
		    \definition{Korrektheit}{Ein Wort $ c $ ist ein syntaktisch korrektes Programm, gdw. es in der Grammatik von \textit{Com} ableitbar ist.}
		    
			\definition{Gleichheit}{Zwei Programme $ c _ 1 $ und $ c _ 2 $ sind syntaktisch gleich, gdw. die die gleichen Ableitungen haben (so sind $ 3 \oplus 5 $ und $ 5 \oplus 3 $ nicht syntaktisch gleich).}
	    % end
	    
	    \section{Zustände}
		    \definition{Zustand}{Ein Zustand eines Programms ist eine Funktion $ \sigma : \textit{Var} \rightarrow \textit{Num} $. Die Menge aller Zustände wird mit $ \Sigma $ bezeichnet.}
		    
		    \intuition{Ein Zustand ordnet jeder Programmvariablen (aus \textit{Var}) einen Wert (aus \textit{Num}) zu.}
		    
		    \definition{Wertsetzungen}{Sei $ \sigma \in \Sigma $ ein Zustand. Dann ist $ \sigma[X \backslash n] $ der Zustand, der der Programmvariablen $ X $ den Wert $ n $ und jeder anderen Variablen $ Y $ den Wert $ \sigma(Y) $ zuweist.}
	    % end
	    
	    \section{Substitutionen}
		    \definition{Substitution}{Eine Substitution ist eine Funktion, welche eine endliche Menge von Metavariablen als Definitionsbereich hat und jedem Element aus dieser Menge genau ein Element aus dem Bildbereich zuordnet.}
		    
		    \definition{Grundsubstitution}{Der Bildbereich keine Metavariablen.}
		    
		    \notation{Substitution}{$ [X _ 1 \mapsto t _ 1, \cdots, X _ n \mapsto t _ n] $ besagt, dass der Definitionsbereich $ \{ X _ 1, \cdots, X _ n \} $ auf den Bildbereich $ \{ t _ 1, \cdots, t _ n \} $ abgebildet wird ($ X _ 1 $ auf $ t _ 1 $, $ X _ 2 $ auf $ t _ 2 $ usw.).}
		    
		    \definition{Anwendung}{Die Anwendung einer Substitution $ \eta $ auf einen Ausdruck $ \alpha $ (geschrieben $ \alpha\eta $) ergibt einen Ausdruck $ \beta $, indem jedes (freies) Auftreten von $ X $ durch $ \eta(X) $ ersetzt.}
		    
		    \subparagraph{Beispiel}
		    \begin{equation*}
			    ((2 \oplus 1) \odot (Y \ominus X))[X \mapsto (1 \oplus Z)] = ((2 \oplus 1) \odot (Y \ominus (1 \oplus Z)))
		    \end{equation*}
	    % end
	    
	    \section{Auswertungssemantik}
		    \subsection{Urteil}
			    \subsubsection{Definitionen}
				    \definition{Urteil}{Ein Urteil ist ein Schema für Ausdrücke, welcher Metavariablen als atomare Ausdrücke enthalten kann. Ein Urteil formalisiert einen gegebenen intuitiven Sachverhalt.}
				    
				    \definition{Urteil-Instanz}{Ein Ausdruck $ \xi $ ist eine Instanz des Urteils $ \zeta $ gdw. $ \xi $ und $ \zeta $ gleich sind oder $ \zeta $ durch ersetzen der Metavariablen zu $ \xi $ umgeformt werden kann.}
				    
				    \definition{Urteil-Grundinstanz}{Eine Instanz $ \xi $ des Urteils $ \zeta $ ist eine Grundinstanz, wenn $ \xi $ keine Metavariablen enthält.}
				% end
		    
			    \subsubsection{Urteile}
				    \definition{Urteil für \textit{AExp}}{
				    	Das Urteil $ \langle a, \sigma \rangle \Downarrow n $ besagt, dass
				    	\begin{itemize}
				    		\item ein arithmetischer Ausdruck $ a \in \textit{AExp} $
				    		\item in einem Zustand $ \sigma \in \Sigma $
				    		\item zu einem Wert $ n \in \textit{Num} $ auswertet.
				    	\end{itemize}
					}
					
					\definition{Urteil für \textit{BExp}}{
						Das Urteil $ \langle b, \sigma \rangle \Downarrow t $ besagt, dass
						\begin{itemize}
							\item ein boolescher Ausdruck $ b \in \textit{BExp} $
							\item in einem Zustand $ \sigma \in \Sigma $
							\item zu einem Wert $ t \in \textit{Bool} $ auswertet.
						\end{itemize}
					}
					
					\definition{Urteil für \textit{Com}}{
						Das Urteil $ \langle c, \sigma \rangle \rightarrow \sigma' $ besagt, dass
						\begin{itemize}
							\item ein Kommando $ c \in \textit{Com} $
							\item in einem Zustand $ \sigma \in \Sigma $
							\item zu einem Zustand $ \sigma' \in \Sigma $ auswertet.
						\end{itemize}
					}
			    % end
		    % end
		    
		    \subsection{Kalkül}
			    \notation{Kalkülregeln}{
			    	\begin{equation*}
				    	\prftree[l, r]
					    	{ $ \Phi _ 1, \cdots, \Phi _ m $ }
					    	{ r-name }
					    	{ \zeta _ 1, \cdots, \zeta _ n }
					    	{ \zeta }
			    	\end{equation*}
			    	
			    	\begin{description}
			    		\item[r-name] Name der Regel
			    		\item[$ \zeta _ 1, \cdots, \zeta _ n $] Prämissen; endliche Liste von Instanzen von Urteilen, welche leer sein kann
			    		\item[$ \zeta $] Konklusion; instantiiertes Urteil
			    		\item[$ \Phi _ 1, \cdots, \Phi _ m $] Seitenbedingungen; endliche Liste von Bedingungen, welche leer sein kann
			    	\end{description}
			    }
			    
			    \subsubsection{Instanziierung}
				    \definition{Kalkülregel-Instanz}{
					    Eine Regel
					    \begin{equation*}
						    \prftree[l]
							    { r-name }
							    { \xi _ 1, \cdots, \xi _ n }
							    { \xi }
					    \end{equation*}
					    ist die Instanz (bzw. Grundinstanz) einer Kalkülregel
					    \begin{equation*}
						    \prftree[l, r]
							    { $ \Phi _ 1, \cdots, \Phi _ n $ }
							    { r-name }
							    { \zeta _ 1, \cdots, \zeta _ n }
							    { \zeta }
					    \end{equation*}
					    wenn es eine Substitution (bzw. Grundsubstitution) $ \eta $ gibt, sodass $ \xi = \zeta\eta $ und $ \xi _ 1 = \zeta _ 1 \eta, \cdots, \xi _ n = \zeta _ n \eta $ gilt und die Instanzen $ \Phi _ 1 \eta, \cdots, \Phi _ n \eta $ erfüllt sind.
				    }
			    % end
		    % end
		    
		    \subsection{Kalkülregeln}
			    \subsubsection{Kalkül für \textit{AExp}: $ \mathcal{A} $}
					Dieser Kalkül in \textit{AExp} wird zur Herleitung von Urteilen der Form $ \langle a, \sigma \rangle \Downarrow n $ genutzt und $ \mathcal{A} $ genannt.

				    \begin{multicols}{2}
					    \begin{equation*}
						    \prftree[l, r]
							    { $ n = n _ 1 + n _ 2 $ }
							    { r$ \oplus $ }
							    { \langle a _ 1, \sigma \rangle \Downarrow n _ 1 }
							    { \langle a _ 2, \sigma \rangle \Downarrow n _ 2 }
							    { \langle (a _ 1 \oplus a _ 2), \sigma \rangle \Downarrow n }
					    \end{equation*}
					    \begin{equation*}
							\prftree[l, r]
								{ $ n = n _ 1 - n _ 2 $ }
								{ r$ \ominus $ }
								{ \langle a _ 1, \sigma \rangle \Downarrow n _ 1 }
								{ \langle a _ 1, \sigma \rangle \Downarrow n _ 2 }
								{ \langle (a _ 1 \ominus a _ 2), \sigma \rangle \Downarrow n }
					    \end{equation*}
					    \begin{equation*}
						    \prftree[l, r]
							    { $ n = n _ 1 \cdot n _ 2 $ }
							    { r$ \odot $ }
							    { \langle a _ 1, \sigma \rangle \Downarrow n _ 1 }
							    { \langle a _ 2, \sigma \rangle \Downarrow n _ 2 }
							    { \langle (a _ 1 \cdot a _ 2), \sigma \rangle \Downarrow n }
					    \end{equation*}
					    \begin{equation*}
						    \prftree[l, r]
							    { $ n  = \sigma(X) $ }
							    { rVar }
							    { \langle X, \sigma \rangle \Downarrow n }
					    \end{equation*}
					    \begin{equation*}
						    \prftree[l]
							    { rNum }
							    { \langle n, \sigma \rangle \Downarrow n }
					    \end{equation*}
				    \end{multicols}
			    % end
			    
			    \subsubsection{Kalkül für \textit{BExp}: $ \mathcal{B} $}
				    Dieser Kalkül in \textit{BExp} wird zur Herleitung von Urteilen der Form $ \langle b, \sigma \rangle \Downarrow t $ genutzt und $ \mathcal{B} $ genannt.
			    
				    \begin{multicols}{2}
					    \begin{equation*}
						    \prftree[l]
							    { rtrue }
							    { \langle \texttt{true}, \sigma \rangle \Downarrow \texttt{true} }
					    \end{equation*}
					    \begin{equation*}
						    \prftree[l]
							    { rfalse }
							    { \langle \texttt{false}, \sigma \rangle \Downarrow \texttt{false} }
					    \end{equation*}
					    \begin{equation*}
						    \prftree[l, r]
							    { $ n _ 1 = n _ 2 $ }
							    { reqt }
							    { \langle a _ 1, \sigma \rangle \Downarrow n _ 1 }
							    { \langle a _ 2, \sigma \rangle \Downarrow n _ 2 }
							    { \langle (a _ 1 \texttt{eq} a _ 2), \sigma \rangle \Downarrow \texttt{true} }
					    \end{equation*}
					    \begin{equation*}
						    \prftree[l, r]
							    { $ n _ 1 \neq n _ 2 $ }
							    { reqf }
							    { \langle a _ 1, \sigma \rangle \Downarrow n _ 1 }
							    { \langle a _ 2, \sigma \rangle \Downarrow n _ 2 }
							    { \langle (a _ 1 \texttt{eq} a _ 2), \sigma \rangle \Downarrow \texttt{false} }
					    \end{equation*}
					    \begin{equation*}
						    \prftree[l, r]
							    { $ n _ 1 \leq n _ 2 $ }
							    { rleqt }
							    { \langle a _ 1, \sigma \rangle \Downarrow n _ 1 }
							    { \langle a _ 2, \sigma \rangle \Downarrow n _ 2 }
							    { \langle (a _ 1 \texttt{leq} a _ 2), \sigma \rangle \Downarrow \texttt{true} }
					    \end{equation*}
					    \begin{equation*}
						    \prftree[l, r]
							    { $ n _ 1 > n _ 2 $ }
							    { rleqf }
							    { \langle a _ 1, \sigma \rangle \Downarrow n _ 1 }
							    { \langle a _ 2, \sigma \rangle \Downarrow n _ 2 }
							    { \langle (a _ 1 \texttt{leq} a _ 2), \sigma \rangle \Downarrow \texttt{false} }
					    \end{equation*}
					    \begin{equation*}
						    \prftree[l]
							    { rnott }
							    { \langle b, \sigma \rangle \Downarrow \texttt{false} }
							    { \langle \texttt{not} b, \sigma \rangle \Downarrow \texttt{true} }
					    \end{equation*}
					    \begin{equation*}
						    \prftree[l]
							    { rnotf }
							    { \langle b, \sigma \rangle \Downarrow \texttt{true} }
							    { \langle \texttt{not} b, \sigma \rangle \Downarrow \texttt{false} }
					    \end{equation*}
					    \begin{equation*}
						    \prftree[l]
							    { randt }
							    { \langle b _ 1, \sigma \rangle \Downarrow \texttt{true} }
							    { \langle b _ 2, \sigma \rangle \Downarrow \texttt{true} }
							    { \langle (b _ 1 \texttt{and} b _ 2), \sigma \rangle \Downarrow \texttt{true} }
					    \end{equation*}
					    \begin{equation*}
						    \prftree[l]
							    { randf1 }
							    { \langle b _ 1, \sigma \rangle \Downarrow \texttt{false} }
							    { \langle (b _ 1 \texttt{and} b _ 2), \sigma \rangle \Downarrow \texttt{false} }
					    \end{equation*}
					    \begin{equation*}
						    \prftree[l]
							    { randf2 }
							    { \langle b _ 2, \sigma \rangle \Downarrow \texttt{false} }
							    { \langle (b _ 1 \texttt{and} b _ 2), \sigma \rangle \Downarrow \texttt{false} }
					    \end{equation*}
					    \begin{equation*}
						    \prftree[l]
							    { rort1 }
							    { \langle b _ 1, \sigma \rangle \Downarrow \texttt{true} }
							    { \langle (b _ 1 \texttt{or} b _ 2), \sigma \rangle \Downarrow \texttt{true} }
					    \end{equation*}
					    \begin{equation*}
						    \prftree[l]
							    { rort2 }
							    { \langle b _ 2, \sigma \rangle \Downarrow \texttt{true} }
							    { \langle (b _ 1 \texttt{or} b _ 2), \sigma \rangle \Downarrow \texttt{true} }
					    \end{equation*}
					    \begin{equation*}
						    \prftree[l]
							    { rorf }
							    { \langle b _ 1, \sigma \rangle \Downarrow \texttt{false} }
							    { \langle b _ 2, \sigma \rangle \Downarrow \texttt{false} }
							    { \langle (b _ 1 \texttt{or} b _ 2), \sigma \rangle \Downarrow \texttt{false} }
					    \end{equation*}
				    \end{multicols}
			    % end
			    
			    \subsubsection{Kalkül für \textit{Com}: $ \mathcal{C} $}
				    Dieser Kalkül in \textit{Com} wird zur Herleitung von Urteilen der Form $ \langle c, \sigma \rangle \rightarrow \sigma' $ genutzt und $ \mathcal{C} $ genannt.
			    
				    \begin{multicols}{2}
				    	\begin{equation*}
					    	\prftree[l]
						    	{ rsk }
						    	{ \langle \texttt{skip}, \sigma \rangle \rightarrow \sigma }
				    	\end{equation*}
				    	\begin{equation*}
					    	\prftree[l, r]
						    	{ $ \sigma' = \sigma[X \backslash n] $ }
						    	{ r$ \coloneqq $ }
						    	{ \langle a, \sigma \rangle \Downarrow n }
						    	{ \langle X \coloneqq a, \sigma \rangle \rightarrow \sigma' }
				    	\end{equation*}
				    	\begin{equation*}
					    	\prftree[l]
						    	{ r; }
						    	{ \langle c _ 1, \sigma \rangle \rightarrow \sigma'' }
						    	{ \langle c _ 2, \sigma'' \rangle \rightarrow \sigma' }
						    	{ \langle c _ 1 ; c _ 2, \sigma \rangle \rightarrow \sigma' }
				    	\end{equation*}
				    	\begin{equation*}
						    \prftree[l]
							    { rift }
							    { \langle b, \sigma \rangle \Downarrow \texttt{true} }
							    { \langle c _ 1, \sigma \rangle \rightarrow \sigma' }
							    { \langle \texttt{if } b \texttt{ then } c _ 1 \texttt{ else } c _ 2 \texttt{ fi}, \sigma \rangle \rightarrow \sigma' }
				    	\end{equation*}
				    	\begin{equation*}
					    	\prftree[l]
						    	{ riff }
						    	{ \langle b, \sigma \rangle \Downarrow \texttt{false} }
						    	{ \langle c _ 2, \sigma \rangle \rightarrow \sigma' }
						    	{ \langle \texttt{if } b \texttt{ then } c _ 1 \texttt{ else } c _ 2 \texttt{ fi}, \sigma \rangle \rightarrow \sigma' }
				    	\end{equation*}
				    	\begin{equation*}
					    	\prftree[l]
						    	{ rwhf }
						    	{ \langle b, \sigma \rangle \Downarrow \texttt{false} }
						    	{ \langle \texttt{while } b \texttt{ do } c \texttt{ od}, \sigma \rangle \rightarrow \sigma }
				    	\end{equation*}
				    \end{multicols}
				    \vspace{-0.4cm}
				    \begin{equation*}
					    \prftree[l]
						    { rwht }
						    { \langle b, \sigma \rangle \Downarrow \texttt{true} }
						    { \langle c, \sigma \rangle \rightarrow \sigma'' }
						    { \langle \texttt{while } b \texttt{ do } c \texttt{ od}, \sigma'' \rangle \rightarrow \sigma' }
						    { \langle \texttt{while } b \texttt{ do } c \texttt{ od}, \sigma \rangle \rightarrow \sigma' }
				    \end{equation*}
			    % end
		    % end
		    
		    \subsection{Herleitbarkeit}
				\definition{Herleitbarkeit}{
					Eine Instanz $ \xi $ eines Urteils ist in einem Kalkül herleitbar gdw. eine der folgenden Bedingungen erfüllt ist:
					\begin{itemize}
						\item Es existiert eine Kalkülregel der Form
							\begin{equation*}
								\prftree[l, r]
									{ $ \Phi _ 1, \cdots, \Phi _ n $ }
									{ r-name }
									{ \zeta }
							\end{equation*}
							und eine Substitution $ \eta $, sodass $ \zeta\eta = \xi $ und $ \Phi _ 1 \eta, \cdots, \Phi _ n \eta $ erfüllt sind.
						\item Es existiert eine Kalkülregel der Form
							\begin{equation*}
								\prftree[l, r]
									{ $ \Phi _ 1, \cdots, \Phi _ n $ }
									{ r-name }
									{ \zeta _ 1, \cdots, \zeta _ n }
									{ \zeta }
							\end{equation*}
							und eine Substitution $ \eta $, sodass $ \zeta\eta = \xi $ und $ \Phi _ 1 \eta, \cdots, \Phi _ n \eta $ erfüllt sind und die Instanzen $ \zeta _ 1 \eta, \cdots, \zeta _ n \eta $ der Prämisse herleitbar sind.
					\end{itemize}
				}
		    % end
		    
		    \subsection{Semantische Äquivalenz}
			    \definition{Äquivalenz von booleschen Ausdrücken}{
				    Zwei boolesche Ausdrücke $ b _ 1, b _ 2 \in \textit{BExp} $ (die Metavariablen enthalten dürfen) sind zueinander semantisch äquivalent gdw. für alle Grundsubstitutionen $ \eta $, deren Definitionsbereich alle Metavariablen von $ b _ 1 $ und $ b _ 2 $ enthält, für alle Zustände $ \sigma \in \Sigma $ und für alle $ t \in \textit{Bool} $ gilt:
				    \begin{equation*}
					    \langle b _ 1 \eta, \sigma \rangle \Downarrow t \text{ herleitbar} \iff \langle b _ 2 \eta, \sigma \rangle \Downarrow t \text{ herleitbar}
				    \end{equation*}
			    }
			    
				\definition{Äquivalenz von arithmetischen Ausdrücken}{
					Zwei arithmetische Ausdrücke $ a _ 1, a _ 2 \in \textit{AExp} $ (die Metavariablen enthalten dürfen) sind zueinander semantisch äquivalent gdw. für alle Grundsubstitutionen $ \eta $, deren Definitionsbereich alle Metavariablen von $ b _ 1 $ und $ b _ 2 $ enthält, und für alle Zustände $ \sigma \in \Sigma $ und für alle $ n \in \textit{Num} $ gilt:
					\begin{equation*}
						\langle a _ 1 \eta, \sigma \rangle \Downarrow n \text{ herleitbar} \iff \langle a _ 2 \eta, \sigma \rangle \Downarrow n \text{ herleitbar}
					\end{equation*}
				}
				
				\definition{Äquivalenz von Kommandos}{
					Zwei Kommandos $ c _ 1, c _ 2 \in \textit{Com} $ (die Metavariablen enthalten dürfen) sind zueinander semantisch äquivalent gdw. für alle Grundsubstitutionen $ \eta $, deren Definitionsbereich alle Metavariablen von $ b _ 1 $ und $ b _ 2 $ enthält, für alle Zustände $ \sigma \in \Sigma $ und für alle $ \sigma' \in \Sigma $ gilt:
					\begin{equation*}
						\langle c _ 1 \eta, \sigma \rangle \rightarrow \sigma' \text{ herleitbar} \iff \langle c _ 2 \eta, \sigma \rangle \rightarrow \sigma' \text{ herleitbar}
					\end{equation*}
				}
				
				\notation{Äquivalenz von Programmen}{Seien $ c _ 1, c _ 2 \in \textit{Com} $. Dann sagt $ c _ 1 \sim c _ 2 $ aus, dass $ c _ 1 $ und $ c _ 2 $ zueinander äquivalent sind.}
		    % end
		    
		    \subsection{Termbeschreibungen}
			    \subsubsection{Regeln}
				    \definition{Regelterm}{
					    Ein Regelterm ist ein Ausdruck der Form $ \text{r-name}(\xi, (\xi _ 1, \cdots, \xi _ n)) $, wobei
					    \begin{description}[leftmargin = 3cm]
					    	\item[r-name] der Name der Regel,
					    	\item[$ \xi $] eine Grundinstanz des Konklusionsurteils ist und
					    	\item[$ (\xi _ 1, \cdots, \xi _ n) $] eine endliche Liste von Grundinstanzen von Prämissenurteilen ist, die auch leer sein kann.
					    \end{description}
					    
					    Somit sind Regelterme eine andere Schreibweise für Instanzen von Kalkülregeln.
					}
					
					\definition{Regeltermmenge}{
						Die durch eine Kalkülregel
						\begin{equation*}
							\prftree[l, r]
								{ $ \Phi _ 1, \cdots, \Phi _ m $ }
								{ r-name }
								{ \zeta _ 1, \cdots, \zeta _ n }
								{ \zeta }
						\end{equation*}
						repräsentierte Mengen an Regeltermen ist, für alle Grundsubstitutionen $ \eta $, definiert als
						\begin{align*}
							\text{RTerme}(\text{r-name}) & \coloneqq \{ \text{r-name}(\zeta\eta, (\zeta _ 1 \eta, \cdots, \zeta _ n \eta)) \\
								& \forwhich \zeta _ 1 \eta, \cdots, \zeta _ n \eta \text{ enthalten keine Metavariablen und } \Phi _ 1 \eta, \cdots, \Phi _ m \eta \text{ sind erfüllt} \} \\
						\end{align*}
					}
			    % end
			    
			    \subsubsection{Herleitungen}
				    \definition{Herleitungsterm}{
					    Sei $ \xi $ eine Instanz eines Urteils $ \zeta $. Die Herleitungen von $ \xi $ in einem Kalkül $ \mathcal{K} $ (kurz: $ K $-Herleitung von $ \xi $) sind folgendermaßen definiert:
					    
					    Eine $ \mathcal{K} $-Herleitung von $ \xi $ ist ein Term der Form $ \text{r-name}(\xi, (\mathcal{H} _ 1, \cdots, \mathcal{H} _ n)) $, wobei es in $ \mathcal{K} $ eine Regel der Form
					    \begin{equation*}
						    \prftree[l, r]
							    { $ \Phi _ 1, \cdots, \Phi _ m $ }
							    { r-name }
							    { \zeta _ 1, \cdots, \zeta _ n }
							    { \zeta }
					    \end{equation*}
					    und eine Substitution $ \eta $ gibt, sodass
					    \begin{itemize}
					    	\item $ \xi = \zeta\eta $ und
					    	\item $ \Phi _ 1 \eta, \cdots, \Phi _ m \eta $ erfüllt sind und
					    	\item $ (\mathcal{H} _ 1, \cdots, \mathcal{H} _ n) $ eine (möglicherweise leere) Liste von Herleitungen ist, sodass, für jedes $ i \in \{ 1, \cdots, n \} $, $ \mathcal{H} _ i $ eine Herleitung von $ \zeta _ i \eta $ ist.
					    \end{itemize}
				    }
				    
				    \definition{Herleitungsterm 2}{
				    	Seien $ \xi, \xi _ 1, \cdots, \xi _ k $ Instanzen von Urteilen $ \zeta, \zeta _ 1, \cdots, \zeta _ k $. Eine Herleitung von $ \xi $ aus $ \xi _ 1, \cdots, \xi _ k $ in einem Kalkül $ \mathcal{K} $ (kurz: $ \mathcal{K} $-Herleitung von $ \xi $ aus $ \xi _ 1, \cdots, \xi _ k $) ist entweder
				    	\begin{enumerate}
				    		\item der Term $ \xi $, wobei $ \xi \in \{ \xi _ 1, \cdots, \xi _ k \} $ gilt, oder
				    		\item ein Term der Form $ \text{r-name}(\xi, (\mathcal{H} _ 1, \cdots, \mathcal{H} _ n)) $, wobei
					    		\begin{itemize}
					    			\item es in $ \mathcal{K} $ eine Regel folgender Form gibt:
						    			\begin{equation*}
							    			\prftree[l, r]
								    			{ $ \Phi _ 1, \cdots, \Phi _ m $ }
								    			{ r-name }
								    			{ \zeta _ 1, \cdots, \zeta _ n }
								    			{ \zeta }
						    			\end{equation*}
						    		\item und es eine Substitution $ \eta $ gibt, sodass
							    		\begin{itemize}
							    			\item $ \xi = \zeta\eta $ und
							    			\item $ \Phi _ 1 \eta, \cdots, \Phi _ m \eta $ erfüllt sind und
							    			\item $ (\mathcal{H} _ 1, \cdots, \mathcal{H} _ n) $ eine (möglicherweise leere) Liste von Herleitungen ist, sodass, für jedes $ i \in \{ 1, \cdots, n \} $, $ \mathcal{H} _ i $ ein Herleitung von $ \zeta _ i \eta $ aus $ \xi _ 1, \cdots, \xi _ k $ ist.
							    		\end{itemize}
					    		\end{itemize}
				    	\end{enumerate}
				    }
				    
				    \notation{Herleitungen}{
					    \begin{itemize}
					    	\item Def.: $ \mathcal{H} \Vdash _ \mathcal{K} \xi \iff \mathcal{H} $ ist eine $ \mathcal{K} $-Herleitung von $ \xi $
					    	\item Def.: $ \Vdash _ \mathcal{K} \xi \iff \xi $ hat eine $ \mathcal{K} $-Herleitung
					    \end{itemize}
					    Ergibt sich der Kalkül aus dem Kontext, so kann das tiefgestellte $ \mathcal{K} $ weg gelassen werden.
				    }
				    
				    \notation{Menge aller $ \mathcal{K} $-Herleitungen von $ \xi $}{
					    Die Menge aller $ \mathcal{K} $-Herleitungen wird mit $ \textit{DER} _ \mathcal{K} (\xi) $ bezeichnet.
					    
					    Ergibt sich der Kalkül aus dem Kontext, so kann das tiefgestellte $ \mathcal{K} $ weg gelassen werden.
				    }
				    
				    \notation{Menge aller $ \mathcal{K} $-Herleitungen}{
					    Die Menge aller $ \mathcal{K} $-Herleitungen wird mit $ \textit{DER} _ \mathcal{K} $ bezeichnet.
				    	
				    	Ergibt sich der Kalkül aus dem Kontext, so kann das tiefgestellte $ \mathcal{K} $ weg gelassen werden.
				    }
			    % end
		    % end
	    % end
	    
	    \section{Alternative (operationelle) Semantik}
		    \subsection{Urteil}
			    \definition{1. Urteil für \textit{AExp}}{
			    	Das Urteil $ \langle a, \sigma \rangle \rightarrow _ 1 a' $ besagt, dass
			    	\begin{itemize}
			    		\item ein arithmetischer Ausdruck $ a \in \textit{AExp} $
			    		\item in einem Zustand $ \sigma \in \Sigma $
			    		\item in einem primitiven Berechnungsschritt
			    		\item zu einem Ausdruck $ a' \in \textit{AExp} $ reduziert wird.
			    	\end{itemize}
			    }
			    
			    \definition{Auswertungsurteil für \textit{AExp}}{
			    	Das Urteil $ \langle a, \sigma \rangle \Rightarrow n $ besagt, dass
			    	\begin{itemize}
			    		\item ein arithmetischer Ausdruck $ a \in \textit{AExp} $
			    		\item in einem Zustand $ \sigma \in \Sigma $
			    		\item zu einem Wert $ n \in \textit{Num} $ auswertet.
			    	\end{itemize}
			    }
			    
			    \definition{Urteil für \textit{Com}}{
			    	Das Urteil $ \langle c, \sigma \rangle \rightarrow _ 1 \langle c', \sigma' \rangle $ besagt, dass
			    	\begin{itemize}
			    		\item ein Kommando $ c \in \textit{Com} $
			    		\item in einem Zustand $ \sigma \in \Sigma $
			    		\item in einem primitiven Berechnungsschritt
			    		\item zu einem Paar $ \langle c', \sigma' \rangle $ reduziert wird, wobei
				    		\begin{itemize}
				    			\item $ \sigma' \in \Sigma $
				    			\item $ c' \in \textit{Com} \cup \{ \epsilon \} $
				    			\item und die Terminierung eines Programms durch $ \epsilon $ modelliert wird.
				    		\end{itemize}
			    	\end{itemize}
			    }
			    
			    \definition{Auswertungsurteil für \textit{Com}}{
			    	Das Urteil $ \langle c, \sigma \rangle \Rightarrow \sigma' $ besagt, dass
			    	\begin{itemize}
			    		\item ein Kommando $ c \in \textit{Com} $
			    		\item in einem Zustand $ \sigma \in \Sigma $
			    		\item zu einem Zustand $ \sigma' \in \Sigma $ auswertet.
			    	\end{itemize}
			    }
		    % end
		    
		    \subsection{Kalkülregeln}
			    \subsubsection{Kalkül für \textit{AExp}}
					Die folgenden Regeln formulieren einen kleinschrittigen Kalkül, welcher Ausdrücke in \textit{AExp} in primitiven Berechnungsschritten auswertet.
		
				    \subparagraph{Basisregeln}
				    	\begin{equation*}
					    	\prftree[l]
						    	{ arNum }
						    	{ \langle n, \sigma \rangle \rightarrow _ 1 n }
				    	\end{equation*}
				    	\begin{equation*}
					    	\prftree[l, r]
						    	{ $ n = \sigma(X) $ }
						    	{ arVar }
						    	{ \langle X, \sigma \rangle \rightarrow _ 1 n }
				    	\end{equation*}
				    % end
			    	
			    	\subparagraph{Regeln für $ \oplus $}
				    	\begin{equation*}
					    	\prftree[l, r]
						    	{ $ a _ 1 \not\in \textit{Num} $ }
						    	{ ar$ \oplus $1 }
						    	{ \langle a _ 1, \sigma \rangle \rightarrow _ 1 a _ 1 ' }
						    	{ \langle (a _ 1 \oplus a _ 2), \sigma \rangle \rightarrow _ 1 (a _ 1 ' \oplus a _ 2) }
				    	\end{equation*}
				    	\begin{equation*}
					    	\prftree[l, r]
						    	{ $ n _ 1 \in \textit{Num} \land a _ 2 \not\in \textit{Num} $ }
						    	{ ar$ \oplus $2 }
						    	{ \langle a _ 2, \sigma \rangle \rightarrow _ 1 a _ 2 ' }
						    	{ \langle (n _ 1 \oplus a _ 2), \sigma \rangle \rightarrow _ 1 (n _ 1 \oplus a _ 2 ') }
				    	\end{equation*}
				    	\begin{equation*}
					    	\prftree[l, r]
						    	{ $ n _ 1, n _ 2 \in \textit{Num} \land n = n _ 1 + n _ 2 $ }
						    	{ ar$ \oplus $3 }
						    	{ \langle (n _ 1 \oplus n _ 2), \sigma \rangle \rightarrow _ 1 n }
				    	\end{equation*}
			    	% end
			    	
				    \subparagraph{Regeln für $ \ominus $}
				    	\begin{equation*}
					    	\prftree[l, r]
						    	{ $ a _ 1 \not\in \textit{Num} $ }
						    	{ ar$ \ominus $1 }
						    	{ \langle a _ 1, \sigma \rangle \rightarrow _ 1 a _ 1 ' }
						    	{ \langle (a _ 1 \ominus a _ 2), \sigma \rangle \rightarrow _ 1 (a _ 1 ' \ominus a _ 2) }
				    	\end{equation*}
				    	\begin{equation*}
					    	\prftree[l, r]
						    	{ $ n _ 1 \in \textit{Num} \land a _ 2 \not\in \textit{Num} $ }
						    	{ ar$ \ominus $2 }
						    	{ \langle a _ 2, \sigma \rangle \rightarrow _ 1 a _ 2 ' }
						    	{ \langle (n _ 1 \ominus a _ 2), \sigma \rangle \rightarrow _ 1 (n _ 1 \ominus a _ 2 ') }
				    	\end{equation*}
				    	\begin{equation*}
					    	\prftree[l, r]
						    	{ $ n _ 1, n _ 2 \in \textit{Num} \land n = n _ 1 - n _ 2 $ }
						    	{ ar$ \ominus $3 }
						    	{ \langle (n _ 1 \ominus n _ 2), \sigma \rangle \rightarrow _ 1 n }
				    	\end{equation*}
			    	% end
	
			    	\subparagraph{Regeln für $ \odot $}
				    	\begin{equation*}
					    	\prftree[l, r]
						    	{ $ a _ 1 \not\in \textit{Num} $ }
						    	{ ar$ \odot $1 }
						    	{ \langle a _ 1, \sigma \rangle \rightarrow _ 1 a _ 1 ' }
						    	{ \langle (a _ 1 \odot a _ 2), \sigma \rangle \rightarrow _ 1 (a _ 1 ' \odot a _ 2) }
				    	\end{equation*}
				    	\begin{equation*}
					    	\prftree[l, r]
						    	{ $ n _ 1 \in \textit{Num} \land a _ 2 \not\in \textit{Num} $ }
						    	{ ar$ \odot $2 }
						    	{ \langle a _ 2, \sigma \rangle \rightarrow _ 1 a _ 2 ' }
						    	{ \langle (n _ 1 \odot a _ 2), \sigma \rangle \rightarrow _ 1 (n _ 1 \odot a _ 2 ') }
				    	\end{equation*}
				    	\begin{equation*}
					    	\prftree[l, r]
						    	{ $ n _ 1, n _ 2 \in \textit{Num} \land n = n _ 1 \cdot n _ 2 $ }
						    	{ ar$ \odot $3 }
						    	{ \langle (n _ 1 \odot n _ 2), \sigma \rangle \rightarrow _ 1 n }
				    	\end{equation*}
				    % end
				    
				    \subparagraph{Regeln für Auswertungen}
					    \begin{equation*}
							\prftree[l, r]
								{ $ n \in \textit{Num} $ }
								{ ar $ \Rightarrow $ a1 }
								{ \langle a, \sigma \rangle \rightarrow _ 1 n }
								{ \langle a, \sigma \rangle \Rightarrow n }
					    \end{equation*}
					    \begin{equation*}
						    \prftree[l, r]
							    { $ a' \not\in \textit{Num} $ }
							    { ar $ \Rightarrow $ a2 }
							    { \langle a, \sigma \rangle \rightarrow _ 1 a' }
							    { \langle a', \sigma \rangle \Rightarrow n }
							    { \langle a, \sigma \rangle \Rightarrow n }
					    \end{equation*}
				    % end
				% end
				
				\subsubsection{Kalkül für \textit{BExp}}
					\todo{Operationelles Kalkül für BExp}
				% end
				
				\subsubsection{Kalkül für \textit{Com}}
					\todo{Operationelles Kalkül für Com}
				% end
		    % end
	    % end
	    
	    \section{Beweistechniken}
		    \subsection{Äquivalenz zweier Programme}
			    \subsubsection{Fallunterscheidung}
				    \paragraph{Theorem}
						\begin{equation*}
							\texttt{while } b \texttt{ do } c \texttt{ od} \sim \texttt{if } b \texttt{ then } c ; \texttt{ while } b \texttt{ do } c \texttt{ od else skip fi}
						\end{equation*}
					% end
					
					\paragraph{Beweis}
						\begin{itemize}
							\item Es ist die Definition von semantischer Äquivalenz in \textit{Com} zu zeigen.
							\item Seien $ \sigma, \sigma' \in \Sigma $ beliebige Zustände und $ \eta $ eine beliebige Grundsubstitution, deren Definitionsbereich $ b $ und $ c $ enthält.
							\item Somit sind folgende Teilaussagen zu Beweisen:
								\begin{enumerate}
									\item Wenn $ \langle (\texttt{while } b \texttt{ do } c \texttt{ od}) \eta, \sigma \rangle \rightarrow \sigma' $ herleitbar ist, dann ist auch \\ $ \langle (\texttt{if } b \texttt{ then } c ; \texttt{ while } b \texttt{ do } c \texttt{ od else skip fi}) \eta, \sigma \rangle \rightarrow \sigma' $ herleitbar.
									\item Wenn $ \langle (\texttt{if } b \texttt{ then } c ; \texttt{ while } b \texttt{ do } c \texttt{ od else skip fi}) \eta, \sigma \rangle \rightarrow \sigma' $ herleitbar ist, dann ist auch $ \langle (\texttt{while } b \texttt{ do } c \texttt{ od}) \eta, \sigma \rangle \rightarrow \sigma' $ herleitbar.
								\end{enumerate}
							\item $ \rightarrow $ Fallunterscheidung
						\end{itemize}
						
						\subparagraph{Beweis von Aussage 1}
						\begin{itemize}
							\item Angenommen, $ \langle (\texttt{while } b \texttt{ do } c \texttt{ od}) \eta, \sigma \rangle \rightarrow \sigma' $ sei herleitbar.
							\item Es gibt zwei Möglichkeiten für die letzte Regel in der Herleitung:
								\begin{enumerate}
									\item \enquote{rwhf} ist die letzte Regel
									\item \enquote{rwht} ist die letzte Regel
								\end{enumerate}
							\item $ \rightarrow $ Fallunterscheidung
						\end{itemize}
						
						\subparagraph{Beweis von Fall 1.1}
						\begin{itemize}
							\item Da \enquote{rwhf} die letzte Regel in der Herleitung ist, muss die Herleitung die folgende Form haben:
								\begin{equation*}
									\prftree[l]
										{ rwhf }
										{ \prfsummary{\mathcal{H} _ 1}{\langle b\eta, \sigma \rangle \Downarrow \texttt{false} } }
										{ \langle (\texttt{while } b \texttt{ do } c \texttt{ od}) \eta, \sigma \rangle \rightarrow \sigma }
								\end{equation*}
							\item Es gibt somit eine Herleitung $ \mathcal{H} _ 1 $ von $ \langle b\eta, \sigma \rangle \Downarrow \texttt{false} $ und es gilt $ \sigma = \sigma' $.
							\item Mit Hilfe der Herleitung $ \mathcal{H} _ 1 $ kann folgende Herleitung von \\ $ \langle (\texttt{if } b \texttt{ then } c ; \texttt{ while } b \texttt{ do } c \texttt{ od else skip fi}) \eta, \sigma \rangle \rightarrow \sigma' $ konstruiert werden:
								\begin{equation*}
									\prftree[l]
										{ riff }
										{ \prfsummary{\mathcal{H} _ 1}{\langle b\eta, \sigma \rangle \Downarrow \texttt{false}} }
										{ \prftree[l]{ rsk }{ \langle (\texttt{skip})\eta, \sigma \rangle \rightarrow \sigma } }
										{ \langle (\texttt{if } b \texttt{ then } c ; \texttt{ while } b \texttt{ do } c \texttt{ od else skip fi}) \eta, \sigma \rangle \rightarrow \sigma }
								\end{equation*}
						\end{itemize}
						
						\subparagraph{Beweis von Fall 1.2}
						\begin{itemize}
							\item Da \enquote{rwht} die letzte Regel in der Herleitung ist, muss die Herleitung die folgende Form haben:
								\begin{equation*}
									\prftree[l]
										{ rwht }
										{ \prfsummary{\mathcal{H} _ 1}{\langle b\eta, \sigma \rangle \Downarrow \texttt{true}} }
										{ \prfsummary{\mathcal{H} _ 2}{\langle c\eta, \sigma \rangle \rightarrow \sigma''} }
										{ \prfsummary{\mathcal{H} _ 3}{\langle (\texttt{while } b \texttt{ do } c \texttt{ od})\eta, \sigma'' \rangle \rightarrow \sigma'} }
										{ \langle (\texttt{while } b \texttt{ do } c \texttt{ od})\eta, \sigma \rangle \rightarrow \sigma' }
								\end{equation*}
							\item Mit Hilfe der Herleitungen $ \mathcal{H} _ 1 $, $ \mathcal{H} _ 2 $ und $ \mathcal{H} _ 3 $ kann folgende Herleitung von \\ $ \langle (\texttt{if } b \texttt{ then } c ; \texttt{ while } b \texttt{ do } c \texttt{ od else skip fi}) \eta, \sigma \rangle \rightarrow \sigma' $ konstruiert werden:
								\begin{equation*}
									\prftree[l]
										{ rift }
										{ \prfsummary{\mathcal{H} _ 1}{\langle b\eta, \sigma \rangle \Downarrow \texttt{true}} }
										{
											\prftree[l]
												{ r; }
												{ \prfsummary{\mathcal{H} _ 2}{\langle c\eta, \sigma \rangle \rightarrow \sigma''} }
												{ \prfsummary{\mathcal{H} _ 3}{\langle (\texttt{while } b \texttt{ do } c \texttt{ od})\eta, \sigma'' \rangle \rightarrow \sigma'} }
												{ \langle (c ; \texttt{ while } b \texttt{ do } c \texttt{ od else skip fi})\eta, \sigma \rangle \rightarrow \sigma' }
										}
										{ \langle (\texttt{if } b \texttt{ then } c ; \texttt{ while } b \texttt{ do } c \texttt{ od else skip fi}) \eta, \sigma \rangle \rightarrow \sigma' }
								\end{equation*}
						\end{itemize}
						
						\subparagraph{Beweis von Aussage 2}
						\begin{itemize}
							\item Angenommen, $ \langle (\texttt{if } b \texttt{ then } c ; \texttt{ while } b \texttt{ do } c \texttt{ od else skip fi}) \eta, \sigma \rangle \rightarrow \sigma' $ sei herleitbar.
							\item Es gibt zwei Möglichkeiten für die letzte Regel der Herleitung:
								\begin{enumerate}
									\item \enquote{riff} ist die letzte Regel
									\item \enquote{rift} ist die letzte Regel
								\end{enumerate}
							\item $ \rightarrow $ Fallunterscheidung
						\end{itemize}
						
						\subparagraph{Beweis von Fall 2.1}
						\begin{itemize}
							\item Da \enquote{riff} die letzte Regel der Herleitung ist, muss die Herleitung die folgende Form haben:
								\begin{equation*}
									\prftree[l]
										{ riff }
										{ \prfsummary{\mathcal{H} _ 1}{\langle b\eta, \sigma \rangle \Downarrow \texttt{false}} }
										{ \prftree[l]{ rsk }{ \langle (\texttt{skip})\eta, \sigma \rangle \rightarrow \sigma } }
										{ \langle (\texttt{if } b \texttt{ then } c ; \texttt{ while } b \texttt{ do } c \texttt{ od else skip fi}) \eta, \sigma \rangle \rightarrow \sigma }
								\end{equation*}
							\item Somit gilt für \enquote{riff}, dass $ \sigma' = \sigma $.
							\item Mit Hilfe der Herleitung $ \mathcal{H} _ 1 $ kann folgende Herleitung von $ \langle (\texttt{while } b \texttt{ do } c \texttt{ od}) \eta, \sigma \rangle \rightarrow \sigma' $ konstruiert werden:
								\begin{equation*}
									\prftree[l]
										{ rwhf }
										{ \prfsummary{\mathcal{H} _ 1}{\langle b\eta, \sigma \rangle \Downarrow \texttt{false}} }
										{ \langle (\texttt{while } b \texttt{ do } c \texttt{ od}) \eta, \sigma \rangle \rightarrow \sigma }
								\end{equation*}
						\end{itemize}
						
						\subparagraph{Beweis von Fall 2.2}
						\begin{itemize}
							\item Da \enquote{rift} die letzte Regel der Herleitung ist, muss die Herleitung die folgende Form haben:
								\begin{equation*}
									\prftree[l]
										{ riff }
										{ \prfsummary{\mathcal{H} _ 1}{\langle b\eta, \sigma \rangle \Downarrow \texttt{true}} }
										{
											\prftree[l]
												{ r; }
												{ \prfsummary{\mathcal{H} _ 1}{\langle c\eta, \sigma \rangle \rightarrow \sigma''} }
												{ \prfsummary{\mathcal{H} _ 3}{\langle (\texttt{ while } b \texttt{ do } c \texttt{ od})\eta, \sigma'' \rangle \rightarrow \sigma' } }
												{ \langle (c ; \texttt{ while } b \texttt{ do } c \texttt{ od else skip fi}) \eta, \sigma \rangle \rightarrow \sigma' }
										}
										{ \langle (\texttt{if } b \texttt{ then } c ; \texttt{ while } b \texttt{ do } c \texttt{ od else skip fi})\eta, \sigma \rangle \rightarrow \sigma' }
								\end{equation*}
							\item Mit Hilfe der Herleitungen $ \mathcal{H} _ 1 $, $ \mathcal{H} _ 2 $ und $ \mathcal{H} _ 3 $ kann folgende Herleitung von \\ $ \langle (\texttt{while } b \texttt{ do } c \texttt{ od}) \eta, \sigma \rangle \rightarrow \sigma' $ konstruiert werden:
								\begin{equation*}
									\prftree[l]
										{ rwht }
										{ \prfsummary{\mathcal{H} _ 1}{\langle b\eta, \sigma \rangle \Downarrow \texttt{true}} }
										{ \prfsummary{\mathcal{H} _ 2}{\langle c\eta, \sigma \rangle \rightarrow \sigma''} }
										{ \prfsummary{\mathcal{H} _ 3}{\langle (\texttt{while } b \texttt{ do } c \texttt{ od}) \eta, \sigma'' \rangle \rightarrow \sigma'}  }
										{ \langle (\texttt{while } b \texttt{ do } c \texttt{ od}) \eta, \sigma \rangle \rightarrow \sigma' }
								\end{equation*}
						\end{itemize}
						
						\qed
					% end
			    % end
		    % end
		    
		    \subsection{Nichtterminierung eines Programms}
			    \subsubsection{Widerspruchsbeweis}
				    \paragraph{Theorem}
					    Es gibt keine Zustände $ \sigma, \sigma' \in \Sigma $, sodass $ \langle \texttt{ while true do skip od}, \sigma \rangle \rightarrow \sigma' $ herleitbar ist.
					    
					    \intuition{Das Programm terminiert nie.}
				    % end
				    
				    \paragraph{Beweis}
					    \begin{itemize}
						    \item Seien $ \sigma, \sigma' \in \Sigma $ beliebig.
						    \item Sei $ \mathcal{H} $ die minimale Herleitung von $ \langle \texttt{ while true do skip od}, \sigma \rangle \rightarrow \sigma' $, d.h. es gibt keine Herleitung mit weniger Regeln als $ \mathcal{H} $.
						    \item Da \enquote{rwht} die letzte Regel der Herleitung sein muss, hat die Herleitung die folgende Form:
							    \begin{equation*}
									\prftree[l]
										{ rwht }
										{ \prftree[l]{ rtrue }{ \langle \texttt{true}, \sigma \rangle \Downarrow \texttt{true} } }
										{ \prftree[l]{ rsk }{ \langle \texttt{skip}, \sigma \rangle \rightarrow \sigma } }
										{ \prfsummary{\mathcal{H} _ 1}{ \langle \texttt{ while true do skip od}, \sigma \rangle \rightarrow \sigma' } }
										{ \langle \texttt{ while true do skip od}, \sigma \rangle \rightarrow \sigma' }
							    \end{equation*}
							\item Somit gilt $ \sigma'' = \sigma $.
							\item Da $ \mathcal{H} _ 2 $ wiederum eine Herleitung von $ \langle \texttt{ while true do skip od}, \sigma \rangle \rightarrow \sigma' $ darstellt, aber weniger Schritte hat als $ \mathcal{H} $, ist $ \mathcal{H} $ nicht die minimale Herleitung. $ \lightning $
							\item[$ \implies $] Das Programm terminiert nie.
					    \end{itemize}
					    
					    \qed
				    % end
			    % end
		    % end
		    
		    \subsection{Induktionsprinzipien}
			    \subsubsection{Prinzip der wohlfundierte Induktion}
				    \paragraph{Theorem}
					    Sei $ P \subseteq D $ eine einstellige Relation auf einer Menge $ D $ und $ \prec \,\subseteq D \times D $ eine wohlfundierte Relation auf D.
					    
					    \begin{align*}
						    \text{Wenn gilt:} & \,\forall d \in D : (\forall d' \in D : ((d' \prec d \implies P(d')) \implies P(d))) \\
						    \text{dann gilt:} & \,\forall d \in D : P(d) \\
					    \end{align*}
				    % end
				    
				    \intuition{Wenn aus \enquote{$ P $ gilt für alle $ d' $, die kleiner sind als $ d $} folgt, dass \enquote{$ P $ für $ d $ gilt}, dann gilt $ P $ für alle Elemente aus $ D $.}
			    % end

			    \subsubsection{Induktion auf den natürlichen Zahlen}
				    \paragraph{Theorem}
					    Sei $ P \subseteq \mathbb{N} _ 0 $ eine einstellige Relation über den natürlichen Zahlen.
					    
					    \begin{align*}
						    \text{Wenn gilt:} & \,P(0) \\
						    \land & \,\forall n \in \mathbb{N} _ 0 : (P(n) \implies P(n + 1)) \\
						    \text{dann gilt:} & \,\forall n \in \mathbb{N} _ 0 : P(n) \\
					    \end{align*}
				    % end
				    
				    \paragraph{Instanziierung der wohlfundierten Induktion}
					    Die Relation $ \prec \,\subseteq \mathbb{N} _ 0 \times \mathbb{N} _ 0 $ sei definiert als $ \prec \,\coloneqq \{ (m, n) \in \mathbb{N} _ 0 \times \mathbb{N} _ 0 \forwhich m + 1 = n \} $.
					    
					    Somit wird das Beweisprinzip der wohlfundierten Induktion folgendermaßen instantiiert:
					    \begin{align*}
						    \text{Wenn gilt:} & \,\forall n \in \mathbb{N} _ 0 : (\forall n' \in \mathbb{N} _ 0 : ((n' + 1 = n \implies P(n')) \implies P(n))) \\
						    \text{Dann gilt:} & \,\forall n \in \mathbb{N} _ 0 : P(n)
					    \end{align*}
					    Da $ n' + 1 = n $ für $ n = 0 $ niemals gelten kann und die Implikation somit immer gilt, wird eine Fallunterscheidung vorgenommen:
					    \begin{align*}
						    \text{Wenn gilt:} & \,\forall n' \in \mathbb{N} _ 0 : ((n' + 1 = 0 \implies P(n)) \implies P(0)) \\
							\land & \,\forall n \in \mathbb{N} _ 0 : (n \neq 0 \implies ((\forall n' \in \mathbb{N} _ 0 : ((n' + 1 = n \implies P(n')) \implies P(n))))) \\
							\text{dann gilt:} & \,\forall n \in \mathbb{N} _ 0 : P(n) \\
					    \end{align*}
						Dies kann vereinfacht werden zu:
						\begin{align*}
							\text{Wenn gilt:} & \,\top \implies P(0) \\
							\land & \,\forall n'' \in \mathbb{N} _ 0 : (n'' + 1 \neq 0 \implies ((\forall n' \in \mathbb{N} _ 0 : ((n' + 1 = n'' + 1 \implies P(n')) \implies P(n'' + 1))))) \\
							\text{dann gilt:} & \,\forall n \in \mathbb{N} _ 0 : P(n) \\
						\end{align*}
						Da $ n'' + 1 \neq 0 $ immer gilt, kann wieder vereinfacht werden und das Prinzip der wohlfundierten Induktion damit endgültig für das Prinzip der Induktion über den natürlichen Zahlen instantiiert werden:
						\begin{align*}
							\text{Wenn gilt:} & \,P(0) \\
							\land & \,\forall n'' \in \mathbb{N} _ 0 : (P(n'') \implies P(n'' + 1)) \\
							\text{dann gilt:} & \,\forall n \in \mathbb{N} _ 0 : P(n) \\
						\end{align*}
				    % end
			    % end
			    
			    \subsubsection{Prinzip der Strukturelle Induktion}
					Das Prinzip der strukturellen Induktion instantiiert das Prinzip der wohlfundierten Induktion für Strukturen wie \textit{AExp}, \textit{BExp} oder \textit{Com}. Diese werden in den folgenden Abschnitten vorgestellt.
					
					Das Prinzip der strukturellen Induktion für \textit{Com} wird hier bewusst ausgelassen.
			    % end
			    
			    \subsubsection{Strukturelle Induktion für \textit{AExp}}
				    Sei $ P \subseteq \textit{AExp} $ eine einstellige Relation über \textit{AExp}.
				    
				    \paragraph{Theorem}
					    \begin{align*}
						    \text{Wenn gilt:} & \,\forall n \in \textit{Num} : P(n) \\
							\land & \,\forall X \in \textit{Var} : P(X) \\
							\land & \,\forall a _ 1, a _ 2 \in \textit{AExp} : (P(a _ 1) \land P(a _ 2) \implies P((a _ 1 \oplus a _ 2))) \\
							\land & \,\forall a _ 1, a _ 2 \in \textit{AExp} : (P(a _ 1) \land P(a _ 2) \implies P((a _ 1 \ominus a _ 2))) \\
							\land & \,\forall a _ 1, a _ 2 \in \textit{AExp} : (P(a _ 1) \land P(a _ 2) \implies P((a _ 1 \odot a _ 2))) \\
							\text{dann gilt:} & \,\forall a \in \textit{AExp} : P(a) \\
					    \end{align*}
				    % end
				    
				    \paragraph{Instanziierung der wohlfundierten Induktion}
					    \definition{Direkte Teilausdrücke}{Die Ausdrücke $ a _ 1, a _ 2 \in \textit{AExp} $ sind die direkten Teilausdrücke der Ausdrücke $ (a _ 1 \oplus a _ 2) $, $ (a _ 1 \ominus a _ 2) $ und $ (a _ 1 \odot a _ 2) $. Die Ausdrücke $ n $ und $ X $ haben keine direkten Teilausdrücke.}

					    Die Relation $ \prec \,\subseteq \textit{AExp} \,\times\, \textit{AExp} $ sei definiert als \[ \prec \,\coloneqq \{ (a _ 1, a _ 2) \in \textit{AExp} \,\times\, \textit{AExp} \forwhich a _ 1 \text{ ist direkter Teilausdruck von } a _ 2 \} \].
					    
					    Somit wird das Beweisprinzip der wohlfundierten Induktion folgendermaßen instantiiert:
					    \begin{align*}
						    \text{Wenn gilt:} & \,\forall a \in \textit{AExp} : (\forall a' \in \textit{AExp} : ((a' \text{ ist direkter Teilausdruck von } a \implies P(a')) \implies P(a))) \\
							\text{dann gilt:} & \,\forall a \in \textit{AExp} : P(a) \\
					    \end{align*}
					    Da für alle $ n \in \textit{Num} $ und alle $ X \in \textit{Var} $ die Teilausdrucksbedingung nicht gilt und somit die erste Implikation immer Wahr, wird folgende Fallunterscheidung durchgeführt. Auch kann die Bedingung der direkten Teilausdrücke mit obiger Definition verworfen und durch eine Fallunterscheidung implementiert werden:
					    \begin{align*}
						    \text{Wenn gilt:} & \,\forall n \in \textit{Num} : P(n) \tag{$ n $ hat keine direkte Teilausdrücke} \\
							\land & \,\forall X \in \textit{Var} : P(X) \tag{$ X $ hat keine direkte Teilausdrücke} \\
							\land & \,\forall a _ 1, a _ 2 \in \textit{AExp} : (P(a _ 1) \land P(a _ 2) \implies P(a _ 1 \oplus a _ 2)) \tag{1. Fall für direkte Teilausdrücke} \\
							\land & \,\forall a _ 1, a _ 2 \in \textit{AExp} : (P(a _ 1) \land P(a _ 2) \implies P(a _ 1 \ominus a _ 2)) \tag{2. Fall für direkte Teilausdrücke} \\
							\land & \,\forall a _ 1, a _ 2 \in \textit{AExp} : (P(a _ 1) \land P(a _ 2) \implies P(a _ 1 \odot a _ 2)) \tag{3. Fall für direkte Teilausdrücke} \\
							\text{dann gilt:} & \,\forall a \in \textit{AExp} : P(a)
					    \end{align*}
					    Damit wurde die wohlfundierte Induktion für die strukturelle Induktion für \textit{AExp} instantiiert.
				    % end
			    % end
			    
			    \subsubsection{Strukturelle Induktion für \textit{BExp}}
				    Sei $ P \subseteq \textit{BExp} $ eine einstellige Relation über \textit{BExp}.
			    
				    \paragraph{Theorem}
					    \begin{align*}
						    \text{Wenn gilt:} & \,P(\texttt{true}) \\
						    \land & \,P(\texttt{false}) \\
						    \land & \,\forall a _ 1, a _ 2 \in \textit{AExp} : P((a _ 1 \texttt{ eq } a _ 2)) \\
						    \land & \,\forall a _ 1, a _ 2 \in \textit{AExp} : P((a _ 1 \texttt{ leq } a _ 2)) \\
						    \land & \,\forall b _ 1 \in \textit{BExp} : (P(b _ 1) \implies P(\texttt{not } b _ 1)) \\
						    \land & \,\forall b _ 1, b _ 2 \in \textit{BExp} : (P(b _ 1) \land P(b _ 2) \implies P((b _ 1 \texttt{ and } b _ 2))) \\
						    \land & \,\forall b _ 1, b _ 2 \in \textit{BExp} : (P(b _ 1) \land P(b _ 2) \implies P((b _ 1 \texttt{ or } b _ 2))) \\
						    \text{dann gilt:} & \,\forall b \in \textit{BExp} : P(b) \\
					    \end{align*}
				    % end
			    
				    \paragraph{Instanziierung der wohlfundierten Induktion}
					    \definition{Direkte Teilausdrücke}{Die Ausdrücke $ b _ 1, b _ 2 \in \textit{BExp} $ sind die direkten Teilausdrücke der Ausdrücke $ \texttt{not } b _ 1 $, $ b _ 1 \texttt{ and } b _ 2 $ und $ b _ 1 \texttt{ or } b _ 2 $. Die Ausdrücke $ true $, $ false $, $ a _ 1 \texttt{ eq } a _ 2 $ und $ a _ 1 \texttt{ leq } a _ 2 $ ($ a _ 1, a _ 2 \in \textit{AExp} $) haben keine direkten Teilausdrücke (in \textit{BExp}).}
					    
					    Die Relation $ \prec \,\subseteq \textit{BExp} \,\times\, \textit{BExp} $ sei definiert als \[ \prec \,\coloneqq \{ (b _ 1, b _ 2) \in \textit{BExp} \,\times\, \textit{BExp} \forwhich b _ 1 \text{ ist direkter Teilausdruck von } b _ 2 \} \].
					    
					    Somit wird das Beweisprinzip der wohlfundierten Induktion folgendermaßen instantiiert:
					    \begin{align*}
						    \text{Wenn gilt:} & \,\forall b \in \textit{BExp} : (\forall b' \in \textit{BExp} : ((b \text{ ist direkter Teilausdruck von } b' \implies P(b')) \implies P(b))) \\
							\text{dann gilt:} & \,\forall b \in \textit{BExp} : P(b)
					    \end{align*}
					    Durch eine Fallunterscheidung an den Elementen der Struktur \textit{BExp} ergibt sich das folgende Prinzip der strukturellen Induktion für \textit{BExp}:
					    \begin{align*}
						    \text{Wenn gilt:} & \,P(\texttt{true}) \\
						    \land & \,P(\texttt{false}) \\
						    \land & \,\forall a _ 1, a _ 2 \in \textit{AExp} : P((a _ 1 \texttt{ eq } a _ 2)) \\
						    \land & \,\forall a _ 1, a _ 2 \in \textit{AExp} : P((a _ 1 \texttt{ leq } a _ 2)) \\
							\land & \,\forall b _ 1 \in \textit{BExp} : (P(b _ 1) \implies P(\texttt{not } b _ 1)) \\
						    \land & \,\forall b _ 1, b _ 2 \in \textit{BExp} : (P(b _ 1) \land P(b _ 2) \implies P((b _ 1 \texttt{ and } b _ 2))) \\
						    \land & \,\forall b _ 1, b _ 2 \in \textit{BExp} : (P(b _ 1) \land P(b _ 2) \implies P((b _ 1 \texttt{ or } b _ 2))) \\
						    \text{dann gilt:} & \,\forall b \in \textit{BExp} : P(b) \\
					    \end{align*}
					    Damit wurde die wohlfundierte Induktion für die strukturelle Induktion für \textit{BExp} instantiiert.
				    % end
			    % end
			    
			    \subsubsection{Prinzip der Induktion über Herleitung}
				    Das Prinzip der Induktion über Herleitung (Herleitungsinduktion) instantiiert das Prinzip der wohlfundierten Induktion für Kalküle wie $ \mathcal{A} $, $ \mathcal{B} $ oder $ \mathcal{C} $. Diese werden in den folgenden Abschnitten vorgestellt.
			    
				    \definition{Direkte Teilherleitung}{Die direkten Teilherleitungen einer Herleitung \\ $ \text{r-name}(\xi, (\mathcal{H} _ 1, \cdots, \mathcal{H} _ n)) $ sind die Herleitungen $ \mathcal{H} _ 1, \cdots, \mathcal{H} _ n $.}
				    
				    \todo{Herleitungsinduktion A}
				    \todo{Herleitungsinduktion B}
			    % end
			    
			    \subsubsection{Induktion über Herleitung für $ \mathcal{C} $}
				    Sei $ P \subseteq \mathcal{C} $ eine einstellige Relation über $ \mathcal{C} $.
				    
				    \paragraph{Theorem}
					    \begin{align*}
						    \text{Wenn gilt:} & \,\forall \sigma \in \Sigma : \\
							    &\quad P(\text{rsk}((\langle \texttt{skip}, \sigma \rangle \rightarrow \sigma), ())) \\
						    \land & \,\forall \sigma \in \Sigma : \\
							    &\quad \forall X \in \textit{Var} : \forall a \in \textit{AExp} : \forall n \in \textit{Num} : \\
							    &\quad \forall \mathcal{H} _ 1 \in \textit{DER} _ \mathcal{A} (\langle a, \sigma \rangle \Downarrow n) : \\
							    &\quad P(\text{r:=}((\langle X \coloneqq a, \sigma \rangle \rightarrow \sigma[X \backslash n]), (\mathcal{H} _ 1)) \\
						    \land & \,\forall \sigma, \sigma', \sigma'' \in \Sigma : \\
							    &\quad \forall c _ 1, c _ 2 \in \textit{Com} : \\
							    &\quad \forall \mathcal{H} _ 1 \in \textit{DER} _ \mathcal{C} (\langle c _ 1, \sigma \rangle \rightarrow \sigma'') : \forall \mathcal{H} _ 2 \in \textit{DER} _ \mathcal{C} (\langle c _ 2, \sigma'' \rightarrow \sigma') : \\
							    &\quad P(\mathcal{H} _ 1) \land P(\mathcal{H} _ 2) \\
							    &\quad\quad \implies P(\text{r;}((\langle c _ 1 ; c _ 2, \sigma \rangle \rightarrow \sigma'), (\mathcal{H} _ 1, \mathcal{H} _ 2))) \\
						    \land & \,\forall \sigma, \sigma' \in \Sigma : \\
							    &\quad \forall b \in \textit{BExp} : \forall c _ 1, c _ 2 \in \textit{Com} : \\
							    &\quad \forall \mathcal{H} _ 1 \in \textit{DER} _ \mathcal{B} (\langle b, \sigma \rangle \Downarrow \texttt{true}) : \\
							    &\quad \forall \mathcal{H} _ 2 \in \textit{DER} _ \mathcal{C} (\langle c _ 1, \sigma \rangle \rightarrow \sigma') : \\
							    &\quad P(\mathcal{H} _ 2) \\
							    &\quad\quad \implies P(\text{rift}((\langle \texttt{if } b \texttt{ then } c _ 1 \texttt{ else } c _ 2 \texttt{ fi}, \sigma \rangle \rightarrow \sigma'), (\mathcal{H} _ 1, \mathcal{H} _ 2))) \\
						    \land & \,\forall \sigma, \sigma' \in \Sigma : \\
							    &\quad \forall b \in \textit{BExp} : \forall c _ 1, c _ 2 \in \textit{Com} : \\
							    &\quad \forall \mathcal{H} _ 1 \in \textit{DER} _ \mathcal{B} (\langle b, \sigma \rangle \Downarrow \texttt{false}) : \\
							    &\quad \forall \mathcal{H} _ 2 \in \textit{DER} _ \mathcal{C} (\langle c _ 2, \sigma \rangle \rightarrow \sigma') : \\
							    &\quad P(\mathcal{H} _ 2) \\
							    &\quad\quad \implies P(\text{riff}((\langle \texttt{if } b \texttt{ then } c _ 1 \texttt{ else } c _ 2 \texttt{ fi}, \sigma \rangle \rightarrow \sigma'), (\mathcal{H} _ 1, \mathcal{H} _ 2))) \\
						    \land & \,\forall \sigma, \sigma', \sigma'' \in \Sigma : \\
							    &\quad \forall b \in \textit{BExp} : \forall c \in \textit{Com} : \\
							    &\quad \forall \mathcal{H} _ 1 \in \textit{DER} _ \mathcal{B} (\langle b, \sigma \rangle \Downarrow \texttt{true}) : \\
							    &\quad \forall \mathcal{H} _ 2 \in \textit{DER} _ \mathcal{C} (\langle c, \sigma \rangle \rightarrow \sigma'') : \\
							    &\quad \forall \mathcal{H} _ 3 \in \textit{DER} _ \mathcal{C} (\langle \texttt{while } b \texttt{ do } c \texttt{ od}, \sigma'' \rangle \rightarrow \sigma') : \\
							    &\quad P(\mathcal{H} _ 2) \land P(\mathcal{H} _ 3) \\
							    &\quad\quad \implies P(\text{rwht}((\langle \texttt{while } b \texttt{ do } c \texttt{ od}, \sigma \rangle \rightarrow \sigma'), (\mathcal{H} _ 1, \mathcal{H} _ 2, \mathcal{H} _ 3))) \\
						    \land & \,\forall \sigma \in \Sigma : \\
							    &\quad \forall b \in \textit{BExp} : \forall c \in \textit{Com} : \\
							    &\quad \forall \mathcal{H} _ 1 \in \textit{DER} _ \mathcal{B} (\langle b, \sigma \rangle \Downarrow \texttt{false}) : \\
							    &\quad P(\text{rwhf}((\langle \texttt{while } b \texttt{ do } c \texttt{ od}, \sigma \rangle \rightarrow \sigma), (\mathcal{H} _ 1))) \\
						    \text{dann gilt:} & \,\forall \mathcal{H} \in \textit{DER} _ \mathcal{C} : P(\mathcal{H}) \\
					    \end{align*}
				    % end
				    
				    \paragraph{Instanziierung der wohlfundierten Induktion}
					    Die Relation $ \prec \,\subseteq \textit{DER} _ \mathcal{C} \times \textit{DER} _ \mathcal{C} $ sei definiert als \[ \prec \,\coloneqq \{ (\mathcal{H} _ 1, \mathcal{H _ 2}) \in \textit{DER} _ \mathcal{C} \times \textit{DER} _ \mathcal{C} \forwhich \mathcal{H} _ 1 \text{ ist direkte Teilherleitung von } \mathcal{H} _ 2 \} \]
					    
					    Somit wird das Beweisprinzip der wohlfundierten Induktion folgendermaßen instantiiert:
					    \begin{align*}
						    \text{Wenn gilt:} & \,\forall \mathcal{H} \in \textit{DER} _ \mathcal{C} : (\forall \mathcal{H}' \in \textit{DER} _ \mathcal{C} : ((\mathcal{H} \text{ ist direkte Teilherleitung von } \mathcal{H}' \implies P(\mathcal{H}')) \implies \mathcal{H})) \\
						    \text{dann gilt:} & \,\forall \mathcal{H} \in \textit{DER} _ \mathcal{C} : P(\mathcal{H}) \\
					    \end{align*}
					    Durch Fallunterscheidungen für alle Regeln aus $ \mathcal{C} $ ergeben sich viele Einzelbedingungen (bspw. hat die Regel \enquote{rsk} keine direkten Teilherleitungen, weshalb sich die Regel stark vereinfacht):
					    \begin{align*}
						    \text{Wenn gilt:} & \,\forall \sigma \in \Sigma : \tag{Zustände} \\
							    &\quad P(\text{rsk}((\langle \texttt{skip}, \sigma \rangle \rightarrow \sigma), ())) \tag{Konklusion} \\
							\land & \,\forall \sigma \in \Sigma : \tag{Zustände} \\
								&\quad \forall X \in \textit{Var} : \forall a \in \textit{AExp} : \forall n \in \textit{Num} : \tag{Ausdrucksbestandteile} \\
								&\quad \forall \mathcal{H} _ 1 \in \textit{DER} _ \mathcal{A} (\langle a, \sigma \rangle \Downarrow n) : \tag{Kalkülfremde Herleitungen} \\
								&\quad P(\text{r:=}((\langle X \coloneqq a, \sigma \rangle \rightarrow \sigma[X \backslash n]), (\mathcal{H} _ 1)) \tag{Konklusion} \\
							\land & \,\forall \sigma, \sigma', \sigma'' \in \Sigma : \tag{Zustände} \\
								&\quad \forall c _ 1, c _ 2 \in \textit{Com} : \tag{Ausdrucksbestandteile} \\
								&\quad \forall \mathcal{H} _ 1 \in \textit{DER} _ \mathcal{C} (\langle c _ 1, \sigma \rangle \rightarrow \sigma'') : \forall \mathcal{H} _ 2 \in \textit{DER} _ \mathcal{C} (\langle c _ 2, \sigma'' \rightarrow \sigma') : \tag{Herleitungen in Prämisse} \\
								&\quad P(\mathcal{H} _ 1) \land P(\mathcal{H} _ 2) \tag{Prämisse} \\
								&\quad\quad \implies P(\text{r;}((\langle c _ 1 ; c _ 2, \sigma \rangle \rightarrow \sigma'), (\mathcal{H} _ 1, \mathcal{H} _ 2))) \tag{Konklusion} \\
							\land & \,\forall \sigma, \sigma' \in \Sigma : \tag{Zustände} \\
								&\quad \forall b \in \textit{BExp} : \forall c _ 1, c _ 2 \in \textit{Com} : \tag{Ausdrucksbestandteile} \\
								&\quad \forall \mathcal{H} _ 1 \in \textit{DER} _ \mathcal{B} (\langle b, \sigma \rangle \Downarrow \texttt{true}) : \tag{Kalkülfremde Herleitungen} \\
								&\quad \forall \mathcal{H} _ 2 \in \textit{DER} _ \mathcal{C} (\langle c _ 1, \sigma \rangle \rightarrow \sigma') : \tag{Herleitungen in Prämisse} \\
								&\quad P(\mathcal{H} _ 2) \tag{Prämisse} \\
								&\quad\quad \implies P(\text{rift}((\langle \texttt{if } b \texttt{ then } c _ 1 \texttt{ else } c _ 2 \texttt{ fi}, \sigma \rangle \rightarrow \sigma'), (\mathcal{H} _ 1, \mathcal{H} _ 2))) \tag{Konklusion} \\
							\land & \,\forall \sigma, \sigma' \in \Sigma : \tag{Zustände} \\
								&\quad \forall b \in \textit{BExp} : \forall c _ 1, c _ 2 \in \textit{Com} : \tag{Ausdrucksbestandteile} \\
								&\quad \forall \mathcal{H} _ 1 \in \textit{DER} _ \mathcal{B} (\langle b, \sigma \rangle \Downarrow \texttt{false}) : \tag{Kalkülfremde Herleitungen} \\
								&\quad \forall \mathcal{H} _ 2 \in \textit{DER} _ \mathcal{C} (\langle c _ 2, \sigma \rangle \rightarrow \sigma') : \tag{Herleitungen in Prämisse} \\
								&\quad P(\mathcal{H} _ 2) \tag{Prämisse} \\
								&\quad\quad \implies P(\text{riff}((\langle \texttt{if } b \texttt{ then } c _ 1 \texttt{ else } c _ 2 \texttt{ fi}, \sigma \rangle \rightarrow \sigma'), (\mathcal{H} _ 1, \mathcal{H} _ 2))) \tag{Konklusion} \\
							\land & \,\forall \sigma, \sigma', \sigma'' \in \Sigma : \tag{Zustände} \\
								&\quad \forall b \in \textit{BExp} : \forall c \in \textit{Com} : \tag{Ausdrucksbestandteile} \\
								&\quad \forall \mathcal{H} _ 1 \in \textit{DER} _ \mathcal{B} (\langle b, \sigma \rangle \Downarrow \texttt{true}) : \tag{Kalkülfremde Herleitungen} \\
								&\quad \forall \mathcal{H} _ 2 \in \textit{DER} _ \mathcal{C} (\langle c, \sigma \rangle \rightarrow \sigma'') : \tag{Herleitungen in Prämisse} \\
								&\quad \forall \mathcal{H} _ 3 \in \textit{DER} _ \mathcal{C} (\langle \texttt{while } b \texttt{ do } c \texttt{ od}, \sigma'' \rangle \rightarrow \sigma') : \tag{Herleitungen in Prämisse} \\
								&\quad P(\mathcal{H} _ 2) \land P(\mathcal{H} _ 3) \tag{Prämisse} \\
								&\quad\quad \implies P(\text{rwht}((\langle \texttt{while } b \texttt{ do } c \texttt{ od}, \sigma \rangle \rightarrow \sigma'), (\mathcal{H} _ 1, \mathcal{H} _ 2, \mathcal{H} _ 3))) \tag{Konklusion} \\
							\land & \,\forall \sigma \in \Sigma : \tag{Zustände} \\
								&\quad \forall b \in \textit{BExp} : \forall c \in \textit{Com} : \tag{Ausdrucksbestandteile} \\
								&\quad \forall \mathcal{H} _ 1 \in \textit{DER} _ \mathcal{B} (\langle b, \sigma \rangle \Downarrow \texttt{false}) : \tag{Kalkülfremde Herleitungen} \\
								&\quad P(\text{rwhf}((\langle \texttt{while } b \texttt{ do } c \texttt{ od}, \sigma \rangle \rightarrow \sigma), (\mathcal{H} _ 1))) \tag{Konklusion} \\
							\text{dann gilt:} & \,\forall \mathcal{H} \in \textit{DER} _ \mathcal{C} : P(\mathcal{H}) \\
					    \end{align*}
					    Damit wurde die wohlfundierte Induktion für die Induktion über Herleitungen für $ \mathcal{C} $ instantiiert.
				    % end
				    
				    \subsubsection{Regelinduktion}
					    Das Prinzip der Regelinduktion definiert ein Induktionsprinzip über Regeln eines Kalküls. Es kann beispielsweise für Kalküle wie $ \mathcal{A} $, $ \mathcal{B} $ oder $ \mathcal{C} $ instantiiert werden.
					    
					    Das Prinzip Regelinduktion für $ \mathcal{B} $ und $ \mathcal{C} $ wird hier bewusst ausgelassen.
					    
					    \paragraph{Beweisprinzip}
						    Sei $ \mathcal{K} $ ein Kalkül zur Herleitung von Instanzen eines Urteils und $ P $ eine einstellige Relation auf der Menge $ I _ \mathcal{K} $ aller Instanzen dieses Urteils.
						    
						    Wenn für jede Kalkülregel
						    \begin{equation*}
							    \prftree[l, r]
								    { $ \Phi _ 1, \cdots, \Phi _ m $ }
								    { r-name }
								    { \zeta _ 1, \cdots, \zeta _ n }
								    { \zeta }
						    \end{equation*}
						    in $ \mathcal{K} $ und jeder Substitution $ \eta $, sodass $ \Phi _ 1 \eta, \cdots, \Phi _ m \eta $ erfüllt sind, gilt, dass
						    \begin{equation*}
							    P(\zeta _ 1 \eta) \land \cdots \land P(\zeta _ n \eta) \implies P(\zeta\eta)
						    \end{equation*}
						    dann gilt auch
							\begin{equation*}
								\forall \xi \in I _ \mathcal{K} : P(\xi)
							\end{equation*}
					    % end
				    % end
				    
				    \subsubsection{Regelinduktion für $ \mathcal{A} $}
					    \paragraph{Theorem}
						    \begin{align*}
							    \text{Wenn gilt:} & \,\forall n \in \textit{Num} : P(n) \\
							    \land & \,\forall X \in \textit{Var} : P(X) \\
							    \land & \,\forall a _ 1, a _ 2 \in \textit{AExp} : P(a _ 1) \land P(a _ 2) \implies P((a _ 1 \oplus a _ 2)) \\
							    \land & \,\forall a _ 1, a _ 2 \in \textit{AExp} : P(a _ 1) \land P(a _ 2) \implies P((a _ 1 \ominus a _ 2)) \\
							    \land & \,\forall a _ 1, a _ 2 \in \textit{AExp} : P(a _ 1) \land P(a _ 2) \implies P((a _ 1 \odot a _ 2)) \\
							    \text{dann gilt:} & \,\forall a \in \textit{AExp} : P(a) \\
						    \end{align*}
						    
						    Welches wiederum der strukturellen Induktion für \textit{AExp} entspricht.
					    % end
				    % end
			    % end
		    % end
	    % end
	    
	    \section{Deterministische Auswertung}
 		    \subsection{\dots von Ausdrücken in \textit{AExp}}
	 		    \paragraph{Theorem}
		 		    Für alle $ a \in \textit{AExp} $, $ m, m' \in \textit{Num} $ und $ \sigma \in \Sigma $ gilt: \\
		 		    Wenn $ \langle a, \sigma \rangle \Downarrow m $ und $ \langle a, \sigma \rangle \Downarrow m' $ herleitbar sind, dann gilt $ m = m' $.
	 		    % end
	 		    
	 		    \paragraph{Beweis}
		 		    Es wird das Prinzip der strukturellen Induktion verwendet mit der einstelligen Relation
		 		    \begin{align*}
			 		    P(a) & \coloneqq \forall a \in \textit{AExp} : \forall m, m' \in \textit{Num} : \forall \sigma \in \Sigma : \\
			 		    & \quad\quad (((\langle a, \sigma \rangle \Downarrow m) \text{ herleitbar} \land (\langle a, \sigma \rangle \Downarrow m') \text{ herleitbar}) \implies m = m') \\
		 		    \end{align*}
		 		    
		 		    \subparagraph{Fall \enquote{Num}}
			 		    Sei $ n \in \textit{Num} $ beliebig.
		 		    
			 		    Die Herleitungen von $ \langle n, \sigma \rangle \Downarrow m $ und $ \langle n, \sigma \rangle \Downarrow m' $ können nur die folgende Form haben:
			 		    \begin{equation*}
				 		    \prftree[l]
					 		    { rNum }
					 		    { \langle n, \sigma \rangle \Downarrow n }
			 		    \end{equation*}
			 		    Womit $ m = m' $ gelten muss.
			 		% end
		 		    
		 		    \subparagraph{Fall \enquote{Var}}
			 		    Sei $ X \in \textit{Var} $ beliebig.
		 		    
			 		    Die Herleitungen von $ \langle X, \sigma \rangle \Downarrow m $ und $ \langle n, \sigma \rangle \Downarrow m' $ können nur die folgende Form haben:
			 		    \begin{equation*}
				 		    \prftree[l, r]
					 		    { $ n = \sigma(X) $ }
					 		    { rVar }
					 		    { \langle X, \sigma \rangle \Downarrow n }
			 		    \end{equation*}
			 		    Da $ \sigma(\cdot) $ eine Funktion ist, muss somit $ m = m' $ gelten.
			 		% end
		 		    
		 		    \subparagraph{Fall \enquote{$ \oplus $}}
			 		    Seien $ a _ 1, a _ 2 \in \textit{AExp} $ beliebig und gelte $ P(a _ 1) \land P(a _ 2) $.
			 		    
			 		    Die Herleitungen von $ \langle (a _ 1 \oplus a _ 2), \sigma \rangle \Downarrow m $ und $ \langle (a _ 1 \oplus a _ 2), \sigma \rangle \Downarrow m' $ können nur die folgende Form haben:
			 		    \begin{equation*}
				 		    \prftree[l, r]
					 		    { $ n = n _ 1 + n _ 2 $ }
					 		    { r$ \oplus $ }
					 		    { \prfsummary{\mathcal{H} _ 1}{\langle a _ 1, \sigma \rangle \Downarrow n _ 1} }
					 		    { \prfsummary{\mathcal{H} _ 2}{\langle a _ 2, \sigma \rangle \Downarrow n _ 2} }
					 		    { \langle (a _ 1 \oplus a _ 2), \sigma \rangle \Downarrow n }
			 		    \end{equation*}
			 		    Da $ a _ 1 $ und $ a _ 2 $ deterministisch auswerten, muss $ m = m' $ gelten.
		 		    % end
		 		    
		 		    \subparagraph{Fall \enquote{$ \ominus $}}
			 		    Seien $ a _ 1, a _ 2 \in \textit{AExp} $ beliebig und gelte $ P(a _ 1) \land P(a _ 2) $.
			 		    
			 		    Die Herleitungen von $ \langle (a _ 1 \ominus a _ 2), \sigma \rangle \Downarrow m $ und $ \langle (a _ 1 \ominus a _ 2), \sigma \rangle \Downarrow m' $ können nur die folgende Form haben:
			 		    \begin{equation*}
				 		    \prftree[l, r]
					 		    { $ n = n _ 1 - n _ 2 $ }
					 		    { r$ \ominus $ }
					 		    { \prfsummary{\mathcal{H} _ 1}{\langle a _ 1, \sigma \rangle \Downarrow n _ 1} }
					 		    { \prfsummary{\mathcal{H} _ 2}{\langle a _ 2, \sigma \rangle \Downarrow n _ 2} }
					 		    { \langle (a _ 1 \ominus a _ 2), \sigma \rangle \Downarrow n }
			 		    \end{equation*}
			 		    Da $ a _ 1 $ und $ a _ 2 $ deterministisch auswerten, muss $ m = m' $ gelten.
		 		    % end
		 		    
		 		    \subparagraph{Fall \enquote{$ \odot $}}
			 		    Seien $ a _ 1, a _ 2 \in \textit{AExp} $ beliebig und gelte $ P(a _ 1) \land P(a _ 2) $.
			 		    
			 		    Die Herleitungen von $ \langle (a _ 1 \odot a _ 2), \sigma \rangle \Downarrow m $ und $ \langle (a _ 1 \odot a _ 2), \sigma \rangle \Downarrow m' $ können nur die folgende Form haben:
			 		    \begin{equation*}
				 		    \prftree[l, r]
					 		    { $ n = n _ 1 \cdot n _ 2 $ }
					 		    { r$ \odot $ }
					 		    { \prfsummary{\mathcal{H} _ 1}{\langle a _ 1, \sigma \rangle \Downarrow n _ 1} }
					 		    { \prfsummary{\mathcal{H} _ 2}{\langle a _ 2, \sigma \rangle \Downarrow n _ 2} }
					 		    { \langle (a _ 1 \odot a _ 2), \sigma \rangle \Downarrow n }
			 		    \end{equation*}
			 		    Da $ a _ 1 $ und $ a _ 2 $ deterministisch auswerten, muss $ m = m' $ gelten.
		 		    % end
		 		    
		 		    Somit gilt $ \forall a \in \textit{AExp} : P(a) $ und damit sind Auswertungen in \textit{AExp} deterministisch.
		 		    
		 		    \qed
	 		    % end
	 		    
	 		    \todo{det. Auswertung in BExp}
		    % end
		    
		    \subsection{\dots von Programmen in \textit{Com}}
			    \paragraph{Theorem}
				    Für alle $ c \in \textit{Com} $ und alle Zustände $ \sigma, \sigma', \sigma'' \in \Sigma $ gilt: \\
				    Wenn $ \langle c, \sigma \rangle \rightarrow \sigma' $ und $ \langle c, \sigma \rangle \rightarrow \sigma'' $ herleitbar sind, dann gilt $ \sigma' = \sigma'' $.
			    % end
			    
			    \paragraph{Beweis}
				    Es wird das Prinzip der Induktion über Herleitung verwendet mit der einstelligen Relation
				    \begin{align*}
					    P(\mathcal{H}) & \coloneqq \forall c \in \textit{Com} : \forall \sigma, \sigma', \sigma'' \in \Sigma : (\mathcal{H} \in \textit{DER} _ \mathcal{C} (\langle c, \sigma \rangle \rightarrow \sigma') \implies \forall \mathcal{H}' \in \textit{DER} _ \mathcal{C} (\langle c, \sigma \rangle \rightarrow \sigma'') : \sigma' = \sigma'') \\
				    \end{align*}
				    
				    \subparagraph{Fall \enquote{rsk}}
					    Es ist zu zeigen, dass $ \forall \sigma ^ * \in \Sigma : P(\text{rsk}((\langle \texttt{skip}, \sigma ^ * \rangle \rightarrow \sigma ^ *), ())) $ gilt.
					    
					    Seien $ \sigma ^ *, \sigma, \sigma', \sigma'' \in \Sigma $, $ c \in \textit{Com} $ beliebig, sodass $ \text{rsk}((\langle \texttt{skip}, \sigma ^ * \rangle \rightarrow \sigma ^ *), ()) \in \textit{DER} _ \mathcal{C} (\langle c, \sigma \rangle \rightarrow \sigma') $ gilt.
					    
					    Somit muss $ c = \texttt{skip} $, $ \sigma = \sigma ^ * $ und $ \sigma' = \sigma ^ * $ gelten. Damit gilt auch $ \sigma = \sigma' $.
					    
					    Es ist noch zu zeigen, dass $ \forall \mathcal{H}' \in \textit{DER} _ \mathcal{C} (\langle \texttt{skip}, \sigma \rangle \rightarrow \sigma'') $.
					    
					    Sei $ \mathcal{H}' \in \textit{DER} _ \mathcal{C} (\langle \texttt{skip}, \sigma \rangle \rightarrow \sigma'') $ beliebig.
					    
					    Da es nur eine Regel gibt, welche $ \texttt{skip} $ enthält, muss $ \mathcal{H}' = \text{rsk}((\langle \texttt{skip}, \sigma \rangle \rightarrow \sigma), ()) $ gelten. Durch $ \mathcal{H}' \in \textit{DER} _ \mathcal{C} (\langle \texttt{skip}, \sigma \rangle \rightarrow \sigma'') $ gilt somit $ \sigma = \sigma'' $.
					    
					    Damit folgt aus $ \sigma = \sigma' $, dass auch $ \sigma' = \sigma'' $ gilt.
				    % end
				    
				    \subparagraph{Fall \enquote{r:=}}
					    Es ist zu zeigen, dass $ \forall \sigma ^ * \in \Sigma : \forall X \in \textit{Var} : \forall a \in \textit{AExp} : \forall n \in \textit{Num} : \forall \mathcal{H} _ 1 \in \textit{DER} _ \mathcal{A} : (\langle a, \sigma ^ * \rangle \Downarrow n) : P(\text{r:=}((\langle X \coloneqq a, \sigma ^ * \rangle \rightarrow \sigma ^ * [X \backslash n]), (\mathcal{H} _ 1))) $ gilt.
					    
					    Seien $ \sigma ^ *, \sigma, \sigma', \sigma'' \in \Sigma $, $ X \in \textit{Var} $, $ a \in \textit{AExp} $, $ n \in \textit{Num} $ und $ \mathcal{H} _ 1 \in \textit{DER} _ \mathcal{A} (\langle a, \sigma ^ * \rangle \Downarrow n) $ beliebig, sodass $ \text{r:=}((\langle X \coloneqq a, \sigma ^ * \rangle \rightarrow \sigma ^ * [X \backslash n]), (\mathcal{H} _ 1)) \in \textit{DER} _ \mathcal{C} (\langle c, \sigma \rangle \rightarrow \sigma') $ gilt.
					    
					    Somit muss $ c = (A \coloneqq a) $, $ \sigma = \sigma ^ * $ und $ \sigma' = \sigma ^ * [X \backslash n] $ gelten.
					    
					    Es ist noch zu zeigen, dass $ \forall \mathcal{H}' \in \textit{DER} _ \mathcal{C} (\langle A \coloneqq a, \sigma \rangle \rightarrow \sigma'') $ gilt.
					    
					    Da es nur eine Regel gibt, welche $ A \coloneqq a $ enthält, muss $ \mathcal{H}' = \text{r:=}((\langle A \coloneqq a, \sigma \rangle \rightarrow \sigma''), (\mathcal{H} _ 1 ')) $ gelten, wobei $ \mathcal{H} _ 1 ' \in \textit{DER} _ \mathcal{A} (\langle a, \sigma \rangle \Downarrow m) $. Durch $ \mathcal{H}' \in \textit{DER} _ \mathcal{C} (\langle A \coloneqq a, \sigma \rangle \rightarrow \sigma'') $ gilt somit $ \sigma'' = \sigma[X \backslash m] $.
					    
					    Da die Auswertung von Ausdrücken in \textit{AExp} deterministisch ist, gilt $ n = m $.
					    
					    Damit folgt aus $ \sigma = \sigma ^ * $, dass $ \sigma'' = \sigma ^ * [X \backslash n] = \sigma' $, dass auch $ \sigma' = \sigma'' $ gilt.
				    % end
				    
				    \subparagraph{Fall \enquote{r;}}
					    Es ist zu zeigen, dass $ \forall \sigma ^ *, \sigma ^ {*'}, \sigma ^ {*''} \in \Sigma : \forall c _ 1, c _ 2 \in \textit{Com} : \forall \mathcal{H} _ 1 \in \textit{DER} _ \mathcal{C} (\langle c _ 1, \sigma ^ * \rangle \rightarrow \sigma ^ {*''}) : \forall \mathcal{H} _ 2 \in \textit{DER} _ \mathcal{C} (\langle c _ 2, \sigma ^ {*''} \rangle \rightarrow \sigma ^ {*'}) : P(\mathcal{H} _ 1) \land P(\mathcal{H} _ 2) \implies P(\text{r;}((\langle c _ 1 ; c _ 2, \sigma ^ * \rangle \rightarrow \sigma ^ {*'}), (\mathcal{H} _ 1, \mathcal{H} _ 2))) $ gilt.
					    
					    Seien $ \sigma ^ *, \sigma ^ {*'}, \sigma ^ {*''}, \sigma, \sigma', \sigma'' \in \Sigma $, $ c _ 1, c _ 2, c \in \textit{Com} $, $ \mathcal{H} _ 1 \in \textit{DER} _ \mathcal{C} (\langle c _ 1, \sigma ^ * \rangle \rightarrow \sigma ^ {*''}) $, $ \mathcal{H} _ 2 \in \textit{DER} _ \mathcal{C} (\langle c _ 2, \sigma ^ {*''} \rangle \rightarrow \sigma ^ {*'}) $ beliebig, sodass $ \text{r;}((\langle c _ 1 ; c _ 2, \sigma ^ * \rightarrow \sigma ^ {*'}), (\mathcal{H} _ 1, \mathcal{H} _ 2)) \in \textit{DER} _ \mathcal{C} (\langle c, \sigma \rangle \rightarrow \sigma') $ und $ P(\mathcal{H} _ 1) $ und $ P(\mathcal{H} _ 2) $ gelten.
					    
					    Somit muss $ c = (c _ 1 ; c _ 2) $, $ \sigma = \sigma ^ * $ und $ \sigma' = \sigma ^ {*'} $ gelten.
					    
					    Es ist noch zu zeigen, dass $ \forall \mathcal{H}' \in \textit{DER} _ \mathcal{C} (\langle c _ 1 ; c _ 2, \sigma \rangle \rightarrow \sigma') $ gilt.
					    
					    Da die Komposition zweier Ausdrücke nur in einer Regel vorkommt, muss $ \mathcal{H}' = \text{r;}((\langle c _ 1 ; c _ 2, \sigma \rangle \rightarrow \sigma'), (\mathcal{H} _ 1 ', \mathcal{H} _ 2 ')) $ mit $ \mathcal{H} _ 1 ' \in \textit{DER} _ \mathcal{C} (\langle c _ 1, \sigma \rangle \rightarrow \sigma''') $ und $ \mathcal{H} _ 2 ' \in \textit{DER} _ \mathcal{C} (\langle c _ 2, \sigma''' \rangle \rightarrow \sigma'') $ gelten für ein $ \sigma''' \in \Sigma $.
					    
					    Aus $ P(\mathcal{H} _ 1) $, $ \mathcal{H} _ 1 \in \textit{DER} _ \mathcal{C} (\langle c _ 1 ^ *, \sigma ^ * \rangle \rightarrow \sigma ^ {*''}) $, $ \mathcal{H} _ 1 ' \in \textit{DER} _ \mathcal{C} (\langle c _ 1 ^ *, \sigma \rangle \rightarrow \sigma''') $ und $ \sigma ^ * = \sigma $ folgt, dass $ \sigma''' = \sigma ^ {*''} $.
					    
					    Aus $ P(\mathcal{H} _ 2) $, $ \mathcal{H} _ 2 \in \textit{DER} _ \mathcal{C} (\langle c _ 2 ^ *, \sigma ^ {*''} \rangle \rightarrow \sigma ^ {*'}) $, $ \mathcal{H} _ 2 ' \in \textit{DER} _ \mathcal{C} (\langle c _ 2 ^ *, \sigma''' \rangle \rightarrow \sigma'' ) $ und  $ \sigma ^ {*''} = \sigma''' $ folgt, dass $ \sigma ^ {*'} = \sigma'' $.
					    
					    Da $ \sigma ^ {*'} = \sigma' $, gilt $ \sigma' = \sigma'' $.
				    % end
				    
				    \subparagraph{Fall \enquote{rift}}
					    Analog \dots
				    % end
				    
				    \subparagraph{Fall \enquote{riff}}
					    Analog \dots
				    % end
				    
				    \subparagraph{Fall \enquote{rwht}}
					    Es ist zu zeigen, dass $ \forall \sigma ^ *, \sigma ^ {*'}, \sigma ^ {*''} \in \Sigma : \forall b \in \textit{BExp} : \forall c ^ * \in \textit{Com} : \forall \mathcal{H} _ 1 \in \textit{DER} _ \mathcal{B} (\langle b, \sigma \rangle \Downarrow \texttt{true}) : \forall \mathcal{H} _ 2 \in \textit{DER} _ \mathcal{C} (\langle c, \sigma ^ * \rangle \rightarrow \sigma ^ {*''}) : \forall \mathcal{H} _ 3 \in \textit{DER} _ \mathcal{C} (\langle \texttt{while } b \texttt{ do } c \texttt{ od}, \sigma ^ {*''} \rangle \rightarrow \sigma ^ {*'}) : P(\mathcal{H} _ 2) \land P(\mathcal{H} _ 3) \implies P(\text{rwht})((\langle \texttt{while } b \texttt{ do } c \texttt{ od}, \sigma ^ * \rangle \rightarrow \sigma ^ {*'}), (\mathcal{H} _ 1, \mathcal{H} _ 2, \mathcal{H} _ 3)) $ gilt.
					    
					    Seien $ \sigma ^ *, \sigma ^ {*'}, \sigma ^ {*''}, \sigma, \sigma', \sigma'' \in \Sigma $, $ b \in \textit{BExp} $, $ c ^ *, c \in \textit{Com} $, $ \mathcal{H} _ 1 \in \textit{DER} _ \mathcal{B} (\langle b, \sigma \rangle \Downarrow \texttt{true}) $, $ \mathcal{H} _ 2 \in \textit{DER} _ \mathcal{C} (\langle c, \sigma ^ * \rangle \rightarrow \sigma ^ {*''}) $ und $ \mathcal{H} _ 3 \in \textit{DER} _ \mathcal{C} (\langle \texttt{while } b \texttt{ do } c \texttt{ od}, \sigma ^ {*''} \rangle \rightarrow \sigma ^ {*'}) $ beliebig, sodass $ \text{rwht}((\langle \texttt{while } b \texttt{ do } c \texttt{ od}, \sigma ^ * \rangle \rightarrow \sigma ^ {*'}), (\mathcal{H} _ 1, \mathcal{H} _ 2, \mathcal{H} _ 3)) \in \textit{DER} _ \mathcal{C} (\langle c, \sigma \rangle \rightarrow \sigma') $, $ P(\mathcal{H} _ 1) $ und $ P(\mathcal{H} _ 2) $ gelten.
					    
					    Somit muss $ c = (\texttt{while } b \texttt{ do } c \texttt{ od}) $, $ \sigma = \sigma ^ * $ und $ \sigma' = \sigma ^ {*'} $ gelten.
					    
					    Es ist noch zu zeigen, dass $ \forall \mathcal{H}' \in \textit{DER} _ \mathcal{C} (\langle \texttt{while } b \texttt{ do } c ^ * \texttt{ od}, \sigma \rangle \rightarrow \sigma'') $ gilt.
					    
					    Da die Auswertung von Ausdrücken in \textit{BExp} deterministisch ist, ist $ \langle b, \sigma \rangle \Downarrow \texttt{false} $ nicht herleitbar. Somit muss $ \mathcal{H}' = \text{rwht}((\langle \texttt{while } b \texttt{ do } c \texttt{ od}), (\mathcal{H} _ 1 ', \mathcal{H} _ 2 ', \mathcal{H} _ 3 '), \sigma \rangle \rightarrow \sigma') $ gelten, wobei $ \mathcal{H} _ 1 ' \in \textit{DER} _ \mathcal{B} (\langle b, \sigma \rangle \Downarrow \texttt{true}) $, $ \mathcal{H} _ 2 ' \in \textit{DER} _ \mathcal{C} (\langle c, \sigma \rangle \rightarrow \sigma''') $ und $ \mathcal{H} _ 3 ' \in \textit{DER} _ \mathcal{C} (\langle \texttt{while } b \texttt{ do } c \texttt{ od}, \sigma''' \rangle \rightarrow \sigma'') $ für ein $ \sigma''' \in \Sigma $.
					    
					    Aus $ P(\mathcal{H} _ 2) $, $ \mathcal{H} _ 2 \in \textit{DER} _ \mathcal{C} (\langle c, \sigma ^ * \rangle \rightarrow \sigma ^ {*''}) $, $ \mathcal{H} _ 2 ' \in \textit{DER} _ \mathcal{C} (\langle c, \sigma \rangle \rightarrow \sigma''') $ und $ \sigma = \sigma ^ * $ folgt, dass $ \sigma''' = \sigma ^ {*''} $.
					    
					    Aus $ P(\mathcal{H} _ 3) $, $ \mathcal{H} _ 3 \in \textit{DER} _ \mathcal{C} (\langle \texttt{while } b \texttt{ do } c \texttt{ od}, \sigma ^ {*''} \rangle \rightarrow \sigma ^ {*'}) $, $ \mathcal{H} _ 3 ' \in \textit{DER} _ \mathcal{C} (\langle \texttt{while } b \texttt{ do } c \texttt{ od}, \sigma''' \rangle \rightarrow \sigma'') $ und $ \sigma''' = \sigma ^ {*''} $ folgt, dass $ \sigma'' = \sigma ^ {*'} $.
					    
					    Da $ \sigma ^ {*'} = \sigma' $, gilt $ \sigma' = \sigma'' $.
				    % end
				    
				    \subparagraph{Fall \enquote{rwhf}}
					    Analog \dots
				    % end
				    
				    Somit gilt $ \forall \mathcal{H} \in \textit{DER} _ \mathcal{C} : P(\mathcal{H}) $.
				    
				    \qed
			    % end
		    % end
	    % end
	    
	    \section{Kalküle als Spezifikationssprache}
		    \subsection{Induktiv definierte Mengen}
			    Ein Kalkül $ \mathcal{K} $ definiert induktiv die Menge $ I _ \mathcal{K} \coloneqq \{ \xi \forwhich \Vdash _ \mathcal{K} \xi \} $.
			    
			    In den folgenden Abschnitten werden weitete Möglichkeiten aufgezeigt, wie die Menge $ I _ \mathcal{K} $ charakterisiert werden kann:
			    \begin{itemize}
			    	\item als Menge aller Instanzen eines Urteils, welche in $ \mathcal{K} $ herleitbar sind,
			    	\item als Schnittmenge aller unter $ \mathcal{K} $ abgeschlossenen Mengen und
			    	\item als Ergebnis der Anwendung des Hüllenoperators $ R _ \mathcal{K} ^ * $ auf $ \emptyset $.
			    \end{itemize}
		    % end
		    
		    \subsection{Operatoren}
			    \definition{Operatoren}{
			    	Sei $ \mathcal{K} $ ein Kalkül zur Herleitung von Instanzen eines Urteils.
			    	
			    	Die Operatoren $ \hat{R} _ \mathcal{K} $, $ \hat{R} _ \mathcal{K} ^ i $, $ \overline{R} _ \mathcal{K} $ und $ R _ \mathcal{K} ^ * $ auf Mengen von Instanzen dieses Urteils werden wie folgt durch $ \mathcal{K} $ spezifiziert:
			    	\begin{align*}
				    	\hat{R} _ \mathcal{K} (Q) \coloneqq&\, \{ \xi \forwhich \exists \xi _ 1, \cdots, \xi _ n : \exists \text{r-name} : (\text{r-name}(\xi, (\xi _ 1, \cdots, \xi _ n)) \in \text{RTerme}(\text{r-name}) \land \{ \xi _ 1, \cdots, \xi _ n \} \subseteq Q) \} \\
				    	\overline{R} _ \mathcal{K} (Q) \coloneqq&\, Q \cup \{ \xi \forwhich \exists \xi _ 1, \cdots, \xi _ n : \exists \text{r-name} : (\text{r-name}(\xi, (\xi _ 1, \cdots, \xi _ n)) \in \text{RTerme}(\text{r-name}) \land \{ \xi _ 1, \cdots, \xi _ n \} \subseteq Q) \} \\
				    	=&\, Q \cup \hat{R} _ \mathcal{K} (Q) \\
				    	\hat{R} _ \mathcal{K} ^ 0 (Q) \coloneqq&\, Q \\
				    	\hat{R} _ \mathcal{K} ^ {i + 1} (Q) \coloneqq&\, \hat{R} _ \mathcal{K}(\hat{R} _ \mathcal{K} ^ i (Q)) \\
				    	R _ \mathcal{K} ^ * (Q) \coloneqq&\, \bigcup _ { i \in \mathbb{N} _ 0 } \hat{R} _ \mathcal{K} ^ i (Q) \\
			    	\end{align*}
			    	
			    	Ergibt sich der Kalkül aus dem Kontext, kann das tiefgestellte $ \mathcal{K} $ fallen gelassen werden.
			    }
		    
			    \theorem{$ \hat{R} _ \mathcal{K} $ und $ \overline{R} _ \mathcal{K} $ sind monoton.}
			    
			    \theorem{$ \overline{R} _ \mathcal{K} $ ist extensiv.}
		    
			    \theorem{$ R _ \mathcal{K} ^ * $ ist ein Hüllenoperator.}
			    
			    \theorem{Es gilt $ R _ \mathcal{K} ^ * (\emptyset) = I _ \mathcal{K} $.}
		    % end
		    
		    \subsection{Abschlusseigenschaften}
			    \definition{Abgeschlossenheit unter Regeln}{
				    Eine Kalkülregel
				    \begin{equation*}
					    \prftree[l, r]
						    { $ \Phi _ 1, \cdots, \Phi _ m $ }
						    { r-name }
						    { \zeta _ 1, \cdots, \zeta _ n }
						    { \zeta }
				    \end{equation*}
				    definiert für eine Menge $ Q $ die Eigenschaft
				    \begin{equation*}
					    \forall \eta : (\Phi _ 1 \eta \land \cdots \land \Phi _ m \eta \land \{ \zeta _ 1 \eta, \cdots, \zeta _ m \eta \} \subseteq Q) \implies \zeta\eta \in Q
				    \end{equation*}
				    
				    Eine Menge $ Q $ heißt \textit{abgeschlossen unter r-name} gdw. obige Formel für $ Q $ erfüllt ist.
			    }
			    
			    \definition{Abgeschlossenheit unter Kalkül}{
			    	Sei $ \mathcal{K} $ ein Kalkül zur Herleitung von Instanzen eines Urteils.
			    	
			    	Eine Menge $ Q $ ist \textit{abgeschlossen unter $ \mathcal{K} $} (\enquote{$ Q $ ist $ \mathcal{K} $-abgeschlossen}) gdw. $ Q $ unter jeder Kalkülregel in $ \mathcal{K} $ abgeschlossen ist.
			    }
			    
			    \theorem{
				    Sei $ \mathcal{K} $ ein Kalkül zur Herleitung von Instanzen eines Urteils.
				    
				    Eine Menge $ Q $ von Instanzen dieses Urteils ist unter $ \mathcal{K} $ abgeschlossen gdw. $ \hat{R} _ \mathcal{K} (Q) \subseteq Q $.
			    }
			    
			    \definition{Abschlusseigenschaft}{Sei $ M $ eine Menge. Eine einstellige Relation $ P $ auf $ \mathcal{P}(M) $ heißt Abschlusseigenschaft gdw. $ \forall Q \subseteq M : \exists Q' \subseteq M : (Q \subseteq Q' \land P(Q')) $}
			    
			    \theorem{
				    Die durch ein Kalkül $ \mathcal{K} $ für eine Menge $ Q $ spezifizierte Eigenschaft \enquote{$ Q $ ist abgeschlossen unter $ \mathcal{K} $} ist eine Abschlusseigenschaft.
				}
		    
			    \theorem{
				    Sei $ \mathcal{K} $ ein Kalkül zur Herleitung von Instanzen eines Urteils.
				    \begin{itemize}
				    	\item Die Menge $ I _ \mathcal{K} $ ist $ \mathcal{K} $-abgeschlossen.
				    	\item Wenn $ Q $ unter $ \mathcal{K} $ abgeschlossen ist, dann gilt $ I _ \mathcal{K} \subseteq Q $.
				    	\item $ \bigcap \{ Q \forwhich Q \text{ ist abgeschlossen unter } \mathcal{K} \} = I _ \mathcal{K} $
				    \end{itemize}
			    }
		    % end
	    % end
    % end
    
    \chapter{Formale Modellierung in der Softwareentwicklung}
	    Siehe SE Zusammenfassung (\url{https://www.dmken.com/redmine/documents/12}).
	    
	    \section{Formale Modellierung}
		    \subsection{Spezifikationssprachen}
			    \begin{description}
			    	\item[Spezifikationssprache] Formale Notation zur Spezifikation von Modellen
			    	\item[Syntax] Ausdrücke, welche als Spezifikation zulässig sind
			    	\item[Spezifikation] Modell oder eine Menge von Modellen
			    	\item[Semantik] Welches Modell/welche Modelle eine Spezifikation beschreibt \\ Abbildung in die Sprache der Mathematik
			    	\item[Beispiele] Use Cases, Aktionsdiagramme, Klassendiagramme, \dots
			    \end{description}
			    
			    Eine Spezifikation heißt inkonsistent, wenn die die leere Menge von Modellen beschreibt.
			    
			    \subsubsection{Klassen von Spezifikationssprachen}
				    Die Syntax ist in beiden Klassen (formal und semi-formal) eine formale Notation. Die Klassen unterscheiden sich nur in ihrer Semantik.
				    \begin{description}
				    	\item[Formal] Für jeden gültigen Ausdruck ist die Semantik eindeutig spezifiziert.
					    	\begin{itemize}
					    		\item Selektive Einsetzung bei bspw. sehr kritischen Komponenten
					    		\item Auch für die Entwicklungsdokumentation
					    	\end{itemize}
				    	\item[Semi-Formal] Es gibt gültige Ausdrücke, für die die Semantik nicht eindeutig spezifiziert ist (Interpretationspielraum).
					    	\begin{itemize}
					    		\item Einsetzbar für weniger kritische Komponenten
					    		\item Bei unkritischen Komponenten sind auch informelle Beschreibungen in Ordnung
					    	\end{itemize}
				    \end{description}
			    % end
		    % end
		    
		    \subsection{Einsatz}
			    \subsubsection{Formale Spezifikation der Anforderungen}
				    \begin{itemize}
				    	\item Kommunikation zwischen Auftraggebern und Entwicklern
				    	\item Vermeidung von Missverständnissen
				    \end{itemize}
			    % end
			    
			    \subsubsection{Formale Spezifikation während der Entwicklung}
				    \begin{itemize}
				    	\item Kommunikation zwischen den Entwicklern
				    	\item Vermeidung von Missverständnissen
				    	\item Generierung von Programmteilen (bspw. Tests) aus Spezifikation ist möglich
				    \end{itemize}
			    % end
			    
			    \subsubsection{Formale Verifikation}
				    \begin{itemize}
				    	\item Überprüfung von Systemeigenschaften (bspw. auf Sicherheit)
				    	\item Fehlervermeidung durch mathematische Beweise
				    \end{itemize}
			    % end
		    % end
	    % end
	    
	    \section{Formale Softwareentwicklung}
		    Um Software vollständig formal zu Entwickeln gibt es zwei Ansätze, beide haben dabei den selben Startpunkt und das gleiche Ziel.
		    \begin{itemize}
		    	\item Transformationsbasierter Ansatz
			    	\begin{description}
			    		\item[Startpunkt] Formale Spezifikation der Anforderungen
			    		\item[Entwicklung] Die Spezifikation wird durch Anwendung von Transformationen schrittweise modifiziert, wobei relevante Teile erhalten bleiben
			    		\item[Zielpunkt] Spezifikation, welche einem Programm entspricht
			    	\end{description}
		    	\item Erfinde-und-Verifiziere Ansatz
			    	\begin{description}
			    		\item[Startpunkt] Formale Spezifikation der Anforderungen
			    		\item[Entwicklung] Erfindung einer neuen Spezifikation und Verifikation, dass alle relevanten Teile vorhanden sind
			    		\item[Zielpunkt] Spezifikation, welche dem Programm entspricht
			    	\end{description}
		    \end{itemize}
	    % end
	    
	    \section{Formale Verifikation}
		    \begin{itemize}
		    	\item Bedingungen
			    	\begin{itemize}
			    		\item Kalküle zur mathematischen Beweisführung (bspw. Hoare-Logik, Refinement Calculus, \dots)
			    	\end{itemize}
			    \item Erleichterungen
				    \begin{itemize}
				    	\item Automatisierung der Beweisprüfung (Ist der Beweis korrekt?)
				    	\item Automatisierung der Beweissucher (automatische oder halbautomatische Theorembeweiser)
				    \end{itemize}
		    \end{itemize}
	    
		    \subsection{Einsatzmöglichkeiten formaler Verifikation}
			    \begin{itemize}
			    	\item Codeebene (sowohl in Programmier- als auch Maschinensprachen)
				    \item Modellebene
					    \begin{itemize}
					    	\item Nachweis, dass ein Modell gegebene Eigenschaften erfüllt
					    	\item Nachweis, dass Modele in einer gegebenen Beziehung zueinander stehen
					    \end{itemize}
			    \end{itemize}
		    % end
		    
		    \subsection{Beispiel: Verifikation auf Codeebene (Hoare-Logik)}
			    Hoare-Tripel: $ \{ P \} \quad C \quad \{ Q \} $
			    \begin{description}
			    	\item[$ P $] Vorbedingung (prädikatenlogische Formel)
			    	\item[$ C $] Programm (imperative Programmiersprache)
			    	\item[$ Q $] Nachbedingung (prädikatenlogische Formel)
			    \end{description}
			    
			    \paragraph{Beispiele}
				    \begin{itemize}
				    	\item Gilt $ \{ x = 11 \} \quad x \coloneqq (x \oplus 2) \quad \{ x = 13 \} $ ?
				    	\item Gilt $ \{ x > y \} \quad \texttt{while } (x \texttt{ leq } 0) \texttt{ do } x \coloneqq (x \ominus 1) \texttt{ od} \quad \{ x > y \} $ ?
				    	\item Gilt $ \{ x < y, y > 0 \} \quad \texttt{while } (x \texttt{leq} 0) \texttt{ do } x \coloneqq (x \oplus 1) \texttt{ od} \quad \{ x > y \} $ ?
				    \end{itemize}
			    % end
		    % end
	    % end
    % end
    
    \chapter{Verhaltensorientierte Modellierung}
	    Erinnerung: Modelle sind absichtlich nicht originalgetreu, sondern heben bestimmte Aspekte der Realität hervor, beispielsweise die Daten, die Architektur oder das Verhalten des Systems. Die verhaltensorientierte Modellierung beschäftigt sich mit dem Hervorheben des Verhaltens der Realität/des Modells.
    
	    \section{Komponenten}
		    Bei der verhaltensorientierten Modellierung wird zwischen folgenden, grundlegenden Komponenten unterschieden (diese werden in den folgenden Abschnitten näher erläutert):
		    \begin{description}
		    	\item[Zustände] Eine Momentaufnahme des Systems während der Ausführung
		    	\item[Ereignisse] Eine Gegebenheit, welche einen Zustandsübergang (Transition) auslösen kann
		    	\item[Transitionen] Ein Übergang von einem Zustand in einen anderen (wird von einem Ereignis ausgelöst)
		    	\item[Spuren und Historien] Mögliche Abläufe des Systems
		    \end{description}
		    
		    \subsection{Zustände}
				Modellierung durch eine Zustandsmenge $ S $, welche wie folgt definiert werden kann:
				\begin{itemize}
					\item Die Menge verbleibt unterspezifiziert
					\item Die Zustände werden als Symbol spezifiziert und $ S $ ist die Menge dieser Symbole
					\item Die Zustände werden durch mathematische Konzepte (bspw. Funktionen) spezifiziert und $ S $ ist die Menge dieser Konzepte
				\end{itemize}
				
				\paragraph{Beispiel}
					Sei \textit{PRODUKTE} die Menge aller Produkte eines Bewertungssystems und \[ \textit{BEWERTUNG} \coloneqq \{ 1, 2, 3, 4, 5, 6 \} \] die Menge der möglichen Bewertungen, wobei die Symbole den intuitiven Schulnoten entsprechen.
					
					Die möglichen Zustände des Bewertungssystems werden nun als Funktion $ S : \textit{PRODUKTE} \rightarrow \textit{BEWERTUNG} ^ * $ spezifiziert, wobei ein Produkt mehrfach bewertet werden kann. Eine Liste von Bewertungen kann durch $ S[\xi \backslash \zeta] $ ausgetauscht werden, wobei $ \xi \in \textit{PRODUKTE} $ und $ \zeta \in \textit{BEWERTUNG}* $.
				% end
		    % end
		    
		    \subsection{Ereignisse}
			    Modellierung durch eine Ereignismenge $ E $, welche wie folgt definiert werden kann:
			    \begin{itemize}
			    	\item Die Menge verbleibt unterspezifiziert
			    	\item Die Ereignisse werden als Symbol spezifiziert und $ S $ ist die Menge dieser Symbole
			    	\item Die Ereignisse werden durch mathematische Konzepte (bspw. Funktionen) spezifiziert und $ S $ ist die Menge dieser Konzepte
			    \end{itemize}
			    
			    \paragraph{Beispiel}
				    Seien alle Definitionen aus dem vorigen Beispiel gültig.
				    
				    Die möglichen Ereignisse eines Systems werden durch die Menge \[ E \coloneqq \{ \text{bewerte}(\xi, \Delta) \forwhich \xi \in \textit{PRODUKTE} \land \Delta \in \textit{BEWERTUNG} \} \] definiert, wobei das Ereignis $ \text{bewerte}(\xi, \Delta) $ dem Produkt $ \xi $ eine neue Bewertung $ \Delta $ hinzufügt.
			    % end
		    % end
		    
		    \subsection{Transitionen/Zustandsübergänge}
			    Transitionen können beispielsweise durch Tupel der Form $ (s, e, s') $ modelliert werden, wobei
			    \begin{description}
			    	\item[$ e \in E $] das auslösende Ereignis darstellt,
			    	\item[$ s \in S $] der Zustand vor dem Geschehen von $ e $ ist und
			    	\item[$ s' \in S $] den nächsten (nach dem Geschehen von $ e $) Zustand darstellt.
			    \end{description}
			    Diese Tupel werden in einer Menge $ \rightarrow \subseteq S \times E \times S $ gesammelt und als \enquote{Transitionsrelation} bezeichnet.
			    
			    Dabei gibt es folgende Möglichkeiten zur Spezifikation der Transitionsrelation:
			    \begin{itemize}
				    \item Die möglichen Transitionen werden explizit aufgeführt
				    \item Die Menge wird deklarativ spezifiziert
			    \end{itemize}
			    Eine unterspezifizierte Transitionsrelation ist nicht zulässig.
			    
			    \paragraph{Beispiel}
				    Seien alle Definitionen aus dem vorigen Beispiel gültig.
				    
				    Die möglichen Zuständsübergänge können folgendermaßen spezifiziert werden:
				    \begin{equation*}
					    \rightarrow\, \coloneqq \{ (S, \text{bewerte}(\xi, \Delta), S') \forwhich \xi \in \textit{PRODUKTE} \land \Delta \in \textit{BEWERTUNG} \land S' = S[\xi \backslash S(\xi).(\Delta)] \}
				    \end{equation*}
			    % end
		    % end
		    
		    \subsection{Transitionssysteme}
			    \definition{Transitionssystem}{
			    	Ein Transitionssystem ist ein Tupel $ (S, S _ 0, E, \rightarrow) $, wobei
			    	\begin{description}
			    		\item[$ S $] die Menge der Zustände,
			    		\item[$ S _ 0 \subseteq S $] die Menge der Start-/Anfangszustände,
			    		\item[$ E $] die Ereignismenge und
			    		\item[$ \rightarrow\, \subseteq S \times E \times S $] die Transitionsrelation darstellt.
			    	\end{description}
			    }
			    
			    \notation{Transitionen}{$ (s, e, s') \in \,\rightarrow \quad\iff\quad s - e \rightarrow s' $}
		    
			    \paragraph{Beispiel}
				    Seien alle Definitionen aus dem vorigen Beispiel gültig.
				    
				    Dann ergibt sich folgendes Transitionssystem $ \mathcal{T} = (S, S _ 0, E, \rightarrow) $:
				    \begin{align*}
					    S &\, \text{Siehe Beispiel \enquote{Zustände}} \\
					    S _ 0 \coloneqq&\, \textit{PRODUKTE} \times \{ () \} \tag{Alle Produkte starten ohne Bewertung} \\
					    E &\, \text{Siehe Beispiel \enquote{Ereignisse}} \\
					    \rightarrow &\, \text{Siehe Beispiel \enquote{Transitionen}} \\
				    \end{align*}
			    % end
			    
			    \subsubsection{Spuren von Transitionssystemen}
				    Sei $ \mathcal{T} = (S, S _ 0, E, \rightarrow) $ ein Transitionssystem.

				    \definition{Spuren von Transitionssystemen}{
				    	Die durch $ \mathcal{T} $ induzierte Menge von Spuren $ \text{Traces}(\mathcal{T}) \subseteq (S \cup E) ^ * $ ist die kleinste Menge, sodass
				    	\begin{equation*}
					    	\begin{cases}
						    	(s) \in \text{Traces}(\mathcal{T}) & \text{wenn } s \in S _ 0 \\
						    	t.(s, e, s') \in \text{Traces}(\mathcal{T}) & \text{wenn } t.(s) \in \text{Traces}(\mathcal{T}) \text{ und } s - e \rightarrow s'
					    	\end{cases}
				    	\end{equation*}
				    	
				    	\intuition{Intuitiv bedeutet dies, dass die Menge $ \text{Traces}(\mathcal{T}) $ alle möglichen Wege durch das Transitionssystem inklusive der Zustände und der Ereignisse enthält.}
				    }
				    
				    \definition{Ereignis-/Zustandsspuren von Transitionssystemen}{
					    Die durch $ \mathcal{T} $ induzierte Menge von Zustandsspuren $ \text{S-Traces}(\mathcal{T}) \subseteq S ^ * $ und die Menge von Ereignisspuren $ \text{E-Traces}(\mathcal{T}) \subseteq E ^ * $ sind wie folgt definiert:
					    \begin{align*}
						    \text{S-Traces}(\mathcal{T}) &\coloneqq \{ t \upharpoonright S \forwhich t \in \text{Traces}(\mathcal{T}) \} \\
						    \text{E-Traces}(\mathcal{T}) &\coloneqq \{ t \upharpoonright E \forwhich t \in \text{Traces}(\mathcal{T}) \} \\
					    \end{align*}
				    }
			    % end
			    
			    \subsubsection{Historien von Transitionssystemen}
				    Sei $ \mathcal{T} = (S, S _ 0, E, \rightarrow) $ ein Transitionssystem.
				    
				    \definition{Historien von Transitionssystemen}{
					    Die durch $ \mathcal{T} $ induzierte Menge von Historien $ \text{Hist}(\mathcal{T}) \subseteq (S \cup E) ^ \infty $ ist wie folgt definiert:
					    \begin{equation*}
						    \text{Hist}(\mathcal{T}) \coloneqq \{ h : \mathbb{N} _ 0 \rightarrow (S \cup E) \forwhich h(0) \in S _ 0 \land \forall n \in \mathbb{N} _ 0 : h(2n) - h(2n + 1) \rightarrow h(2n + 2) \}
					    \end{equation*}
					    
					    \intuition{Intuitiv bedeutet dies, dass die Menge $ \text{Hist}(\mathcal{T}) $ alle unendlichen Wege durch das Transitionssystem enthält, wobei jede Historie mit einem Startzustand startet, gefolgt von einem Ereignis, gefolgt von einem Zustand, \dots.}
				    }
				    
				    \definition{Ereignis-/Zustandshistorien von Transitionssystemen}{
				    	Die durch $ \mathcal{T} $ induzierte Menge von Zustandshistorien $ \text{S-Hist}(\mathcal{T}) \subseteq S ^ \infty $ und die Menge von Ereignishistorien $ \text{E-Hist}(\mathcal{T}) \subseteq E ^ \infty $ sind wie folgt definiert:
				    	\begin{align*}
					    	\text{S-Hist}(\mathcal{T}) &\coloneqq \{ h : \mathbb{N} _ 0 \rightarrow S \forwhich \exists h' \in \text{Hist}(\mathcal{T}) : \forall n \in \mathbb{N} _ 0 : h(n) = h'(2n) \} \\
					    	\text{E-Hist}(\mathcal{T}) &\coloneqq \{ h : \mathbb{N} _ 0 \rightarrow S \forwhich \exists h' \in \text{Hist}(\mathcal{T}) : \forall n \in \mathbb{N} _ 0 : h(n) = h'(2n + 1) \} \\
				    	\end{align*}
				    }
				% end
		    % end
		    
		    \subsection{Spuren}
			    \definition{Spur}{
			    	Eine Spur ist eine endliche Folge von Zuständen und Ereignissen.
			    	
			    	Enthält die Spur nur Ereignisse, so heißt sie Ereignisspur. \\
			    	Enthält die Spur nur Zustände, so heißt sie Zustandsspur.
			    }
			    
			    \definition{Konkatentation}{
			    	Die Konkatenation von zwei Spuren $ t _ 1, t _ 2 \in (S \cup E) ^ * $ ist die wie folgt definierte Spur $ t _ 1 . t _ 2 \in (S \cup E) ^ * $:
			    	\begin{equation*}
				    	t _ 1 . t _ 2 \coloneqq \begin{cases}
					    	t _ 1 & \text{wenn } t _ 2 = () \\
					    	(t _ 1 . t _ 2, q) & \text{wenn } t _ 2 = (t _ 2 ', q)
				    	\end{cases}
			    	\end{equation*}
			    }
			    
			    \definition{Projektion}{
			    	Die Projektion einer Spur $ t \in (S \cup E) ^ * $ nach einer Menge $ Q \subseteq S \cup E $ ist die wie folgt definierte Spur:
			    	\begin{equation*}
				    	t \upharpoonright Q \coloneqq \begin{cases}
					    	() & \text{wenn } t = () \\
					    	(t' \upharpoonright Q, q) & \text{wenn } t = t'.(q) \text{ und } q \in Q \\
					    	t' \upharpoonright Q & \text{wenn } t = t'.(q) \text{ und } q \not\in Q \\
				    	\end{cases}
			    	\end{equation*}
			    	
			    	\intuition{Intuitiv bedeutet dies, dass die Projektion eine Teilspur aus $ t $ extrahiert mit den Elementen, welche in $ Q $ vorhanden sind (in der Reihenfolge, in der sie in $ t $ vorkommen). Dies kann beispielsweise mit $ Q = E $ dazu genutzt werden, eine beliebige Spur in eine Ereignisspur umzuwandeln. Warnung: Hierbei können wichtige Daten verloren gehen.}
			    }
			    
			    \definition{Präfix}{
				    Eine Spur $ t' $ heißt Präfix einer Spur $ t $ gdw. es eine Spur $ t'' $ gibt, sodass $ t = t' . t'' $ gilt.
				    Notation: $ t' \leq t \iff t' \text{ ist Präfix von } t $
			    }
			    
			    \definition{Verschachtlungsmenge}{
			    	Seien $ t, u \in E ^ * \cup (E ^ * \times \{ \surd \}) $ zwei Spuren.
			    	
			    	Die Menge der Verschachtlungen $ \text{Interleaving}(t, u) $ von $ t $ und $ u $ ist wie folgt rekursiv definiert (in der Definition als \enquote{IV} abgekürzt):
			    	\begin{align*}
				    	\text{IV}(t, u) &\coloneqq \begin{cases}
					    	\{ t \} & \text{falls } u = () \\
					    	\{ u \} & \text{falls } t = () \\
					    	\{ (x).s \forwhich s \in \text{IV}(t', u) \} \cup \{ (y).s \forwhich s \in \text{IV}(t, u') \} & \text{falls } t = (x).t' \land u = (y).u' \\
				    	\end{cases}
			    	\end{align*}
			    }
			    
			    \paragraph{Beispiel}
				    \subparagraph{Spur}
					    Die Spur
					    \begin{align*}
						    ( & \{ (\text{HANDY}, ()), (\text{LAPTOP}, ()) \}, \\
						      & \text{bewerte}(\text{HANDY}, 2), \\
						      & \{ (\text{HANDY}, (2)), (\text{LAPTOP}, ()) \}, \\
						      & \text{bewerte}(\text{LAPTOP}, 5), \\
						      & \{ (\text{HANDY}, (2)), (\text{LAPTOP}, (5)) \}, \\
						      & \text{bewerte}(\text{HANDY}, 4) \\
						      & \{ (\text{HANDY}, (2, 4)), (\text{LAPTOP}, (5)) \} )
					    \end{align*}
					    ist wie folgt zu interpretieren:
					    \begin{enumerate}
					    	\item Das System startet im Anfangszustand.
					    	\item Es wird eine Bewertung $ 2 $ zum Produkt \enquote{HANDY} hinzugefügt, an dem Produkt \enquote{LAPTOP} wird nichts geändert.
					    	\item Es wird eine Bewertung $ 5 $ zum Produkt \enquote{LAPTOP} hinzugefügt, an dem Produkt \enquote{HANDY} wird nichts geändert.
					    	\item Es wird eine Bewertung $ 4 $ zum Produkt \enquote{HANDY} hinzugefügt, an dem Produkt \enquote{LAPTOP} wird nichts geändert.
					    \end{enumerate}
					% end

					\subparagraph{Ereignisspur}
					    Die Ereignisspur
					    \begin{align*}
						    ( & \text{bewerte}(\text{HANDY}, 2), \\
						      & \text{bewerte}(\text{LAPTOP}, 5), \\
						      & \text{bewerte}(\text{HANDY}, 4) )
					    \end{align*}
					    ist wie folgt zu interpretieren:
					    \begin{enumerate}
					    	\item Ein Nutzer bewertet das Produkt \enquote{HANDY} mit einer $ 2 $.
					    	\item Ein Nutzer bewertet das Produkt \enquote{LAPTOP} mit einer $ 5 $.
					    	\item Ein Nutzer bewertet das Produkt \enquote{HANDY} mit einer $ 4 $.
					    \end{enumerate}
					% end
				    
				    \subparagraph{Zustandsspur}
					    Die Zustandsspur
					    \begin{align*}
						    ( & \{ (\text{HANDY}, ()), (\text{LAPTOP}, ()) \}, \\
						      & \{ (\text{HANDY}, (2)), (\text{LAPTOP}, ()) \}, \\
						      & \{ (\text{HANDY}, (2)), (\text{LAPTOP}, (5)) \}, \\
						      & \{ (\text{HANDY}, (2, 4)), (\text{LAPTOP}, (5)) \} )
					    \end{align*}
					    ist wie folgt zu interpretieren:
					    \begin{enumerate}
					    	\item Das System startet im Anfangszustand.
					    	\item Es wird eine Bewertung $ 2 $ zum Produkt \enquote{HANDY} hinzugefügt.
					    	\item Es wird eine Bewertung $ 5 $ zum Produkt \enquote{LAPTOP} hinzugefügt.
					    	\item Es wird eine Bewertung $ 4 $ zum Produkt \enquote{HANDY} hinzugefügt.
					    \end{enumerate}
					% end
			    % end
		    % end
		    
		    \subsection{Historien}
			    \definition{Historie}{
			    	Eine Historie ist eine unendliche Folge von Ereignissen und Zuständen. Historien können zur Modellierung von nicht-terminierenden Ausführungen und zur Modellierung von terminierenden Ausführungen eingesetzt werden.
			    	
			    	Enthält die Historie nur Ereignisse, so heißt sie Ereignishistorie. \\
			    	Enthält die Historie nur Zustände, so heißt sie Zustandshistorie.
			    }
			    
			    \definition{Terminierende Historien}{
			    	Der Haupteinsatz von Historien ist die Modellierung von Modellen, welche nicht Terminieren.
			    	
			    	Durch die Einführung eines Ereignisses $ \surd $ ist es möglich, auch terminierende Modell zu spezifizieren:
			    	\begin{itemize}
			    		\item Das Ereignis $ \surd $ modelliert die Terminierung einer Ausführung.
			    		\item Tritt $ \surd $ zum ersten Mal an einer Stelle $ n $ auf ($ \textit{hist}(n) = \surd $), so gilt für alle $ n' > n $, dass $ \textit{hist}(n') = \textit{hist}(n' - 1) $, beziehungsweise $ \textit{hist}(n') = \surd $. Somit ist der letzte Zustand der Historie an der Stelle $ n - 1 $, welcher unverändert bleibt.
			    	\end{itemize}
			    }
		    % end
	    % end
	    
	    \section{Modulare Modellierung}
		    Mit der Modellierung von nebenläufigen Komponenten ist eine modulare Modellierung möglich, wodurch
		    \begin{itemize}
		    	\item das Modell strukturiert und
		    	\item die Komplexität des Modellierens reduziert wird.
		    \end{itemize}
		    Hierzu ist eine Definition der Komposition von Modellen nötig und es muss klar definiert sein, wann die Komposition zweier angemessener Modelle wiederum ein angemessenes Modell ergibt.
	    
		    Varianten nebenläufiger Ausführung:
		    \begin{description}
		    	\item[Synchrone Ausführung] Die Systemkomponenten führen gleichzeitig einen Berechnungsschritt durch.
		    	\item[Asynchrone Ausführung] Die Systemkomponenten führen unabhängig voneinander ihre Berechnungsschritte durch.
		    \end{description}
	    
		    \subsection{Ausführung ohne Kommunikation (Produktkomposition)}
				Dieser Abschnitt beschäftigt sich mit der Produktkomposition zweier nebenläufiger Komponenten, welche genutzt werden kann, wenn die Komponenten nicht miteinander kommunizieren.

				Seien $ \mathcal{T} ^ 1 = (S ^ 1, S _ 0 ^ 1, E ^ 1, \rightarrow ^ 1) $ und $ \mathcal{T} ^ 2 = (S ^ 2, S _ 0 ^ 2, E ^ 2, \rightarrow ^ 2) $ zwei Transitionssysteme.

			    \subsubsection{Synchrone Produktkomposition}
				    \definition{Synchrone Produktkomposition}{
				    	Die synchrone Produktkomposition von $ \mathcal{T} ^ 1 $ und $ \mathcal{T} ^ 2 $ ergibt das Transitionssystem $ \mathcal{T} = (S, S _ 0, E, \rightarrow) $, wobei
				    	\begin{align*}
					    	S &\coloneqq S ^ 1 \times S ^ 2 \\
					    	S _ 0 &\coloneqq S _ 0 ^ 1 \times S _ 0 ^ 2 \\
					    	E &\coloneqq E ^ 1 \times E ^ 2 \\
					    	\rightarrow\, &\coloneqq \{ ((s _ 1, s _ 2), (e _ 1, e _ 2), (s _ 1 ', s _ 2 ')) \in S \times E \times S \forwhich (s _ 1, e _ 1, s _ 1 ') \in \rightarrow ^ 1 \land (s _ 2, e _ 2, s _ 2 ') \in \rightarrow ^ 2 \} \\
				    	\end{align*}
				    	
				    	\intuition{Damit $ \mathcal{T} $ einen Schritt machen kann, müssen $ \mathcal{T} ^ 1 $ und $ \mathcal{T} ^ 2 $ jeweils einen Schritt machen.}
				    }
			    % end
			    
			    \subsubsection{Asynchrone Produktkomposition}
				    \definition{Asynchrone Produktkomposition}{
				    	Die asynchrone Produktkomposition von $ \mathcal{T} ^ 1 $ und $ \mathcal{T} ^ 2 $ ergibt das Transitionssystem $ \mathcal{T} = (S, S _ 0, E, \rightarrow) $, wobei
				    	\begin{align*}
					    	S &\coloneqq S ^ 1 \times S ^ 2 \\
					    	S _ 0 &\coloneqq S _ 0 ^ 1 \times S _ 0 ^ 2 \\
					    	E &\coloneqq E ^ 1 \cup E ^ 2 \\
					    	\rightarrow\, &\coloneqq \{ ((s _ 1, s _ 2), e, (s _ 1 ', s _ 2 ')) \in S \times E \times S \\
					    	& \quad\quad\quad\quad \forwhich ((s _ 1, e, s _ 1 ') \in \,\rightarrow ^ 1 \land \, e \in E ^ 1 \land s _ 2 ' = s _ 2) \lor ((s _ 2, e, s _ 2 ') \in \,\rightarrow ^ 2 \land \, e \in E ^ 2 \land s _ 1 ' = s _ 1) \}
				    	\end{align*}
				    	
				    	\intuition{Damit $ \mathcal{T} $ einen Schritt machen kann, muss entweder $ \mathcal{T} ^ 1 $ oder $ \mathcal{T} ^ 2 $ einen Schritt machen.}
				    }
				    
				    \theorem{
				    	Sei $ \mathcal{T} = (S, S _ 0, E, \rightarrow) $ die asynchrone Produktkomposition von $ \mathcal{T} ^ 1 $ und $ \mathcal{T} ^ 2 $.
				    	
				    	Wenn $ E ^ 1 \cap E ^ 2 = \emptyset $ gilt, dann gilt:
				    	\begin{align*}
					    	\rightarrow ^ 1 \, &= \{ (s _ 1, e _ 1, s _ 1 ') \in S ^ 1 \times E ^ 1 \times S ^ 1 \forwhich \exists s _ 2 \in S ^ 2 : ((s _ 1, s _ 2), e _ 1, (s _ 1 ', s _ 2)) \in \,\rightarrow \} \\
					    	\rightarrow ^ 2 \, &= \{ (s _ 2, e _ 2, s _ 2 ') \in S ^ 2 \times E ^ 2 \times S ^ 2 \forwhich \exists s _ 1 \in S ^ 1 : ((s _ 1, s _ 2), e _ 2, (s _ 1, s _ 2 ')) \in \,\rightarrow \} \\
				    	\end{align*}
				    }
				% end
		    % end
	    
		    \section{Ausführung mit Kommunikation}
			    Sollen zwei Komponenten innerhalb eines Modells miteinander kommunizieren, so gibt es folgende Möglichkeiten zur Kommunikation:
			    \begin{description}
			    	\item[Shared Memory] Eine Komponente aktualisiert dem gemeinsamen Speicher; alle anderen Komponenten sehen den aktualisierten Speicher \\
				    	Problematik: Umgang mit Schreibkonflikte
			    	\item[Message Passing] Eine Komponente sendet eine Nachricht, eine anderen Komponente empfängt die Nachricht
			    \end{description}
			    
			    Seien $ \mathcal{T} ^ 1 = (S ^ 1, S _ 0 ^ 1, E ^ 1, \rightarrow ^ 1) $ und $ \mathcal{T} ^ 2 = (S ^ 2, S _ 0 ^ 2, E ^ 2, \rightarrow ^ 2) $ zwei Transitionssysteme.
			    
			    \subsection{Shared Memory (asynchron)}
				    \definition{Speicherkomponierbarkeit}{
				    	Zwei Transitionssysteme $ \mathcal{T} ^ 1 $ und $ \mathcal{T} ^ 2 $ heißen speicherkomponierbar gdw. sich die Zustände in $ S ^ 1 $ und $ S ^ 2 $ in einen lokalen und einen globalen Teil zerlegen lassen, d.h. wenn es $ S _ L ^ 1 $, $ S _ L ^ 2 $ und $ S _ G $ gibt, sodass $ S ^ 1 = S _ L ^ 1 \times S _ G $ und $ S ^ 2 = S _ L ^ 2 \times S _ G $ gelten.
				    	
				    	Der Wertebereich $ S _ G $ modelliert den gemeinsamen Speicher, die Wertebereiche $ S _ L ^ 1 $ und $ S _ L ^ 2 $ modellieren jeweils den lokalen Speicher von $ \mathcal{T} ^ 1 $ und $ \mathcal{T} ^ 2 $.
				    }
				    
				    \definition{Shared Memory Komposition}{
				    	Seien $ \mathcal{T} ^ 1 $ und $ \mathcal{T} ^ 2 $ speicherkomponierbar.
				    	
				    	Dann ergibt die Shared Memory Komposition von $ \mathcal{T} ^ 1 $ und $ \mathcal{T} ^ 2 $ das Transitionssystem $ \mathcal{T} = (S, S _ 0, E, \rightarrow) $, wobei
				    	\begin{align*}
					    	S &\coloneqq S _ L ^ 1 \times S _ L ^ 2 \times S _ G \\
					    	S _ 0 &\coloneqq \{ (s _ L ^ 1, s _ L ^ 2, s _ G) \in S \forwhich (s _ L ^ 1, s _ G) \in S _ 0 ^ 1 \land (s _ L ^ 2, s _ G) \in S _ 0 ^ 2 \} \\
					    	E &\coloneqq E ^ 1 \cup E ^ 2 \\
					    	\rightarrow\, &\coloneqq \{ ((s _ L ^ 1, s _ L ^ 2, s _ G), e, (s _ L ^ {1 '}, s _ L ^ {2 '} , s _ G ' )) \in S \times E \times S \\
						    	& \quad\quad\quad\quad \forwhich (((s _ L ^ 1, s _ G), e, (s _ L ^ {1 '}, s _ G ')) \in \,\rightarrow ^ 1 \land \, e \in E ^ 1 \land s _ L ^ {2 '} = s _ L ^ 2) \lor (((s _ L ^ 2, s _ G), e, (s _ L ^ {2 '}, s _ G ')) \in \rightarrow ^ 2 \land \, e \in E ^ 2 \land s _ L ^ {1 '} = s _ L ^ 1) \} \\
				    	\end{align*}
				    }
			    % end
			    
			    \subsection{Message Passing (asynchron)}
				    \definition{Message Passing Komposition}{
				    	Die Message Passing Komposition von $ \mathcal{T} ^ 1 $ und $ \mathcal{T} ^ 2 $ ergibt das Transitionssystem $ \mathcal{T} = (S, S _ 0, E, \rightarrow) $, wobei
				    	\begin{align*}
					    	S &\coloneqq S ^ 1 \times S ^ 2 \\
					    	S _ 0 &\coloneqq S _ 0 ^ 1 \times S _ 0 ^ 2 \\
					    	E &\coloneqq E ^ 1 \cup E ^ 2 \\
					    	\rightarrow\, &\coloneqq \{ ((s _ 1, s _ 2), e, (s _ 1 ', s _ 2 ')) \in S \times E \times S \\
						    	& \quad\quad\quad\quad \forwhich ((s _ 1, e, s _ 1 ') \in \rightarrow ^ 1 \land \, (s _ 2, e, s _ 2 ') \in \rightarrow ^ 2 \land \, e \in E ^ 1 \cap E ^ 2)  \\
						    	& \quad\quad\quad\quad\quad \lor ((s _ 1, e, s _ 1 ') \in \rightarrow ^ 1 \land \, e \in E ^ 1 \setminus E ^ 2 \land s _ 2 ' = s _ 2) \\
						    	& \quad\quad\quad\quad\quad \lor ((s _ 2, e, s _ 2 ') \in \rightarrow ^ 2 \land \, e \in E ^ 2 \setminus E ^ 1 \land s _ 1 ' = s _ 1) \} \\
				    	\end{align*}
				    	
				    	\intuition{Gemeinsame Ereignisse verursachen einen einen synchronen Zustandsübergang in beiden Komponenten; lokale Ereignisse verursachen nur einen Übergang in einer Komponente.}
				    }
			    % end
			    
			    \subsection{Shared Memory (synchron)}
				    \todo{shared memory synchron}
			    % end
		    % end
		% end
	    
	    \section{Formale Spezifikationssprache}
		    \subsection{Vergleich Transitionssystem}
			    \begin{itemize}
			    	\item Eine Modellierung durch Transitionssysteme geben nur an, welche Transitionen möglich sind, geben aber keine weiterführenden Informationen
			    	\item Systemläufe werden durch Spuren und Historien modelliert (durch induzierte Mengen auf dem Transitionssystem)
			    	\item Mögliche Systemläufe können auch direkt durch Mengen von Spuren/Historien modelliert werden
			    \end{itemize}
		    % end
		    
		    \subsection{Prozesse}
			    \definition{Prozess}{
			    	Ein Prozess $ P $ ist ein Paar $ (E, \textit{Tr}) $, wobei
			    	\begin{description}
			    		\item[$ E $] eine Menge von Ereignissen und
			    		\item[$ \textit{Tr} \subseteq E ^ * \cup (E ^ * \times \{ \surd \}) $] eine nichtleere Menge von Ereignisspuren ist.
			    	\end{description}
			    	Die Menge $ Tr $ muss unter der Präfixbildung abgeschlossen sein, d.h. $ \forall t, t' \in  E ^ * \cup (E ^ * \times \{ \surd \}) : (t \in \textit{Tr} \land t' \leq t) \implies t' \in \textit{Tr} $ muss gelten.
			    	
			    	\intuition{
			    		\begin{itemize}
			    			\item Die Menge $ E $ enthält genau die Ereignisse, an denen das System beteiligt ist.
			    			\item Die Menge $ \textit{Tr} $ enthält genau die Spuren, die für das System möglich sind.
			    		\end{itemize}
			    	}
			    }
			    
			    \definition{Prozessalphabet}{
			    	Die Funktion $ a(\cdot) $ liefert für einen Prozess die Menge an Ereignissen.
			    	
			    	Für $ P = (E, \textit{Tr}) $ gilt somit $ a(P) = E $. Die Menge $ a(P) $ wird als Alphabet von $ P $ bezeichnet.
			    }
			    
			    \definition{Prozessspuren}{
			    	Die Funktion $ \text{traces}(\cdot) $ liefert für einen Prozess die Menge an Spuren.
			    	
			    	Für $ P = (E, \textit{Tr}) $ gilt somit $ a(P) = \textit{Tr} $.
			    }
			    
			    \paragraph{Modellierung des internen Verhaltens}
				    $ E $ wird so definiert, dass jede Ein- und Ausgabeaktion und jede interne Aktion durch ein Ereignis in $ E $ modelliert wird.
			    % end
			    
			    \paragraph{Kommunikation an einer Schnittstelle}
				    $ E $ wird so definiert, dass jede Ein- und Ausgabeaktion durch ein Ereignis in $ E $ modelliert wird. Interne Aktionen werden hierbei nicht modelliert.
			    % end
		    % end
		    
		    \subsection{Modellierung von Anforderungen}
			    \label{sec:anfmod}
		    
			    \definition{Anforderungsmodellierung}{
			    	$ P \textit{sat} S $ spezifiziert, dass der durch $ P $ spezifizierte Prozess die durch $ S $ modellierte Eigenschaft hat.
			    	\begin{itemize}
			    		\item $ P $ ist ein Prozessausdruck
			    		\item $ S $ ist ein Prädikat auf Spuren, d.h. $ S : E ^ * \rightarrow \mathbb{B} $
			    		\item $ P \textit{sat} S $ wird \enquote{$ P $ erfüllt $ S $} gesprochen
			    	\end{itemize}
			    	
			    	\subsubparagraph{Semantik}
				    	\begin{equation*}
					    	\forall \textit{tr} \in \text{traces}(P) : S(\textit{tr})
				    	\end{equation*}
			    	% end
			    }
			    
			    \definition{Anforderungsmodellierung mit Reihenfolge}{
			    	Seien $ E $ ein Alphabet und $ F, G \subseteq E $ beliebig.
			    	
			    	$ P \textit{sat } \text{BEFORE} _ { F, G } $ spezifiziert, dass vor der Ausführung eines Ereignisses aus $ G $ zuvor ein Ereignis aus $ F $ geschehen muss, wobei das Prädikat $ \text{BEFORE} _ { F, G } $ wie folgt spezifiziert ist:
			    	\begin{equation*}
				    	\text{BEFORE} _ { F, G } (\textit{tr}) \coloneqq (\textit{tr} \upharpoonright G \neq ()) \implies (\textit{tr} \upharpoonright F \neq ())
			    	\end{equation*}
			    }
		    % end
		    
		    \subsection{Entwurf einer Spezifikationssprache}
			    \begin{description}
			    	\item[Ziel] Eine formale Sprache zur Spezifikation von Prozessen
			    	\item[Muss-Kriterien] formal; formal definierte Semantik
			    	\item[Kann-Kriterien] möglichst ausdrucksmächtig; möglichst natürlich (nur schwer objektivierbar)
			    	\item[Anatz] \begin{itemize}
			    		\item Entwurf einer Teilsprache für endliche Mengen von Spuren
				    		\begin{itemize}
				    			\item \textit{STOP} und \textit{SKIP}
				    			\item Aktionspräfixe
				    			\item nicht-deterministische Auswahl
				    		\end{itemize}
				    	\item Schrittweise Einführung von Operatoren
					    	\begin{itemize}
					    		\item rekursive Definitionen
					    		\item sequentielle Komposition
					    		\item modulare Spezifikation nebenläufiger Systeme (Synchronisation und Verschachtlung)
					    	\end{itemize}
			    	\end{itemize}
			    \end{description}
			    
			    \subsubsection{Ausdrucksstärke}
				    Dieser Abschnitt beschäftigt sich mit der Ausdrucksstärke der Prozessausdruckssprache, wobei die Sprache auf
				    \begin{grammar}
				    	<P> ::= $ \textit{STOP} _ E $
					    	\alt $ \textit{SKIP} _ E $
					    	\alt $ (X \rightarrow <P>) $
					    	\alt $ (<P> \sqcap <P>) $
				    \end{grammar}
				    beschränkt wird.
			    
				    \theorem{
				    	Jeder Ausdruck der Prozessausdruckssprache spezifiziert einen Prozess $ (E, \textit{Tr}) $ mit endlicher Menge \textit{Tr}.
				    }
				    
				    \definition{Alphabet/Spur zu Prozessausdruck}{
				    	Die Funktion \enquote{\text{process}} liefert für jedes Alphabet $ E $ und jede Spur $ t \in E ^ * \cup (E ^ * \times \{ \surd \}) $ einen Prozessausdruck.
				    	
				    	Die Funktion ist folgendermaßen rekursiv definiert:
				    	\begin{equation*}
					    	\text{process}(E, t) \coloneqq \begin{cases}
						    	\textit{STOP} _ E & \text{wenn } t = () \\
						    	\textit{SKIP} _ E & \text{wenn } t = (\surd) \\
						    	(x \rightarrow \text{process}(E, t')) & \text{wenn } t = (x).t' \land x \neq \surd
					    	\end{cases}
				    	\end{equation*}
				    }
				    
				    \theorem{
				    	Für den Prozessausdruck $ \text{process}(E, t) $ gilt:
				    	\begin{itemize}
				    		\item $ E \cup \{ \surd \} = a(\text{process}(E, t)) \cup \{ \surd \} $
				    		\item $ t \in \text{traces}(\text{process}(E, t)) $
				    		\item $ \text{traces}(\text{process}(E, t)) = \{ t' \in E ^ * \cup (E ^ * \times \{ \surd \}) \forwhich t' \leq t \} $
				    	\end{itemize}
				    }
				    
				    \theorem{Jeder Prozess $ (E, \textit{Tr}) $ mit endlicher und unter Präfixbildung abgeschlossener Menge \textit{Tr} kann durch einen Ausdruck in der oben definierten Prozessausdruckssprache spezifiziert werden.}
			    % end
			    
			    \subsubsection{Syntax/Semantik}
				    \paragraph{Prozessausdruck $ \textit{STOP} _ E $}
					    \definition{Prozessausdruck $ \textit{STOP} _ E $}{
					    	Für jedes Alphabet $ E $ gibt es einen Prozessausdruck $ \textit{STOP} _ E $, welcher ein System modelliert, welches nichts tut.
					    	
					    	\subsubparagraph{Semantik}
						    	\begin{align*}
							    	a(\textit{STOP} _ E) &\coloneqq E \\
							    	\text{traces}(\textit{STOP} _ E) &\coloneqq \{ () \} \\
						    	\end{align*}
							% end
					    }
				    % end
				    
				    \paragraph{Prozessausdruck $ \textit{SKIP} _ E $ (Terminierung)}
					    \definition{Prozessausdruck $ \textit{SKIP} _ E $}{
					    	Für jedes Alphabet $ E $ gibt es einen Prozessausdruck $ \textit{SKIP} _ E $, welcher ein System modelliert, welches terminiert aber sonst nichts tut.
					    	
					    	\subsubparagraph{Semantik}
						    	\begin{align*}
							    	a(\textit{SKIP} _ E) &\coloneqq E \\
							    	\text{traces}(\textit{SKIP} _ E) &\coloneqq \{ (), (\surd) \} \\
						    	\end{align*}
						    % end
					    	
					    	\info{$ () \in \text{traces}(\textit{SKIP} _ E) $ muss gelten, da die Menge sonst nicht unter der Präfixbildung abgeschlossen wäre.}
					    	
					    	\warning{Die Prozessausdrücke $ \textit{STOP} _ E $ und $ \textit{SKIP} _ E $ sind nicht äquivalent.}
					    }
				    % end
				    
				    \paragraph{Prozessausdruck $ (x \rightarrow P) $ (Reihenfolge)}
					    \definition{Prozessausdruck $ (x \rightarrow P) $}{
							Der Prozessausdruck $ (x \rightarrow P) $ spezifiziert einen Prozess, der sich zunächst am Ereignis $ x $ beteiligt und danach die der Prozessausdruck $ P $ verhält.
							\begin{itemize}
								\item $ (x \rightarrow P) $ ist nur dann zulässig, wenn $ x \in a(P) $ und $ x \neq \surd $ gilt.
								\item $ (x \rightarrow P) $ wird \enquote{$ x $ vor $ P $} gesprochen
							\end{itemize}
							
							\subsubparagraph{Semantik}
								\begin{align*}
									a((x \rightarrow P)) &\coloneqq a(P) \\
									\text{traces}((x \rightarrow P)) &\coloneqq \{ () \} \cup \{ (x).t \forwhich t \in \text{traces}(P) \} \\
								\end{align*}
							% end
					    }
				    % end
				    
				    \paragraph{Prozessausdruck $ (P \sqcap Q) $ (nichtdeterministische Wahl)}
					    \definition{Prozessausdruck $ (P \sqcap Q) $}{
					    	Der Prozessausdruck $ (P \sqcap Q) $ spezifiziert einen Prozess, der sich entweder wie der Prozessausdruck $ P $ oder wie der Prozessausdruck $ Q $ verhält, wobei die Entscheidung nicht von dem System beeinflusst werden kann.
					    	\begin{itemize}
					    		\item $ (P \sqcap Q) $ ist nur dann zulässig, wenn $ a(P) = a(Q) $ gilt.
					    		\item $ (P \sqcap Q) $ wird \enquote{$ P $ oder $ Q $} gesprochen
					    	\end{itemize}
					    	
					    	\subsubparagraph{Semantik}
						    	\begin{align*}
							    	a((P \sqcap Q)) &\coloneqq a(P) = a(Q) \\
							    	\text{traces}((P \sqcap Q)) &\coloneqq \text{traces}(P) \cup \text{traces}(Q) \\
						    	\end{align*}
					    	% end
					    }
				    % end
				    
				    \paragraph{Prozessausdruck $ (\sqcap _ { j \in I } P(j)) $ ($ n $-stellige nichtdeterministische Wahl)}
					    \definition{Prozessausdruck $ (\sqcap _ { j \in I } P(j)) $}{
					    	Der Prozessausdruck $ (\sqcap _ { j \in I } P(j)) $ spezifiziert einen Prozess, der sich wie einer der Prozessausdrücke $ P(j) $ verhält, wobei die Entscheidung nicht von dem System beeinflusst werden kann.
					    	\begin{itemize}
					    		\item $ (\sqcap _ { j \in I } P(j)) $ ist nur dann zulässig, wenn $ \forall i, j \in I : a(P(i)) = a(P(j)) $ gilt.
					    	\end{itemize}
					    	
					    	\subsubparagraph{Semantik}
						    	\begin{align*}
							    	a((\sqcap _ { j \in I } P(j))) &\coloneqq a(P(j)) \text{ (für ein beliebiges )} j \in I \\
							    	\text{traces}((\sqcap _ { j \in I } P(j))) &\coloneqq \bigcup _ { j \in I } \text{traces}(P(j)) \\
						    	\end{align*}
					    	% end
					    }
				    % end
				    
				    \paragraph{Prozessausdruck $ (P \,\square\, Q) $ (deterministische Wahl)}
					    \definition{Prozessausdruck $ (P \,\square\, Q) $}{
					    	Der Prozessausdruck $ (P \,\square\, Q) $ spezifiziert einen Prozess, der sich entweder wie der Prozessausdruck $ P $ oder wie der Prozessausdruck $ Q $ verhält, wobei die Entscheidung von dem System beeinflusst werden kann.
					    	\begin{itemize}
					    		\item $ (P \,\square\, Q) $ ist nur dann zulässig, wenn $ a(P) = a(Q) $ gilt.
					    		\item $ (P \,\square\, Q) $ wird \enquote{$ P $ Wahl $ Q $} gesprochen
					    	\end{itemize}
					    	
					    	\subsubparagraph{Semantik}
						    	\begin{align*}
							    	a((P \,\square\, Q)) &\coloneqq a(P) = a(Q) \\
							    	\text{traces}((P \,\square\, Q)) &\coloneqq \text{traces}(P) \cup \text{traces}(Q) \\
						    	\end{align*}
					    	% end
					    }
				    % end
				    
				    \paragraph{Prozessausdruck $ (\square _ { j \in I } P(j)) $ ($ n $-stellige deterministische Wahl)}
					    \definition{Prozessausdruck $ (\square _ { j \in I } P(j)) $}{
					    	Der Prozessausdruck $ (\square _ { j \in I } P(j)) $ spezifiziert einen Prozess, der sich wie einer der Prozessausdrücke $ P(j) $ verhält, wobei die Entscheidung von dem System beeinflusst werden kann.
					    	\begin{itemize}
					    		\item $ (\square _ { j \in I } P(j)) $ ist nur dann zulässig, wenn $ \forall i, j \in I : a(P(i)) = a(P(j)) $ gilt.
					    	\end{itemize}
					    	
					    	\subsubparagraph{Semantik}
						    	\begin{align*}
							    	a((\square _ { j \in I } P(j))) &\coloneqq a(P(j)) \text{ (für ein beliebiges )} j \in I \\
							    	\text{traces}((\square _ { j \in I } P(j))) &\coloneqq \bigcup _ { j \in I } \text{traces}(P(j)) \\
						    	\end{align*}
					    	% end
					    }
				    % end
				    
				    \paragraph{Prozessausdruck $ (P ; Q) $ (Konkatenation)}
					    \definition{Prozessausdruck $ (P ; Q) $}{
					    	Der Prozessausdruck $ (P ; Q) $ spezifiziert einen Prozess, der sich erst wie der Prozessausdruck $ P $ verhält und anschließend wie der Prozessausdruck $ Q $.
					    	\begin{itemize}
					    		\item $ (P ; Q) $ ist nur dann zulässig, wenn $ a(P) = a(Q) $ gilt.
					    		\item $ (P ; Q) $ wird \enquote{$ P $ und danach $ Q $} gesprochen
					    	\end{itemize}
					    	
					    	\subsubparagraph{Semantik}
						    	\begin{align*}
							    	a((P ; Q)) &\coloneqq a(P) = a(Q) \\
							    	\text{traces}((P ; Q)) &\coloneqq \{ s \in \text{traces}(P) \forwhich a \upharpoonright \{ \surd \} = () \} \cup \{ s.t \forwhich s.(\surd) \in \text{traces}(P) \land t \in \text{traces}(Q) \} \\
						    	\end{align*}
					    	% end
					    }
				    % end
				    
				    \paragraph{Prozessausdruck $ (P \parallel Q) $ (Synchrone Komposition)}
					    \definition{Prozessausdruck $ (P \parallel Q) $}{
					    	Der Prozessausdruck $ (P \parallel Q) $ spezifiziert einen Prozess, der die durch $ P $ und $ Q $ spezifizierten Prozesse nebenläufig synchron ablaufen lässt.
					    	\begin{itemize}
					    		\item $ (P \parallel Q) $ ist nur dann zulässig, wenn $ a(P) \neq a(Q) $ gilt.
					    		\item $ (P \parallel Q) $ wird \enquote{$ P $ parallel $ Q $} gesprochen
					    	\end{itemize}
					    	
					    	\subsubparagraph{Semantik}
						    	\begin{align*}
							    	a((P \parallel Q)) &\coloneqq a(P) \cup a(Q) \\
							    	\text{traces}((P \parallel Q)) &\coloneqq \{ t \in (a(P) \cup a(Q)) ^ * \forwhich (t \upharpoonright (a(P))) \in \text{traces}(P) \land (t \upharpoonright (a(Q))) \in \text{traces}(Q) \} \\
						    	\end{align*}
					    	% end
					    }
				    % end
				    
				    \paragraph{Prozessausdruck $ (P \parallelAsync Q) $ (Asynchrone Komposition)}
					    \definition{Prozessausdruck $ (P \parallelAsync Q) $}{
					    	Der Prozessausdruck $ (P \parallelAsync Q) $ spezifiziert einen Prozess, der die durch $ P $ und $ Q $ spezifizierten Prozesse nebenläufig asynchron ablaufen lässt.
					    	\begin{itemize}
					    		\item $ (P \parallelAsync Q) $ ist nur dann zulässig, wenn $ a(P) = a(Q) $ gilt.
					    		\item $ (P \parallelAsync Q) $ wird \enquote{$ P $ verschachtelt $ Q $} gesprochen
					    	\end{itemize}
					    	
					    	\subsubparagraph{Semantik}
						    	\begin{align*}
							    	a((P \parallelAsync Q)) &\coloneqq a(P) = a(Q) \\
							    	\text{traces}((P \parallelAsync Q)) &\coloneqq \{ s \in (a(P) \cup a(Q)) ^ * \forwhich \exists t \in \text{traces}(P) : \exists u \in \text{traces}(Q) : s \in \text{Interleaving}(t, u) \} \\
						    	\end{align*}
					    	% end
					    }
				    % end
				    
				    \paragraph{Prozessausdruck $ \mu X : E.F(X) $ (Fixpunktoperator)}
					    Zur Vermeidung von rekursiven Gleichungssystemen kann ein Fixpunktoperator eingeführt werden.
					    
					    \definition{Fixpunktoperator}{
					    	Sei $ F $ eine Funktion, die für jeden Prozessbezeichner $ \textit{id} \in \textit{ID} $ einen Prozessausdruck liefert.
					    	
					    	Dann spezifiziert der Prozessausdruck $ \mu X : E.F(X) $ einen Prozess $ X $ mit Alphabet $ E $, der sich entsprechend des Ausdrucks $ F(X) $ verhält.
					    	\begin{itemize}
					    		\item $ \mu X : E.F(X) $ ist nur dann zulässig, wenn $ F(X) $ nur Ereignisse enthält, die in der Menge $ E $ vorhanden sind und wenn jedes Vorkommen von $ X $ in $ F(X) $ bewacht ist.
					    	\end{itemize}
					    	
					    	\subsubparagraph{Semantik}
						    	\begin{align*}
							    	a(\mu X : E.F(X)) &\coloneqq E \\
							    	\text{traces}(\mu X : E.F(X)) &\coloneqq \text{Menge der Spuren zur Lösung der Gleichung } X = _ E F(X) \\
						    	\end{align*}
					    	% end
					    }
				    % end
			    % end
			    
			    \subsubsection{Unendliche Systeme}
				    Unendliche Systeme lassen sich beispielsweise durch eine unendliche Menge von Spuren modellieren.
				    
				    \paragraph{Rekursive Gleichungssysteme}
					    \subparagraph{Ansatz}
						    Ein Prozess wird durch mehrere Prozessausdrücke aus der oben spezifizierten Prozessausdruckssprache, welche die genannten Seitenbedingungen erfüllen, durch eine Menge von Gleichungen der Form \[ \textit{id} = _ E P \forwhich \textit{id} \in \textit{ID} \] spezifiziert, wobei \textit{ID} eine Menge von Prozessbezeichnern ist und $ E $  das Alphabet des durch \textit{id} bezeichneten Prozess angibt.
						    
						    Ereignisse dürfen eben so wenig wie Bestandteile der Sprache (bspw. $ \textit{STOP} _ E $) als Bezeichner verwendet werden.
						    
						    \warning{Das Gleichungssystem darf für jeden Prozessbezeichner $ \textit{id} \in \textit{ID} $ nur genau eine Gleichung enthalten, in der \textit{id} auf der linken Seite auftritt.}
						    
						    \warning{Das Gleichungssystem darf nur Gleichungen enthalten, deren rechte Seite \enquote{bewacht} ist. Das heißt, für jedes Vorkommen eines Bezeichners $ \textit{id}' $ auf der rechten Seite einer Gleichung $ \textit{id} = _ E P $ muss es einen Teilausdruck $ (x \rightarrow P') $ geben, der das Vorkommen von $ \textit{id}' $ enthält. Das Ereignis $ x $ heißt Wächter.}
					    % end
					    
						\subparagraph{Semantik}
							Sei \textit{ID} eine Menge von Prozessbezeichnern, \textit{GS} eine Menge von Gleichungen der Form $ \{ \textit{id} = _ E P \forwhich \textit{id} \in \textit{ID} \} $, sodass \textit{GS} genau eine Gleichung für jeden Prozessbezeichner $ \textit{id} \in \textit{ID} $ enthält und jede Gleichung in \textit{GS} bewacht ist.
							
							Die Semantik eines Prozessausdruck \textit{id} unter \textit{GS} ist wie folgt definiert:
							\begin{align*}
								a(\textit{id}) &\coloneqq E \tag{$ (\textit{id} = _ E P) \in \textit{GS} $} \\
								\text{traces}(\textit{id}) &\coloneqq \textit{Tr} \tag{$ (\textit{id} = _ E P) \in \textit{GS} $ und \textit{Tr} Lösung von $ \text{traces}(\textit{id}) = \text{traces}(P) $} \\
							\end{align*}
						% end
				    % end
			    % end
		    % end
	    % end
	    
	    \section{Modellierung von Systemeigenschaften}
		    Zur Modellierung von Anforderungen wird angenommen, dass bestimmte Strukturen im Modell definiert werden (bspw. Zustände durch Funktionen), auf denen die Anforderungen aufbauen.
		    
			Sei $ \mathcal{T} = (S, S _ 0, E, \rightarrow) $ ein Transitionssystem, welches das Systemverhalten als Systemmodell darstellt. Anforderungen an das System können nur mit Hilfe prädikatenlogischer Formeln auf dem Transitionssystem modelliert werden. \\
			Die Modellierung der Anforderungen durch ein Prädikaten $ K $ ist angemessen, wenn gilt
			\begin{itemize}
				\item $ K(\mathcal{T}) $ gilt für ein Transitionssystem, $ \mathcal{T} = (S, S _ 0, E, \rightarrow) $ gdw.
				\item das durch $ \mathcal{T} $ modellierte System die durch $ K $ modellierte Anforderung erfüllt.
			\end{itemize}
	    
		    Siehe auch \ref{sec:anfmod} für Notationen zur Anforderungsmodellierung auf Prozessausdrücken.
		    
		    \subsection{Beispiel: Modellierung einer Robotersteuerung}
			    \todo{13.8, 13.9, 13.10, 13.11, 13.12, 13.13, 13.14, 13.15}
		    % end
		    
		    \subsection{Beispiel: Sicherheitslücke in einem Kommunikationsprotokoll}
			    \todo{13.19, 13.20, 13.21, 13.22, 13.23, 13.24, 13.25, 13.28, 13.29}
		    % end
	    % end
    % end
\end{document}
